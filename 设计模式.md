# 设计模式

## 分类

总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

## 单例模式

单例模式确保某个类只有一个实例，而且自行实例化并向其他所有对象提供这个实例。

### 懒汉式单例:

```java
//在第一次调用时实例化自己
public class Singleton{
    private Singleton(){}
    private static Singleton single=null;
    public static Singleton getInstance(){
        if(single==null){
            single=new Singleton();
        }
        return single;
    }
}
```

### 饿汉式单例:

```java
//类初始化时即已经自行实例化
public class Singleton(){
    private Singleton(){}
    private static Singleton single=new Singleton();
    public static Singleton getInstance(){
    	return single;
    }
}
```

### 双重锁模式:

```java
//双重检查模式，进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避免多线程问题。
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getInstance () {  
        if (singleton == null) {  
            synchronized (Singleton.class) {  
                if (singleton == null) {  
                	singleton = new Singleton();
                }  
            } 
        }  
        return singleton;  
    }  
}
```

### 单例模式结合HASHMAP实现缓存

```java
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getInstance () {  
        if (singleton == null) {  
            synchronized (Singleton.class) {  
                if (singleton == null) {  
                	singleton = new Singleton();
                }  
            } 
        }  
        return singleton;  
    }  
    
    private Map<String, Object> cacheDataMap = new ConcurrentHashMap<String, Object>();
    public Map<String, Portalbas> getCacheDataMap() {
		return cacheDataMap;
	}

	public void setCacheDataMap(Map<String, Object> cacheDataMap) {
		this.cacheDataMap = cacheDataMap;
	}
    
    /*
    public void addCacheData(String key,Object obj){
        cacheDataMap.put(key,obj);
    }
    public Object getCacheData(String key){
        return cacheDataMap.get(key);
    }
    public void removeCacheData(String key){
    	if(cacheDataMap.containsKey(key)){
            cacheDataMap.remove(key);
        }
    }
    */
}
```



## 工厂方法模式

定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。

结构：工厂方法模式的主要角色如下。

抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。

具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。

抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。（只有一类产品）

具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。

如：A牧场产牛，B牧场产羊，AFarm.newAnimals();

## 抽象工厂模式

​	定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。

​	结构：抽象工厂模式的主要角色如下。

抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。

具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。

抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。（拥有多类产品）

具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。

如：A工厂产牛，水果，B工厂产羊，蔬菜，AFarm.newAnimals(),AFarm.newPlants();

两者都是始终由一家工厂创建类对象

## 装饰器模式

定义：指在不改变现有对象结构的情况下，动态地给该对象增加额外功能的模式。

结构：装饰模式主要包含以下角色。

抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。

具体构件（Concrete   Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。

抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。

具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

## 代理模式

在不改变源码的情况下，实现对目标对象的功能扩展。

注：只有标黄的部分是需要自己写出，其余部分全都是固定代码。

### 静态代理

public interface ISinger {

   void sing();

 }

 /**

  \*  目标对象实现了某一接口

  */

 public class Singer implements ISinger{

   public void sing(){

​     System.out.println("唱一首歌");

   }  

 }

 /**

 \*  代理对象和目标对象实现相同的接口

 */

 public class SingerProxy implements ISinger{

   // 接收目标对象，以便调用sing方法

   private ISinger target;

   public UserDaoProxy(ISinger target){

​     this.target=target;

   }

   // 对目标对象的sing方法进行功能扩展

   public void sing() {

​     System.out.println("向观众问好");

​     target.sing();

​     System.out.println("谢谢大家");

   }

 } 

 /**

  \* 测试类

  */

 public class Test {

   public static void main(String[] args) {

​     //目标对象

​     ISinger target = new Singer();

​     //代理对象

​     ISinger proxy = new SingerProxy(target);

​     //执行的是代理的方法

​     proxy.sing();

   }

 }

　　总结：其实这里做的事情无非就是，创建一个代理类SingerProxy，继承了ISinger接口并实现了其中的方法。只不过这种实现特意包含了目标对象的方法，正是这种特征使得看起来像是“扩展”了目标对象的方法。假使代理对象中只是简单地对sing方法做了另一种实现而没有包含目标对象的方法，也就不能算作代理模式了。所以这里的包含是关键。

 

缺点：这种实现方式很直观也很简单，但其缺点是代理对象必须提前写出

### 动态代理（也叫JDK代理）

调用Proxy类的静态方法newProxyInstance即可，该方法会返回代理类对象

static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces,InvocationHandler h )

接收的三个参数依次为:

ClassLoader loader：指定当前目标对象使用类加载器，写法固定

Class<?>[] interfaces：目标对象实现的接口的类型，写法固定

InvocationHandler h：事件处理接口，需传入一个实现类，一般直接使用匿名内部类

 

public interface ISinger {

  void sing();

}

/**

 \*  目标对象实现了某一接口

 */

public class Singer implements ISinger{

  public void sing(){

​    System.out.println("唱一首歌");

  }  

}

public class Test{

  public static void main(String[] args) {

 Singer target = new Singer();

​    ISinger proxy  = (ISinger) Proxy.newProxyInstance(

​        target.getClass().getClassLoader(),

​        target.getClass().getInterfaces(),

​        new InvocationHandler() {

​          @Override

​          public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

​            System.out.println("向观众问好");

​            //执行目标对象方法

​            Object returnValue = method.invoke(target, args);

​            System.out.println("谢谢大家");

​            return returnValue;

​          }

​        });

​    proxy.sing();

  }

}

动态代理跟静态代理的区别：动态代理是在运行时刻运用反射机制动态的创建出代理类及其对象。静态代理是在编译的时候就确定了代理类具体类型，如果有多个类需要代理，那么就得创建多个。

缺点：可以看出静态代理和JDK代理有一个共同的缺点，就是目标对象必须实现一个或多个接口，加入没有，则可以使用Cglib代理。

#### Cglib代理

没有通过接口定义的类，CGLib采用动态创建子类的方式生成代理对象，动态创建代理实例。（所以不能对目标类中的private、final等方法进行代理）。

/**

 \* 目标对象,没有实现任何接口

 */

public class Singer{

  public void sing() {

​    System.out.println("唱一首歌");

  }

}

/**

 \* Cglib子类代理工厂

 */

public class ProxyFactory implements MethodInterceptor{

  // 维护目标对象

  private Object target;

  public ProxyFactory(Object target) {

​    this.target = target;

  }

 

  // 给目标对象创建一个代理对象

  public Object getProxyInstance(){

​    //1.工具类

​    Enhancer en = new Enhancer();

​    //2.设置父类

​    en.setSuperclass(target.getClass());

​    //3.设置回调函数

​    en.setCallback(this);

​    //4.创建子类(代理对象)

​    return en.create();

  }

 

  @Override

  public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {

​    System.out.println("向观众问好");

​    //执行目标对象的方法

​    Object returnValue = method.invoke(target, args);

​    System.out.println("谢谢大家");

​    return returnValue;

  }

}

/**

 \* 测试类

 */

public class Test{

  public static void main(String[] args){

​    //目标对象

​    Singer target = new Singer();

​    //代理对象

​    Singer proxy = (Singer)new ProxyFactory(target).getProxyInstance();

​    //执行代理对象的方法

​    proxy.sing();

  }

}
# 设计模式

## 分类

总体来说设计模式分为三大类：

创建型模式，共五种：单例模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

## 创建型模式

### 单例模式

单例模式确保某个类只有一个实例，而且自行实例化并向其他所有对象提供这个实例。

#### 饿汉式单例

```java
//在类加载的时候创建实例对象。不会出现线程安全，JVM在类加载时保证只会有一个线程去执行类的初始化方法
public class Singleton(){
    private Singleton(){}
    private static Singleton single=new Singleton();
    public static Singleton getInstance(){
    	return single;
    }
}
```

#### 懒汉式单例

```java
//在第一次调用时实例化自己，会出现线程安全
public class Singleton{
    private Singleton(){}
    private static Singleton single=null;
    public static Singleton getInstance(){
        if(single==null){
            single=new Singleton();
        }
        return single;
    }
}
```

#### 双重锁模式

```java
//双重检查模式，进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避免多线程问题。
public class Singleton {  
    
	/*
	new 不是一个原子操作 ,指令可能会重排序
	1、重排序：先分配内存，让 instance 指向这块内存 ，然后执行对象的初始化 ，这种会有问题，在初始化执行没有完成 ，这时候 cpu 切换时间片 ，
    导致其他线程执行第一个判断不为空，直接返回 ，但是对象还没有初始化完
    2、正常排序：先分配内存，然后对象初始化，让 instance 指向这个内存
    总结 ： valotile 修饰变量，指令不会重排序 ，也就是上面的步骤2
	*/
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getInstance () {
        if (singleton == null) {  
            
            //将判断为空和new操作原子化，同时synchronized也保证了内存可见
            synchronized (Singleton.class) {  
                if (singleton == null) {  
                	singleton = new Singleton();
                }  
            } 
            
        }  
        return singleton;  
    }  
}
```

##### 单例模式结合HASHMAP实现缓存

```java
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getInstance () {  
        if (singleton == null) {  
            synchronized (Singleton.class) {  
                if (singleton == null) {  
                	singleton = new Singleton();
                }  
            } 
        }  
        return singleton;  
    }  
    
    private Map<String, Object> cacheDataMap = new ConcurrentHashMap<String, Object>();
    public Map<String, Portalbas> getCacheDataMap() {
		return cacheDataMap;
	}

	public void setCacheDataMap(Map<String, Object> cacheDataMap) {
		this.cacheDataMap = cacheDataMap;
	}
    
    /*
    public void addCacheData(String key,Object obj){
        cacheDataMap.put(key,obj);
    }
    public Object getCacheData(String key){
        return cacheDataMap.get(key);
    }
    public void removeCacheData(String key){
    	if(cacheDataMap.containsKey(key)){
            cacheDataMap.remove(key);
        }
    }
    */
}
```

#### 静态内部类单例模式

- 外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化instance，故而不占内存。
- 只有第一次调用getInstance()方法会导致虚拟机加载SingleTonHoler类，才会去初始化instance。
- 这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化，但是由于是静态内部类的形式去创建单例的，故外部无法传递参数进去。

```java
public class SingleTon {
    private SingleTon() {}
    private static class SingleTonHoler {
        private static SingleTon instance = new SingleTon();
    }
    public static SingleTon getInstance() {
        return SingleTonHoler.instance;
    }
}
```

#### 枚举单例模式

默认枚举实例的创建是线程安全的，并且在任何情况下都是单例。实际上

- 枚举类隐藏了私有的构造器。
- 枚举类的域是相应类型的一个实例对象

```java
public enum Singleton {
    INSTANCE;
    //可以省略此方法，通过Singleton.INSTANCE进行操作
    public static Singleton getInstance() {
        return Singleton.INSTANCE;
    }
}
```

## 结构型模式

创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。其中，单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。

结构型模式。结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。 

### 代理模式

为其他对象提供一种代理，以控制对这个对象的访问；通过代理对象访问目标对象，可以增强额外的操作，扩展目标对象的功能；

#### 静态代理 

静态就是程序运行之前就已经存在代理类的字节码文件

```java
public interface UserService {
    public void login(String username,String password);
    public String logout();
}

public class UserServiceImpl implements UserService {
    @Override
    public void login(String username, String password) {
        System.out.println("UserServiceImpl.login:"+username+","+password);
    }

	 @Override
    public String logout() {
        System.out.println("UserServiceImpl.logout");
        return "byebye";
    }
}

//代理的三要素：
//1.目标类的接口
//2.目标类的实例
//3.交叉业务逻辑，要执行的操作
//代理对象需要和目标对象实现相同的接口
public class UserServiceProxy implements UserService {
    
    private UserService userService=new UserServiceImpl();

    @Override
    public void login(String username, String password) {
        try {
            Method method = userService.getClass().getMethod("login", String.class, String.class);
            invoke(method,username,password);
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
    }

    @Override
    public String logout() {
        try {
            Method method = userService.getClass().getMethod("logout");
            return invoke(method).toString();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
        return null;
    }

    //封装到公共方法中，统一入口，模块化
    private Object invoke(Method method,Object...args){
        //1.打印日志
        System.out.println(method.getName()+" 启动 at:["+new Date().getTime()+"]");
        //2.执行业务
        try {
            return method.invoke(userService,args);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        return null;
    }
} 
 
public static void main(String[] args) {
    UserService userService=new UserServiceProxy();
    userService.login("admin","123");
    System.out.println(userService.logout());
} 
```

缺点：这种实现方式很直观也很简单，但其缺点是代理对象必须提前写出

#### 动态代理

代理类是程序在运行期间由JVM根据反射等机制动态生成的，自动生成代理类和代理对象 。

所谓动态就是指在程序运行前不存在代理类的字节码文件。

##### JDK动态代理

目标对象必须实现一个或多个接口，如果没有实现任何接口，则无法使用jdk的动态代理

```java
public static void main(String[] args) {
    //调用Proxy类的newProxyInstance()方法动态的生成代理类和实例
    UserService userService= (UserService) Proxy.newProxyInstance(
            UserServiceImpl.class.getClassLoader(), //目标类的类加载器
            new Class[]{UserService.class}, //目标类的接口列表
            new InvocationHandler() { //交叉业务逻辑
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    //1.打印日志
                    System.out.println(method.getName()+" login at:["+new Date().getTime()+"]");
                    //2.执行业务
                    System.out.println("开启事务。。。。");
                    Object returnValue = null;
                    try {
                        returnValue = method.invoke(new UserServiceImpl(), args);
                        System.out.println("提交事务。。。。。");
                    } catch  (Exception e) {
                        System.out.println("回滚事务。。。。。");
                        throw e; //一定要抛出异常
                    }
                    return returnValue;
                }
            }
    );

    userService.login("admin","123");
    System.out.println("-------------------------------------------------");
    System.out.println(userService.logout());
    //代理类的类型
    System.out.println(userService.getClass());
}
```

缺点：可以看出静态代理和JDK代理有一个共同的缺点，就是目标对象必须实现一个或多个接口。

##### Cglib代理

没有实现接口，CGLib采用动态创建子类的方式生成代理对象，动态创建代理实例。（所以不能对目标类中的private、final等方法进行代理）。JDK1.8中JDK代理比cglib代理性能更好

```java
public static void main(String[] args) {

	HelloWorld helloWorld = (HelloWorld) Enhancer.create(
            HelloWorld.class, //目标类的类型
            new InvocationHandler() { //交叉业务逻辑
                @Override
                public Object invoke(Object o, Method method, Object[] args) throws Throwable {
                    System.out.println(method.getName() + " start at:[" + new Date().getTime() + "]");
                    return method.invoke(new HelloWorld(), args);
                }
            }
    );

    helloWorld.sayHello();
    //代理类的类型
    System.out.println(helloWorld.getClass());
}
```


## 项目实际使用

### 工厂模式应用

```java
// 定义统一接口
public interface TemplateRegisterService {
    void registerTemplate(ConfigRegisterDomain config);
}

// 定义实现类的接口降低耦合
public interface DataProductTemplateService extends TemplateRegisterService {}

public interface APITemplateService extends TemplateRegisterService {}
```

```java
// 实现统一接口，可以将抽取的公共方法放在这里
@Service
@Slf4j
public class TemplateRegisterServiceImpl implements TemplateRegisterService {
    @Autowired
    private TemplateHistoryService templateHistoryService;
    
    @Override
    public void registerTemplate(ConfigRegisterDomain config) {
        log.error("use the correct implementation class.");
    }

    public void handleRegisterResult(String batchNo, String templatePath,
        List<List<String>> responseLists, String feedbackName) {
        TemplateHistoryVO templateHistoryVO = TemplateRegisterUtils.getTemplateRegisterInfo(batchNo);
        ......
    }
}
```

```java
@Service
@Slf4j
public class DataProductTemplateServiceImpl extends TemplateRegisterServiceImpl implements DataProductTemplateService {
    @Override
    public void registerTemplate(ConfigRegisterDomain config) {
        ......
        super.handleRegisterResult(
                config.getBatchNo(), config.getTemplatePath(), responseLists, AppConstant.FEEDBACK_NAME_DATAPRODUCT);
    }
}

@Service
@Slf4j
public class APITemplateServiceImpl extends TemplateRegisterServiceImpl implements APITemplateService {
    @Override
    public void registerTemplate(ConfigRegisterDomain config) {
        ......
        super.handleRegisterResult(config.getBatchNo(), config.getTemplatePath(), responseLists,
            AppConstant.FEEDBACK_NAME_API);
    }
}
```

```java
// 代码调用
TemplateRegisterService templateRegisterService;
switch (assetType) {
    case AppConstant.MODEL_ASSETTYPE:
        templateRegisterService = SpringUtils.getBean(DataModelTemplateService.class);
        break;
    case AppConstant.REPORT_ASSETTYPE:
        templateRegisterService = SpringUtils.getBean(ReportTemplateService.class);
        break;
    case AppConstant.API_ASSETTYPE:
        templateRegisterService = SpringUtils.getBean(APITemplateService.class);
        break;
    case AppConstant.DATAPRODUCT_ASSETTYPE:
        templateRegisterService = SpringUtils.getBean(DataProductTemplateService.class);
        break;
    default:
        templateRegisterService = null;
        break;
}
templateRegisterService.registerTemplate(config);
```

```java
@Component
public class SpringUtils implements ApplicationContextAware {
    private static ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        if (SpringUtils.applicationContext == null) {
            SpringUtils.applicationContext = applicationContext;
        }
    }

    // 获取applicationContext
    public static ApplicationContext getApplicationContext() {
        return applicationContext;
    }

    public static Object getBean(String name) {
        return getApplicationContext().getBean(name);
    }

    public static <T> T getBean(Class<T> clazz) {
        return getApplicationContext().getBean(clazz);
    }

    public static <T> T getBean(String name, Class<T> clazz) {
        return getApplicationContext().getBean(name, clazz);
    }
}
```

### 原型模式应用

[BeanUtils](https://blog.csdn.net/Munger6/article/details/103196595)



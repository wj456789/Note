# 软件结构

## 六大设计原则

### SOLID原则

面向对象设计五个基本原则 ：

- 单一功能原则（SRP）：表明一个类有且只有一个职责。

- 开闭原则（OCP）：一个类应该对扩展开放，对修改关闭。

- 里氏替换原则（LSP）：派生的子类应该是可替换基类的，也就是说将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立 。通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能 ，子类必须拥有父类的属性和方法。

- 接口分离原则（ISP）：表明类不应该被迫依赖他们不使用的方法，也就是说一个接口应该拥有尽可能少的行为，它是精简的，也是单一的。

- 依赖反转原则（DIP）：表明高层模块不应该依赖低层模块，他们都应该依赖抽象类或者接口。这意味着不应该在高层模块中使用具体的低层模块。

  ```java
  class Program {
      public void work() {
  
      }
  }
  
  class Engineer {
      Program program;
  
      public void setProgram(Program p) {
          program = p;
      }
  
      public void manage() {
          program.work();
      }
  }
  //这里我们的类Engineer就是上层类，底层的类就是Program。
  //这时引入新的类SuperProgram 会对Engineer类造成影响，必须修改Engineer类 
  ```

  ```java
  //通过IProgram接口添加抽象层
  interface IProgram {
      public void work();
  }
  
  class Program implements IProgram {
      public void work() {}
  }
  
  class SuperProgram implements IProgram {
      public void work() {}
  }
  
  class Engineer {
      IProgram program;
  
      public void setProgram(IProgram p) {
          program = p;
      }
  
      public void manage() {
          program.work();
      }
  }
  ```

### 迪米特原则

是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则，尽量降低类与类之间的耦合度。 







## 软件建模

软件建模通过模型指导软件系统的具体实现，模型并不是软件系统的一个完备表示，而是所研究的系统的一种抽象。

### 概念

**软件建模原则：**

模型是抽象的，是选取系统某个最显著的特征并进行简化表示，因此需要通过不同的视角采用不同模型来表示：

- 外部视角：这个是站在系统之外来描述这个系统，描述系统所处的位置环境和系统的边界等，举个例子：假如我们所描述的软件系统是一个更大系统里的一个子系统，那么站在外部视角就是描述这个子系统在整个系统中的位置以及与其它子系统的层级关系，另外还要描述这个子系统的职责范围，哪些是这个子系统负责的，哪些不是。
- 交互视角：是描述系统与使用者之间有哪些交互，该系统对外提供哪些功能等。
- 结构化视角：是描述系统的组成结构，描述系统由哪些对象组成，拥有哪些数据，比如：前面谈到的图书馆管理系统中，借阅者是一个对象，他有姓名，身份证号一些属性，它他有借书，还书等一些活动方法；书也是一个对象，有书名，编号的信息，以及当前是否被借的状态等等，那么这些对象的属性和方法，就通过结构化的视角来描述
- 行为视角：描述系统动态的行为，比如前面所描述的用户登录过程。

**软件建模方法：**

- 结构化方法 (Structured Method)
- 面向对象方法（Object Oriented Method）
- 基于构件方法（Component Based Development）
- 面向服务方法（Service Oriented Method）
- 面向方面方法（Aspect Oriented Method）
- 模型驱动方法 （Model Driven Development）
- 形式化方法 (Formal Method)

**软件建模工具：**

随着面向对象技术的不断发展和应用，形成了面向对象的建模标准，即UML(Unified Modeling Language)统一建模语言， 是面向对象开发中一种通用的图形化建模语言。

### UML

UML由三部分组成：事物，关系和图 

- 事物是UML中重要的组成部分，是UML模型中最基本的面向对象的构造块，就好比英文中的26个字母，根据事物的属性和用途，又分为 结构、行为、组织、辅助四大类。
- 关系：是把事物紧密联系在一起，主要有四种： 关联，依赖，泛化和实现。
- 图：是多个有相互关系的事物组成的组；图一般分为9种，根据其用途和性质可以将这9种图分为静态和动态两大类，静态图用于描述软件系统的静态结构组成，动态图用于描述软件系统的动态活动过程。

关于事物，关系和图，可以简单理解为，点线面的关系，每一个事物是一个点，关系把它们连起来，多组事物和关系结合起来形成一张图。

#### UML模型图

| 图                             | 用途                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| 用例图   Use-Case Diagram      | 用于描述角色以及角色与用例之间的连接关系（如：泛化、关联和依赖）；说明的是谁要使用系统，以及他们使用该系统可以做些什么。是一种静态模型。 |
| 类图   Class Diagram           | 用于描述系统中的类，以及各个类之间的关系（如：泛化、实现、依赖、关联、聚合、组合）。是一种静态模型。 |
| 对象图   Object   Diagram      | 与类图极为相似，它是类图的实例，对象图显示类的多个对象实例，而不是实际的类。它描述的不是类之间的关系，而是对象之间的关系。是一种静态模型。 |
| 状态图   State Diagram         | 用于描述类的对象所有可能的状态，以及事件发生时状态的转移条件，是对类图行为上的补充。是一种动态模型。 |
| 活动图   Activity Diagram      | 用于描述用例要求所要进行的活动，以及活动间的约束关系，有利于识别并行活动。是一种动态模型。 |
| 顺序图   Sequence Diagram      | 也叫序列图或时序图，用于描述参与者与系统对象之间有序的交互过程，强调消息是如何在对象之间被发送和接收的。是一种动态模型。 |
| 合作图   Communication Diagram | 也叫协作图，和顺序图相似，用于描述对象间的动态合作关系。可以看成是类图和顺序图的交集，重点描述对象之间的相互通信关系。如果强调时间和顺序，则使用序列图；如果强调上下级关系，则选择合作图。是一种动态模型。 |
| 组件图   Component Diagram     | 也叫构件图，用于描述代码构件的物理结构以及各种构件之间的依赖关系。是一种静态模型。 |
| 部署图   Deployment Diagram    | 用于描述系统的物理部署。例如计算机和设备，以及它们之间是如何连接的。是一种静态模型。 |

##### UML4+1视图

###### 4

**逻辑视图：**类图、对象图

**实现视图：**组件图 

**行为视图：**顺序图、合作图、状态图、活动图

**部署视图：**部署图 

###### 1

**用例视图：**用例图

#### UML建模

软件开发流程：需求分析 -> 概要设计 -> 详细设计 -> 编码阶段 -> 测试

常用模型图：用例图 -> 类图、对象图\合作图、状态图、顺序图、活动图 -> 类图、对象图\合作图、状态图、顺序图、活动图 -> / -> 类图、组件图、部署图

##### 案例 - 图书馆管理系统建模 

**需求分析：**

- 借阅者的基本业务功能：支持查询、借阅，续借，预约/撤销，归还图书；支持查询历史借阅记录，缴纳罚款；不同类型的借阅者（如：老师、学生）一次借阅的书本数量和最大借阅时长限制可以不同。
- 图书管理员的基本业务功能：支持图书出借、图书归还、图书预约，收取罚款的处理；
- 系统管理员的基本业务功能：支持添加、删除、修改图书信息；支持添加、删除、修改借阅者信息。
- 身份认证系统：系统管理员和图书管理员需要进行身份认证才能操作；借阅者除查询图书信息无需登录认证以外，其它操作需要登录认证才能操作。

##### 用例图实例

![img](img_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/www.51wendang.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto)

在图书馆管理系统中，角色有借阅者、图书管理员和系统管理员。每个角色都有一个用例图 

- 描述用例首先要确定参与者，即角色(Actors)，Actors表示提供或接收系统信息的人或系统，他们是与系统有交互作用的人或事物，代表一个系统的使用者或外部通信的目标。
- 用例是系统中的一个功能单元，被描述为角色与系统之间的一次交互。用例需要**从角色希望系统提供的功能中提取，而不是以系统自身的角度来提取**，满足参与者的需求的用例才是好用例。
- 用例间的常见关系有**包含（Include）、扩展（Extend）、泛化（Generalization）**。包含也可以叫Use，表示本用例会用到被包含的其他用例，被包含的用例是可以被重用的；扩展用例是可选的，在特定场景下可以补充基础用例，降低基础用例的复杂性。泛化体现了父子关系，表明存在派生和继承。

扩展: 扩展用例 -----------> 基础用例 （虚线+箭头）

包含: 被包含的其他用例 -----------> 本用例 （虚线+箭头）

泛化: 子 ————▷ 父 （实线+三角）

##### 类图实例

类图是依据系统结构从静态观点描述系统的视图，它定义系统中的对象和类及类之间的关系，以及类的内部结构，即类的属性和操作。

- 实现（Realization）（ -----------▷）：是一种类与接口的关系，表示类是接口所有特征和行为的实现。例如：借阅者能查找书籍。
- 依赖（Dependency）（----------->）：是一种使用的关系，有单向依赖和双向依赖，但避免使用双向依赖。例如：借阅者查找结果依赖标题。
- 泛化（Generalization）（————▷）：是一种继承关系，指定了子类继承父类的所有特征和行为。例如：借阅者是老师或者学生。
- 关联（Association）（1————>1）：是一种拥有的关系，它使一个类知道另一个类的属性和方法。例如：借阅者的借阅记录或预约记录。
- 聚合（Aggregation）（1◇————>0...n）：是整体与个体的关系，可以理解成把个体聚集在一起。例如：借阅者的多条借阅记录。
- 组合（Composition）（1◆————>1）：是整体与局部的关系，整体的对象负责代表局部的对象的生命周期，可以理解成整体是由局部组成的。例如：借阅记录必须要有相关书籍信息。





接下来我们再来看一下图书馆管理系统的类图

类图是站在结构化视角来看这个系统的，主要描述这个系统的结构是怎么样的，系统中有哪些类，每个类各自负责哪些数据的管理，有哪些操作，以及这些类之间的关系是什么样的通过前面的需求分析和用例模型，我们以借阅者为例，来看一下要满足借阅者的相关需求，我们要怎么来设计这个结构，需要设计哪些对象，他们之间的关系是什么。

###### 实现，依赖和泛化

首先对于借阅者来说有查书，借书和还书的行为，那我们可以定义这样一个接口来表达，接口只负责声明，声明系统有哪些对外的功能，而实现则是由借阅者这个类来进行，所以，借阅者这个类与这个接口的关系就是一种**实现**的关系，采用一个虚线加三角空心箭头来将他们关联起来，其中箭头是指向接口的。

对于查书这个行为来说，那么至少要有一个书目这样的类Title，提供书的编码名称、作者信息等，借阅者才能进行查询，Title是一个独立的类，用于描述书的信息，那借阅者在查书的出过程中需要使用这个类，就存在**依赖**关系，我们采用虚线箭头表示，这个关系的画法跟用例图中的包含关系画法是一样的，其实从含以上来理解，包含也是一种依赖，有时也叫Use使用，这里说明的是借阅者需要使用和依赖Title这个类；

另外我们知道对于借阅者来说可以有学生和老师，他们虽然有一些差异化的功能，比如一次最大借阅数量可以不同，不过大部分的需求还是一样的，这个时候我们可以用父子继承的方式来表明他们和借阅者这个类的关系，在类图中我们一般叫**泛化**关系，用实线空心箭头来表达，箭头指向父类。

从这个例子，我们可以看有三种关系，**实现，依赖和泛化**，实现表明的是类与接口的关系，依赖是一种使用的关系，有单向和双向依赖，但我们应该尽量避免双向依赖，泛化是一种继承关系，比如这里的老师、学生与借阅者的关系。

###### 关联，聚合和组合

那我们继续围绕借阅者相关的功能来设计，根据需求分析我们知道对于借阅者我们提供了预约借书的功能，那我们把这个预约记录单独封装成一个类，里面包括借阅者的ID，预约时间，以及预约的书名等信息，那借阅者与预约记录这个类我们就用**关联**关系来表达，采用实现箭头，箭头指向被关联的类，这个关系也可以理解为是一种拥有的关系，说明借阅者拥有预约记录这个类的内容，那这个和前面讲的依赖关系有什么区别呢？

**依赖**也叫使用，也就是说是在我需要的时候才会用到你，而**关联**是只要我在你就在，他们的生命周期不一样，被依赖的对象是在某个方法过程中使用，使用之后就可以销毁了，而被关联的对象则是与自己的生命周期一样长，这里从类的设计中也可以看出来，关联对象我们是用作类的属性字段，而依赖通常是在某个方法里面用到的一个局部变量，所以从对两个类的紧密强度来看，关联的紧密强度是要大于依赖的；

我们再来看，对于一个借阅者来说每次借一本书就会产生一条借阅记录Loan，而一个借阅者可以借多本书，那就有多条借阅记录，我们把这些的借阅记录合起来就构成了这个借阅者的借阅信息，我们可以设计一个叫做BorrowedInfo这个类来表示，那借阅信息与借阅记录的关系就是**聚合**关系，用一个空心菱形加实线箭头来表达，其中菱形要画在整体这边，箭头指向个体。

**聚合**关系其实是一种特殊的关联关系，它比普通的关联关系更强，因为聚合关系是整体与部分之间的关系，而**关联**仅仅是两个平等的类之间的关系，没有从属关系。

那我们接着看一下，对于一条借阅记录，里面应该有哪些内容，比如，借阅者ID，借阅时间，借阅内容等，其中对于借阅内容（它由有多个相关的属性组成），我们把他封装成了一个类Item，那这个Item与借阅记录的关系就是**组合**关系，他是一个整体与部分的关系，是一个比聚合关系更强的关系，因为item对借阅记录来说是不可缺少的一部分，借阅记录一旦消失，那么他的Item也就没有任何意义了；画法与聚合比较相似，采用一个实心菱形加实线箭头来表达，同样菱形要画在整体，箭头指向部分。

好，我们有看到了类图中的另外三个关系：**关联，聚合和组合**。

好，我们来整体看一下类图中的6种关系，他们分别是 实现、依赖、泛化、关联、聚合和组合

借阅者实现了系统对外的借阅接口

借阅者查书的时候需要依赖图书条目Title

学生和老师是不同的借阅者，从借阅者继承而来

一个借阅者拥有预约信息和借阅信息

借阅信息有多条借阅记录汇聚而成

书籍信息Item是一条借阅记录的组成部分

另外我们看到每一种关系的画法都有箭头，那箭头指向谁，大家有的时候可能容易搞错，画反了，

那这里有一个小技巧，可以保证大家不用记错。就是 **箭头指向内容和范围较小的类**。

比如：实现关系中，类实现接口，那么类里面的内容和范围肯定大于接口，所以箭头指向接口

比如：依赖，使用者对于被依赖的类是一种拥有得出关系，那范围也肯定是大于被依赖的对象，所以箭头指向被依赖的类

比如泛化，子类是对父类的扩展，所谓青出于蓝而胜于蓝，子类的范围是可以大于父类的，所以箭头指向父类

对于关联，被关联类是关联类的一个属性字段，所以被关联类较小，箭头指向被关联的类

对于聚合和组合就不用说了，是整体与部分的关系，箭头当然是指向部分了。

##### 顺序图

（对象消息顺序图）

完成图书管理系统的静态模型建立以后，开始进行系统的动态建模。动态模型是描述系统的功能是如何完成的，用顺序图、活动图和状态图从不同的角度来描述对象和对象之间的交互。 

顺序图是强调**消息时间顺序**的交互图。描述了不同**对象**之间相互协助完成预期行为的动态过程。  

顺序图的主要绘图元素：

- 顺序图将交互关系表示为一个二维图
- 纵向是时间轴，时间沿竖线向下延伸
- 横向轴代表了在协作中各独立对象的类元角色
- 类元角色用生命线表示
- 消息用从一个对象的生命线到另一个对象生命线的箭头表示

其中消息的种类有同步调用以及调用的回应，异步消息和自调用，同步调用可理解为两个对象之间进行的一次函数调用，异步消息表示从一个对象到另一个对象的交互是通过消息发送的，而自调用表示对象调用了自己的另一个方法。

##### 活动图

（活动流程图）

活动图用于对目标对象计算流程和工作流程建模。

- 一张活动图本质是一个**流程图**，它显示系统从一个活动到另一个活动的流程迁移。
- 在完成用例建模后，通过活动图表示用例的活动步骤，用于描述用例模型，有助于用例的动态行为建模。
- 也可以用于通用的流程图建模场景。

四种基本模型元素：

- 活动Activity：表示一个执行步骤
- 活动流Activity line：不同活动间的控制流或数据流，从当前活动流向下一步活动 
- 控制符Control node：分支decision/merge，并发fork/join，控制符有两种，一种能够是分支控制符，一种是并发控制符，分支控制符用于流程中的分支判断，并发控制符用于描述活动的并发流程。
- 泳道Swimming line：用于表达不同的活动分组

##### 状态图

（类对象状态转换图）

状态图描述了系统元素的状态条件和响应，它反映了**类的对象可能具有的状态，以及引起状态变化的事件**。

并不是所有的类都有相应的状态图，状态图仅用于具有下列特点的类：具有若干个确定的状态，类的行为在这些状态下会受到影响变为其他状态，另外也可为系统描述整体状态图。

状态图可用于类、用例或者整个系统。

主要概念：

- 状态 （State）：状态描述了一个类对象生命期中的一个时间段。
- 事件 （Event）：事件是发生在时间和空间上的值得注意的事情。事件可以引发状态变迁。事件可以分为：信号事件、调用事件、改变事件、时间事件等
- 转换（Transition）：从状态出发的转换定义了处于此状态的对象对外界发生的事件所做出的反应。转换要有引起转换的触发器事件、监护条件、转换的动作和转换的目标状态。

##### 顺序图、活动图和状态图对比

| 类别   | 建模对象                                 | 核心建模元素          | 建模时机                   | 适用场景                                                     |
| ------ | ---------------------------------------- | --------------------- | -------------------------- | ------------------------------------------------------------ |
| 顺序图 | 多个不同对象间交互过程                   | Role-Message          | 在类图完成之后进行         | 描述复杂的多对象间交互。并发、分支过多的场景会影响可理解性   |
| 活动图 | (特定对象或不同对象的)不同活动之间的流动 | Activity-Control Flow | 在用例图或类图完成之后进行 | 描述涉及到复杂的活动步骤的用例。特别并发、分支等场景         |
| 状态图 | (特定对象的)不同状态变迁                 | State-Transition      | 在类图或用例图完成之后     | 涉及到复杂的状态变化的场景，也适用于并发场景，如网络连接的会话状态等。 |

- 顺序图强调多个不同对象之间交互的先后顺序；
- 活动图强调复杂流程处理中活动单元的分支处理；
- 状态图强调特定对象在不同事件发生后的状态变化；



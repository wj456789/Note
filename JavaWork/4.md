# 科一

[labuladong的算法秘籍V1.7(力扣版).pdf](https://labuladong.gitee.io/algo/)

## 算法理论

### 动态规划

动态规划问题的⼀般形式就是求最值。 求解动态规划的核⼼问题是穷举。 这类问题存在「重叠⼦问题」 ，动态规划问题⼀定会具备「最优⼦结构」 ，列出正确的「状态转移⽅程」，才能正确地穷举。 

明确 base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。 

#### 斐波那契数列

##### 暴⼒递归 

```java
int fib(int N) {
    if (N == 1 || N == 2) return 1;
    return fib(N - 1) + fib(N - 2);
}
```

递归算法的时间复杂度怎么计算？就是⽤⼦问题个数乘以解决⼀个⼦问题需要的时间。 ⾸先计算⼦问题个数，即递归树中节点的总数。显然⼆叉树节点总数为指数级别，所以⼦问题个数为 O(2^n)。 然后计算解决⼀个⼦问题的时间，在本算法中，没有循环，只有 f(n - 1) + f(n - 2) ⼀个加法操作， 时间为 O(1)。 所以，这个算法的时间复杂度为⼆者相乘，即 O(2^n)

##### 带备忘录的递归解法 

```java
// 带备忘录的递归解法解决重叠⼦问题
int fib(int N) {
    // 备忘录全初始化为 0
    int[] memo = new int[N + 1];
    // 进⾏带备忘录的递归
    return helper(memo, N);
}
int helper(int[] memo, int n) {
    // base case
    if (n == 0 || n == 1) return n;
    // 已经计算过，不⽤再计算了
    if (memo[n] != 0) return memo[n];
    memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
    return memo[n];
}
```

⼦问题个数，即图中节点的总数，由于本算法不存在冗余计算，⼦问题就是 f(1), f(2), f(3) ... f(20)， 数量和输⼊规模 n = 20 成正⽐，所以⼦问题个数为 O(n)。 解决⼀个⼦问题的时间，同上，没有什么循环，时间为 O(1)。 所以，本算法的时间复杂度是 O(n) 。

##### dp 数组的迭代（递推）解法 

```java
int fib(int N) {
    if (N == 0) return 0;
    int[] dp = new int[N + 1];
    // base case
    dp[0] = 0; dp[1] = 1;
    // 状态转移
    for (int i = 2; i <= N; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[N];
}
```

f(n) = 1,n=1,2

f(n) = f(n-1) + f(n-2),n>2

状态转移⽅程，f(n) 的函数参数会不断变化，把参数 n 想做⼀个状态，这个状态 n 是由状态 n - 1 和状态 n - 2 转移（相加）⽽来，这就叫状态转移 

#### 凑零钱问题

给你 k 种⾯值的硬币，⾯值分别为 c1, c2 ... ck，每种硬币的数量⽆限，再给⼀个总⾦额 amount，问 你最少需要⼏枚硬币凑出这个⾦额，如果不可能凑出，算法返回 -1 。 

要符合「最优⼦结构」，⼦问题间必须互 相独⽴。 

1. 确定 base case，这个很简单，显然⽬标⾦额 amount 为 0 时算法返回 0，因为不需要任何硬币就已经凑 出⽬标⾦额了。 
2. 确定「状态」，也就是原问题和⼦问题中会变化的变量。由于硬币数量⽆限，硬币的⾯额也是题⽬给定 的，只有⽬标⾦额会不断地向 base case 靠近，所以唯⼀的「状态」就是⽬标⾦额 amount。 
3. 确定「选择」，也就是导致「状态」产⽣变化的⾏为。⽬标⾦额为什么变化呢，因为你在选择硬币，你每 选择⼀枚硬币，就相当于减少了⽬标⾦额。所以说所有硬币的⾯值，就是你的「选择」。
4. 明确 dp 函数/数组的定义。我们这⾥讲的是⾃顶向下的解法，所以会有⼀个递归的 dp 函数，⼀般来说函 数的参数就是状态转移中会变化的量，也就是上⾯说到的「状态」；函数的返回值就是题⽬要求我们计算的 量。就本题来说，状态只有⼀个，即「⽬标⾦额」，题⽬要求我们计算凑出⽬标⾦额所需的最少硬币数量。 

##### 暴力递归

```java
int coinChange(int[] coins, int amount) {
    // 题⽬要求的最终结果是 dp(amount)
    return dp(coins, amount)
}
int dp(int[] coins, int amount) {
    // base case
    if (amount == 0) return 0;
    if (amount < 0) return -1;
    int res = Integer.MAX_VALUE;
    for (int coin : coins) {
        // 计算⼦问题的结果
        int subProblem = dp(coins, amount - coin);
        // ⼦问题⽆解则跳过
        if (subProblem == -1) continue;
        // 在⼦问题中选择最优解，然后加⼀
        res = Math.min(res, subProblem + 1);
    }
    return res == Integer.MAX_VALUE ? -1 : res;
}
```

##### 带备忘录的递归 

```java
int[] memo;
int coinChange(int[] coins, int amount) {
    memo = new int[amount + 1];
    // dp 数组全都初始化为特殊值
    Arrays.fill(memo, -666);
    return dp(coins, amount);
}
int dp(int[] coins, int amount) {
    if (amount == 0) return 0;
    if (amount < 0) return -1;
    // 查备忘录，防⽌重复计算
    if (memo[amount] != -666)
        return memo[amount];
    int res = Integer.MAX_VALUE;
    for (int coin : coins) {
        // 计算⼦问题的结果
        int subProblem = dp(coins, amount - coin);
        // ⼦问题⽆解则跳过
        if (subProblem == -1) continue;
        // 在⼦问题中选择最优解，然后加⼀
        res = Math.min(res, subProblem + 1);
    }
    // 把计算结果存⼊备忘录
    memo[amount] = (res == Integer.MAX_VALUE) ? -1 : res;
    return memo[amount];
}
```

##### dp 数组的迭代解法 

dp 数组的定义：当⽬标⾦额为 i 时，⾄少需要 dp[i] 枚硬币凑出。 

```java
int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    // 数组⼤⼩为 amount + 1，初始值也为 amount + 1
    Arrays.fill(dp, amount + 1);
    // base case
    dp[0] = 0;
    // 外层 for 循环在遍历所有状态的所有取值
    for (int i = 0; i < dp.length; i++) {
        // 内层 for 循环在求所有选择的最⼩值
        for (int coin : coins) {
            // ⼦问题⽆解，跳过
            if (i - coin < 0) {
                continue;
            }
            dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}
```

#### 下载路径最小和

输⼊为⼀个 n * n 的⼆维数组 matrix，请你计算从第⼀⾏落到最 后⼀⾏，经过的路径和最⼩为多少。 

```java
int minFallingPathSum(int[][] matrix);
就是说你可以站在 matrix 的第⼀⾏的任意⼀个元素，需要下降到最后⼀⾏。
每次下降，可以向下、向左下、向右下三个⽅向移动⼀格。也就是说，可以从 matrix[i][j] 降到
matrix[i+1][j] 或 matrix[i+1][j-1] 或 matrix[i+1][j+1] 三个位置。
```

##### 暴力递归

```java
int minFallingPathSum(int[][] matrix) {
    int n = matrix.length;
    int res = Integer.MAX_VALUE;
    // 终点可能在最后⼀⾏的任意⼀列
    for (int j = 0; j < n; j++) {
        res = Math.min(res, dp(matrix, n - 1, j));
    }
    return res;
}

int dp(int[][] matrix, int i, int j) {
    // ⾮法索引检查
    if (i < 0 || j < 0 ||
        i >= matrix.length ||
        j >= matrix[0].length) {
        // 返回⼀个特殊值
        return 99999;
    }
    // base case
    if (i == 0) {
        return matrix[i][j];
    }
    // 状态转移
    return matrix[i][j] + min(
        dp(matrix, i - 1, j), 
        dp(matrix, i - 1, j - 1),
        dp(matrix, i - 1, j + 1)
    );
}
int min(int a, int b, int c) {
    return Math.min(a, Math.min(b, c));
}
```

##### 带备忘录的递归

```java
int minFallingPathSum(int[][] matrix) {
    int n = matrix.length;
    int res = Integer.MAX_VALUE;
    // 备忘录⾥的值初始化为 66666
    memo = new int[n][n];
    for (int i = 0; i < n; i++) {
        Arrays.fill(memo[i], 66666);
    }
    // 终点可能在 matrix[n-1] 的任意⼀列
    for (int j = 0; j < n; j++) {
        res = Math.min(res, dp(matrix, n - 1, j));
    }
    return res;
}
// 备忘录
int[][] memo;
int dp(int[][] matrix, int i, int j) {
    // 1、索引合法性检查
    if (i < 0 || j < 0 ||
        i >= matrix.length ||
        j >= matrix[0].length) {

        return 99999;
    }
    // 2、base case
    if (i == 0) {
        return matrix[0][j];
    }
    // 3、查找备忘录，防⽌重复计算
    if (memo[i][j] != 66666) {
        return memo[i][j];
    }
    // 进⾏状态转移
    memo[i][j] = matrix[i][j] + min(
        dp(matrix, i - 1, j), 
        dp(matrix, i - 1, j - 1),
        dp(matrix, i - 1, j + 1)
    );
    return memo[i][j];
}
int min(int a, int b, int c) {
    return Math.min(a, Math.min(b, c));
}
```









### 二维数组

```java
public static void main(String[] args) {
    // 使用JDK将字符串转化为二维数组int
    String str = "[[2,3],[45,5,8],[10,8,33,3],[5]]";
    str = str.substring(2, str.length() - 2);
    String[] first = str.split("],\\[");
    int[][] array = new int[first.length][];

    for (int i = 0; i < first.length; i++) {
        int[] second = Arrays.stream(first[i].split(",")).sorted(Comparator.comparing(o -> Integer.parseInt(String.valueOf(o))).reversed()).mapToInt(Integer::parseInt).toArray();
        //String[] second = first[i].split(",");
        array[i] = new int[second.length];
        for (int j = 0; j < second.length; j++) {
            array[i][j] = second[j];
        }
    }


    // 使用fastjson将字符串转化为二维数组int
    Integer[][] ints = JSON.parseObject("[[2,3],[45,5,8],[10,8,33,3],[5]]", Integer[][].class);
    int[][] ints1 = new int[ints.length][];
    for (int i = 0; i < ints1.length; i++) {
        ints1[i] = Arrays.stream(ints[i]).mapToInt(Integer::intValue).toArray();
    }
    System.out.println(JSON.toJSONString(ints));
}
```

```java
// 使用JDK将字符串转化为二维数组int
public static void main(String[] args) {
    String a = "[[2,3],[45,5,8],[10,8,33,3],[5]]";
    String b = a.substring(2, a.length()-2);
    String[]  arr1 = b.split("],\\[");
    int[][] res = new int[arr1.length][];
    AtomicInteger index = new AtomicInteger(0);
    Arrays.stream(arr1).map(e->abc(e.split(","))).forEach(e->{
        res[index.getAndIncrement()] = e;
    });
    System.out.println(res);
}

private static int[] abc(String[] arr) {
    return Arrays.stream(arr).mapToInt(Integer::parseInt).toArray();
}
```

## 算法题

### 手机九宫格输入法 

手机上的九宫格输入法使用 0-9 十个数字键，除了可以在“数字状态”下输入数字外，还可以在“英文状态”下通过连续多次摁某一数字键来输入对应的英文字符。每个数字键可输入的字符对应关系如图： 

![img](4.assets/c3f4a6bd6a.png) 



说明： 

- 输入法初始默认为“数字状态”，并可在“数字状态”与“英文状态”间切换。
- 输入法在“数字状态”下，数字键对应为单个数字，摁几次显示几个该数字。
- 输入法在“英文状态”下，如果数字键为 0，则对应为单字符（空格），摁几次显示几个该字符。
- 输入法在“英文状态”下，如果数字键为非 0，则对应为多个字符，可通过连续多次快速摁该键循环选择对应字符： 
  - 以英文状态下的数字键 2 为例，摁1次为 `a` ，2次为 `b` ，3次为 `c` ，4次又循环回 `a` 。
  - 若连续多次摁键循环选择时被其它键或停顿中断，则输出所选择的字符。

现给定一个仅含字符集合为 [0-9#/] 的字符串，表示用户的摁键操作，请输出实际显示出来的字符串。 

- 0-9 为数字键。
- \#   表示在“数字状态”与“英文状态”之间切换。
- /   停顿符，表示用户有意停顿。

输入

一个字符串，表示用户的摁键操作，长度范围 [1,200]

输出

实际显示出来的字符串

样例

输入样例 1 复制

```
123
```

输出样例 1

```
123
```

提示样例 1

输入法默认为“数字状态”，每个数字键都对应单个字符，摁键即为实际显示出来的字符串，因此输出 `123` 。

 

输入样例 2 复制

```
#22/23044444411
```

输出样例 2

```
bad i.
```

提示样例 2

\# 表示输入法切换为“英文状态”；
数字键 2 摁2次后被停顿符 / 中断，显示 `b` ；
其后，数字键 2、3、0 各摁1次后被其它键中断，显示 `a`、`d`、空格 ；
然后，数字键 4 摁6次后中断，显示 `i` ；
最后，数字键 1 摁2次后结束，显示 `.` 。

因此，实际显示出来的字符串为 `bad i.`

#### 答案

```java
// 用一个Map存储按键对应的字符，通过一个index%size的方式在当前案件轮回滚动
private static String getDisplayString(String inputStr) {
    Map<Character, char[]> charMap = initCharMap();
    inputStr = inputStr.replace("##", "");
    String[] inputs = inputStr.split("#");
    if (inputs.length < 1) {
        return "";
    }
    StringBuilder result = new StringBuilder();
    for (int i = 0; i < inputs.length; i++) {
        if (i % 2 == 0) {
            result.append(inputs[i].replace("/", ""));
        } else {
            result.append(getLetters(inputs[i], charMap));
        }
    }
    return result.toString();
}
private static Map<Character, char[]> initCharMap() {
    Map<Character, char[]> chars = new HashMap<>();
    chars.put('1', new char[] {',', '.'});
    chars.put('2', new char[] {'a', 'b', 'c'});
    chars.put('3', new char[] {'d', 'e', 'f'});
    chars.put('4', new char[] {'g', 'h', 'i'});
    chars.put('5', new char[] {'j', 'k', 'l'});
    chars.put('6', new char[] {'m', 'n', 'o'});
    chars.put('7', new char[] {'p', 'q', 'r', 's'});
    chars.put('8', new char[] {'t', 'u', 'v'});
    chars.put('9', new char[] {'w', 'x', 'y', 'z'});
    return chars;
}
private static String getLetters(String input, Map<Character, char[]> charMap) {
    StringBuilder result = new StringBuilder();
    int index = 0;
    char current = ' ';
    for (int i = 0; i < input.length(); i++) {
        if (current == input.charAt(i)) {
            index = (index + 1) % charMap.get(current).length;
        } else {
            if (charMap.containsKey(current)) {
                result.append(charMap.get(current)[index]);
            }
            if (input.charAt(i) == '0') {
                result.append(" ");
                current = ' ';
            } else {
                current = input.charAt(i) == '/' ? ' ' : input.charAt(i);
            }
            index = 0;
        }
    }
    if (current != ' ') {
        result.append(charMap.get(current)[index]);
    }
    return result.toString();
}
```

#### 个人解答

```java
private static final String[][] strings = new String[10][4];

static {
    strings[0][0] = " ";
    strings[1][0] = ",";
    strings[1][1] = ".";
    strings[2][0] = "a";
    strings[2][1] = "b";
    strings[2][2] = "c";
    strings[3][0] = "d";
    strings[3][1] = "e";
    strings[3][2] = "f";
    strings[4][0] = "g";
    strings[4][1] = "h";
    strings[4][2] = "i";
    strings[5][0] = "j";
    strings[5][1] = "k";
    strings[5][2] = "l";
    strings[6][0] = "m";
    strings[6][1] = "n";
    strings[6][2] = "o";
    strings[7][0] = "p";
    strings[7][1] = "q";
    strings[7][2] = "r";
    strings[7][3] = "s";
    strings[8][0] = "t";
    strings[8][1] = "u";
    strings[8][2] = "v";
    strings[9][0] = "w";
    strings[9][1] = "x";
    strings[9][2] = "y";
    strings[9][3] = "z";
}

public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in, StandardCharsets.UTF_8.name());
    String inputStr = scanner.nextLine();
    scanner.close();
    String result = getDisplayString(inputStr);
    System.out.println(result);
}

private static String getDisplayString(String inputStr) {
    StringBuffer result = new StringBuffer();
    int repeat = 0;
    Character previous = null;
    boolean isNumber = true;
    inputStr += "$";
    char[] chars = inputStr.toCharArray();
    for (Character c : chars) {
        if (c == '#' || c == '/' || c == '$') {
            if (!isNumber && previous != null) {
                result = getValue(previous, repeat, result);
                previous = null;
                repeat = 0;
            }
            if (c == '#') {
                isNumber = !isNumber;
            }
            continue;
        }
        if (isNumber) {
            result.append(c);
        } else if (previous == null) {
            previous = c;
            repeat = 1;
        } else if (previous == c) {
            repeat++;
        } else {
            result = getValue(previous, repeat, result);
            previous = c;
            repeat = 1;
        }
    }

    return result.toString();
}

private static StringBuffer getValue(Character key, int repeat, StringBuffer result) {
    if (key == '0') {
        for (int i = 1; i <= repeat; i++) {
            result.append(" ");
        }
    } else if (key == '1') {
        result.append(strings[Integer.parseInt(key + "")][(repeat + 1) % 2]);
    } else if (key == '7' || key == '9') {
        result.append(strings[Integer.parseInt(key + "")][(repeat + 3) % 4]);
    } else {
        result.append(strings[Integer.parseInt(key + "")][(repeat + 2) % 3]);
    }
    return result;
}
```



### 屏蔽敏感词 

为了净化网络环境，需要开发一个简易的敏感词屏蔽功能：给定敏感词，按如下规则，对待检查字符串进行匹配和替换： 

- 敏感词中的各字符顺序地出现在待检查字符串中，且第一个字符和最后一个字符之间的其它字符个数小于敏感词长度，连同其它字符一起替换为星号 `*`如：敏感词 135 可匹配字符串1?3?5、1??35，不匹配1?3??5。
- 支持贪婪匹配，即每次从左到右扫描，一旦遇到可匹配的情况就开始进行匹配，且匹配尽可能长的字符，例如：
  - 敏感词为 ab 时，字符串 abbc 应该替换成 *c ，而不是 *bc
  - 敏感词为 abc 时，字符串 aabcbc 应该替换成 *bc，而不是 a* （遇到首个 a 时就开始进行匹配）
- 支持全量匹配，即：有多处符合匹配规则时，则需要全部进行匹配和替换。

请输出屏蔽后的字符串。 

输入样例 1 复制

```
ABCdfgABC
ABC
```

输出样例 1

```
*dfg*
```

提示样例 1

注意全量匹配，待检查字符串中有两处符合匹配规则，首个ABC以及最后一个ABC，都替换为`*`后，屏蔽后输出为 `*dfg*`。

输入样例 2 复制

```
abbdefghjjk
bdfhj
```

输出样例 2

```
a*k
```

提示样例 2

注意贪婪匹配：从第二个字符b开始匹配到第十个字符j，中间干扰字符个数为4（含 begj），小于敏感词的长度5，因此屏蔽后输出为：a*k

输入样例 3 复制

```
abbbbbcde
abc
```

输出样例 3

```
abbbbbcde
```

提示样例 3

a 和 c之间的字符串 bbbbb 长度超过了敏感词的长度，因此无屏蔽。



#### 答案

```java
public class Main {
    /**
     * main入口由OJ平台调用
     */
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in, StandardCharsets.UTF_8.name());
        String checkedStr = cin.nextLine();
        String sensitiveStr = cin.nextLine();
        cin.close();
        String result = getMaskedStr(checkedStr, sensitiveStr);
        System.out.println(result);
    }
    // 待实现函数，在此函数中填入答题代码
    private static String getMaskedStr(String checkedStr, String sensitiveStr) {
        int sLen = sensitiveStr.length();
        int cLen = checkedStr.length();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < cLen; i++) {
            if (checkedStr.charAt(i) != sensitiveStr.charAt(0)) {
                sb.append(checkedStr.charAt(i));
                continue;
            }
            int j = (i + sLen * 2 - 1) > cLen ? cLen : (i + sLen * 2 - 1);
            while (j >= i + sLen && checkedStr.charAt(j - 1) != sensitiveStr.charAt(sLen - 1)) {
                j--;
            }
            if ((j - i) >= sLen && isSenStr(checkedStr.substring(i, j), sensitiveStr)) {
                sb.append("*");
                i = j - 1;
            } else {
                sb.append(checkedStr.charAt(i));
            }
        }
        return sb.toString();
    }
    private static boolean isSenStr(String checkedStr, String sensitiveStr) {
        int j = 0;
        for (int i = 0; i < sensitiveStr.length(); i++) {
            while (j < checkedStr.length() && checkedStr.charAt(j++) != sensitiveStr.charAt(i)){}
            if (checkedStr.length() - j + 1 < sensitiveStr.length() - i) {
                return false;
            }
        }
        return true;
    }
}
```

### 销售点分布调查 

题目描述

终端部门按层级管理销售负责人，即：销售总裁直接对接公司分布在若干个国家的销售负责人，每个国家的销售负责人对接本国各大区负责人，大区负责人对接本区内各省负责人，各省负责人对接本省各市负责人等等…… 这里假设每个级别的负责人都仅向唯一的上级领导汇报。

假设共有N（N<100）位销售负责人，每人有一个两位数的代号（从 01 到 N），销售总裁的代号为01。如下样例给出了一个23人销售负责人的层级结构图：
![img](4.assets/dddd65dce8.png)

给定销售负责人的层级关系数据，请统计指定负责人**名下**人数最多的层级是哪一层，该层有多少人？

- 当有多个层级的人数相同时，选择最高的那个层级。
- 所统计的层级是相对的，指定负责人的层级为 1，其下的层级逐层递增。

解答要求时间限制：1000ms, 内存限制：256MB

输入

第一行一个整数 N 表示销售负责人总数，取值范围：[1,100)。
第二行一个整数 M （0 <= M < N）表示有下属的负责人的人数。
随后 M 行，每行给出一位负责人，格式为`ID K ID[1] ID[2] ... ID[K]`，其中 ID 是该负责人的代号，K (K > 0) 是其下属人数，后面给出的其下属们的代号。
最后一行给出待统计的指定负责人的代号`ID`

输出

两个数字，依次表示指定负责人名下人数最多的层级，及该层级的人数。

样例

输入样例 1 复制

```
23
13
21 1 23
01 4 03 02 04 05
03 3 06 07 08
06 2 12 13
13 1 21
08 2 15 16
02 2 09 10
11 2 19 20
17 1 22
05 1 11
07 1 14
09 1 17
10 1 18
01
```

输出样例 1

```
[4 9]
```

提示样例 1

01号负责人，其名下人数最多的层级是第4层（01号自身算第1层，其名下的层级逐层递增），该层有9人；因此输出[4 9]

> 补充说明：
>
> - 如果统计09号负责人：其名下所有层级的人数都是1人，取最高层级即自身层级 1，输出[1 1]。
> - 如果统计06号负责人：其名下第2层人数最多，有2人，输出[2 2]。
> - 如果统计20号负责人：其名下没有层级，取自身层级 1，人数 1，输出[1 1]。

#### 个人解答

```java
public static void main(String[] args) {
    Scanner cin = new Scanner(System.in, StandardCharsets.UTF_8.name());
    int totalSales = cin.nextInt();
    int supNum = cin.nextInt();

    Map<Integer, List<Integer>> relationList = new HashMap<>();
    for (int i = 0; i < supNum; i++) {
        int sup = cin.nextInt(); // 主管
        int subCnt = cin.nextInt();
        List<Integer> subIds = new ArrayList<>(subCnt);
        for (int j = 0; j < subCnt; j++) {
            subIds.add(cin.nextInt()); // 下属
        }
        relationList.put(sup, subIds);
    }

    int appointSale = cin.nextInt();
    cin.close();

    int[] results = pointSaleSurvey(totalSales, relationList, appointSale);
    String[] strResult = Arrays.stream(results).mapToObj(String::valueOf).toArray(String[]::new);
    System.out.print("[" + String.join(" ", strResult) + "]");
}

// 待实现函数，在此函数中填入答题代码
private static int[] pointSaleSurvey(int totalSales, Map<Integer, List<Integer>> relationList, int appointSale) {
    Map<Integer, Integer> map = new HashMap<>();
    map.put(1, 1);

    getI(map, relationList, 2, appointSale);
    int level = 0;
    int maxpeople = 0;
    for (Integer in : map.keySet()) {
        if (maxpeople < map.get(in)) {
            maxpeople = map.get(in);
            level = in;
        }
    }

    return new int[] {level, maxpeople};
}

private static void getI(
    Map<Integer, Integer> map,
    Map<Integer, List<Integer>> relationList,
    Integer currentLevel,
    int parentAppoint) {
    if (relationList.containsKey(parentAppoint)) {
        Integer orDefault = map.getOrDefault(currentLevel, 0);
        map.put(currentLevel, orDefault + relationList.get(parentAppoint).size());
        for (Integer in : relationList.get(parentAppoint)) {
            if (relationList.containsKey(in)) {
                getI(map, relationList, currentLevel + 1, in);
            }
        }
    }
}
```
















## try-with-resource

- 传统的`try-finally`方式存在复杂易出错和异常抑制(Suppressed)等问题。 使用`try-with-resource`，可以更安全、简洁地申请和关闭资源，同时解决了异常抑制问题。 
- `try-with-resource`是语法糖，其最终仍然会被编译成`try-finally`方式并调用close方法关闭资源。 
- 为了支持`try-with-resource`，资源类必须要实现`AutoClosable接口`，否则无法使用。在使用`try-with-resource`之前，请务必确认下资源类是否已经实现了`AutoClosable接口`。
- `try-with-resource`使用方式
  - `try-with-resource`使用很简单，申请资源的代码写在try后面的()中即可，无需显式调用`close方法`来关闭资源。 
  - 为了使程序更加健壮，在`try-with-resouce`中使用装饰器时，建议显式声明被装饰/包裹对象的引用。 

### 使用

能够借助`try-with-resource`关闭资源的类必须实现`AutoClosable接口`，重写`close方法`。如果是自定义资源类， 为了支持`try-with-resource`，请务必实现`AutoClosable接口`。 

```java
//申请资源的代码写在try后面的()中即可，资源关闭无需显式close
public void twrClose2NotCatch(String src, String dst) throws IOException {
    try (FileInputStream ins = new FileInputStream(src);
         OutputStream outs = new FileOutputStream(dst)) {
        byte[] buf = new byte[BUF_SIZE];
        int n;
        while ((n = ins.read(buf)) >= 0) {
            outs.write(buf, 0, n);
        }
    }
}
```

`try-with-resource`主要做了两件事：

- 添加调用close方法的代码，关闭资源。
- 使用addSuppressed方法附加异常，消除异常抑制的问题。

#### try-finally举例

##### 异常抑制

异常抑制（Suppressed）也有叫异常覆盖和异常屏蔽

```java
public class ConnectionNormal {
    public void send() throws Exception {
        throw new SendException("send fail.");
    }

    public void close() throws Exception {
        throw new CloseException("close fail");
    }
}

//按照程序逻辑，应该先抛出SendException，再抛出CloseException：
public static void main(String[] args) {
    try {
        test();
    } catch (Exception e) {
        e.printStackTrace();
    }
}


private static void test() throws Exception {
    ConnectionNormal conn = null;
    try {
        conn = new ConnectionNormal();
        conn.send();
    } finally {
        if (conn != null) {
            conn.close();
        }
    }
}

//运行后我们发现：
com.CloseException: close fail
at com.ConnectionNormal.close(ConnectionNormal.java:10)
    at com.TryWithResource.test(TryWithResource.java:20)
    at com.TryWithResource.main(TryWithResource.java:6)
```

SendException明明先被抛出了，但是没有丝毫痕迹，被后抛的CloseException给抑制了，这就是异常抑制，SendException被称为Suppressed Exception。关键的异常信息丢失，这会导致某些bug变得极其隐蔽而难以发现！

#### try-with-resource举例

`try-with-resource`为`Throwable类`新增了`addSuppressed方法`，支持将一个异常附加到另一个之上，从而解决异常抑制。

```java
public class ConnectionAutoClose implements AutoCloseable{
    public void send() throws Exception {
        throw new SendException("send fail.");
    }
    @Override
    public void close() throws Exception {
        throw new CloseException("close fail");
    }
}

private static void test2() {
    try (ConnectionAutoClose conn = new ConnectionAutoClose()) {
        conn.send();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

运行结果：
com.SendException: send fail.
    at com.ConnectionAutoClose.send(ConnectionAutoClose.java:5)
    at com.TryWithResource.test2(TryWithResource.java:27)
    at com.TryWithResource.main(TryWithResource.java:6)
    Suppressed: com.CloseException: close fail
at com.ConnectionAutoClose.close(ConnectionAutoClose.java:10)
        at com.TryWithResource.test2(TryWithResource.java:28)
        ... 1 more
```

### 原理

```java
//try-with-resource反编译.class
private static void test2() {
    try {
        ConnectionAutoClose conn = new ConnectionAutoClose();
        Throwable var1 = null;
        try {
            conn.send();
        } catch (Throwable var11) {
            var1 = var11;
            throw var11;
        } finally {
            if (conn != null) {
                if (var1 != null) {
                    try {
                        conn.close();
                    } catch (Throwable var10) {
                        var1.addSuppressed(var10);
                    }
                } else {
                    conn.close();
                }
            }
        }
    } catch (Exception var13) {
        var13.printStackTrace();
    }
}
```

### 显式声明

为了使程序更加健壮，在try-with-resouce中使用装饰器时，建议显式声明被装饰 / 包裹对象的引用。

```java
//在finally中仅调用了out.close()，在GZIPOutputStream.close内部，会关闭被包裹的FileOutputStream，但是这个关闭可能会失败
public void gzipWrapper(File file) throws IOException {
   try (GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(file))) {
      ...
  }
}
```

```java
//fout.close一定会被调用
public void gzipWrapperRobust(File file) throws IOException {
   try (FileOutputStream fout = new FileOutputStream(file); // 显式声明
        GZIPOutputStream out = new GZIPOutputStream(fout)) {
      ...
  }
}
```



## 正则表达式

```java
//IPv4的地址格式，总长度 32位=4段*8位，每段之间用.分割， 每段都是0-255之间的十进制数值
System.out.println("10.45.168.74".matches("^((25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d)))\\.){3}(25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d)))$"));
//端口号0-65535
System.out.println("8080".matches("^([0-9]|[1-9]\\d|[1-9]\\d{2}|[1-9]\\d{3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5])$"));
```



## Java基础

### 类型强转

```java
Object obj;
List<Integer> list = castList(obj,Integer.class);
//list强转
private static <T> List<T> castList(Object obj, Class<T> clazz) {
    List<T> result = new ArrayList<T>();
    if (obj instanceof List<?>) {
        for (Object o : (List<?>) obj) {
            result.add(clazz.cast(o));
        }
        return result;
    }
    return null;
}
```

```java
Object obj;
Map<String,Object> map = castHashMap(obj,String.class,Object.class);

/**
 * 防止出现强转警告
 *
 * @param obj 强转对象
 * @param clazz1 HashMap的key
 * @param clazz2 HashMap的value
 * @param <K> Key泛型
 * @param <V> Value泛型
 * @return 强转后对象
 */
private <K, V> HashMap<K, V> castHashMap(Object obj, Class<K> clazz1, Class<V> clazz2) {
    HashMap<K, V> result = new HashMap<K, V>();
    if (obj instanceof HashMap<?, ?>) {
        for (Object o : ((HashMap<?, ?>) obj).keySet()) {
            result.put(clazz1.cast(o), clazz2.cast(((HashMap<?, ?>) obj).get(o)));
        }
        return result;
    }
    return null;
}
```



## 解压tar包

```java
private static final int BUFFER = 512;
private static final int TOOBIG = 0x6400000; // max size of unzipped data, 100MB
private static final int TOOMANY = 1024; // max number of files

public static void main(String[] args) {
    String sourcePath = "";
    String destDir = "";
    TarEntry entry;
    //接收byte[]数据  TarInputStream tis = new TarInputStream(new ByteArrayInputStream(sourceData))
    try (FileInputStream fis = new FileInputStream(sourcePath);
         TarInputStream tis = new TarInputStream(fis)) {
        while ((entry = tis.getNextEntry()) != null) {
            int total = 0;
            int entries = 0;
            byte[] data = new byte[BUFFER];
            String destPath = FileUtil.sanitzeFileName(entry.getName(), destDir);
            int count;
            try (FileOutputStream fos = new FileOutputStream(destPath)) {
                while ((count = tis.read(data, 0, BUFFER)) != -1) {
                    total += count;
                    if (total > TOOBIG) {
                        log.error("fileSize in package is too big");
                    }
                    fos.write(data, 0, count);
                }
                if (++entries > TOOMANY) {
                    log.error("fileNum in package is too many");
                }
            }
        }
    } catch (IOException e) {
        log.error("decompressTar error", e);
    }
}

/**
 * 文件路径检查
 *
 * @param entryName 文件名称
 * @param intendedDir 文件路径
 * @return 文件全路径
 * @throws IOException
 */
public static String sanitzeFileName(String entryName, String intendedDir) throws IOException {
    String canonicalPath = new File(intendedDir, entryName).getCanonicalPath();
    String canonicalID = new File(intendedDir).getCanonicalPath();
    if (canonicalPath.startsWith(canonicalID)) {
        return canonicalPath;
    } else {
        throw new IllegalStateException("File is outside extraction target directory.");
    }
}
```

## 数据运算越界检查

> oldAcc + (newVal * scale)

### 先决条件检查 

```java
public int safeAdd(int left, int right) {
    if (right > 0 ? left > Integer.MAX_VALUE - right
        : left < Integer.MIN_VALUE - right) {
        throw new ArithmeticException("Integer overflow");
    }
    return left + right;
}

//Java数据类型的合法取值范围是不对称的（最小值的绝对值比最大值大1），所以对最小值取负时，会导致溢出。
public int safeMultiply(int left, int right) {
    if (right > 0 ? left > Integer.MAX_VALUE / right
        || left < Integer.MIN_VALUE / right
        : (right < -1 ? left > Integer.MIN_VALUE / right 
           || left < Integer.MAX_VALUE / right
           : right == -1 && left == Integer.MIN_VALUE)) {
        throw new ArithmeticException("Integer overflow");
    }
    return left * right;
}
```

### 向上类型转换 

该方式对long类型不适用。 

```java
public static long intRangeCheck(long value) {
    // 向上类型转换
    if ((value < Integer.MIN_VALUE) || (value > Integer.MAX_VALUE)) {
        throw new ArithmeticException("Integer overflow");
    }
    return value;
}

public static int multAccum(int oldAcc, int newVal, int scale) {
    final long res = intRangeCheck(((long) oldAcc) +
                                   intRangeCheck((long) newVal * (long) scale));
    return (int) res; // Safe downcast
}
```

### BigInteger 

```java
private static final BigInteger bigMaxInt = BigInteger.valueOf(Integer.MAX_VALUE);
private static final BigInteger bigMinInt = BigInteger.valueOf(Integer.MIN_VALUE);
// BigInteger检查是否存在溢出
public static BigInteger intRangeCheck(BigInteger val) {
    if (val.compareTo(bigMaxInt) == 1 || val.compareTo(bigMinInt) == -1) {
        throw new ArithmeticException("Integer overflow");
    }
    return val;
}

public static int multAccum(int oldAcc, int newVal, int scale) {
    BigInteger product = BigInteger.valueOf(newVal).multiply(BigInteger.valueOf(scale));
    BigInteger res = intRangeCheck(BigInteger.valueOf(oldAcc).add(product));
    return res.intValue(); // Safe conversion
}
```

## Normalizer.normalize()

normalize方法对外部输入字符串做归一化/标准化处理，如：

```java
//将全角形式的字符转化为半角形式的字符，"＜root＞"-->"<root>"
Normalizer.normalize(str,Normalizer.Form.NFKC);
```

[关于Normalizer.normalize()方法的用途](https://blog.csdn.net/u010512607/article/details/79921353)

## @PostConstruct和@PreDestory执行顺序

构造函数==》postConstruct==>init==destory==>predestory==卸载servlet;;  



## Git

### 首次提交代码到远程仓库

1. 首先，登录GitLab，创建一个新项目的私人仓库； 

2. 然后，在本地仓库（就是你写代码文件夹），右键，Git Bash Here，打开Git命令窗口； 

3. 按照如下步骤，添加远程仓库地址，并提交代码；  

   ```sh
   git init                           #初始化仓库
   git add .						 #把所有文件和文件夹添加到；
   git commit -m "first commit"       #把代码提交到本地仓库，并备注信息；
   git remote add origin 仓库地址      #设置远程仓库地址，创建远程主分支；
   git pull origin master 		       #把本地仓库的变化连接到远程仓库主分支
   git push -u origin master          #提交代码到远程仓库，master分支；
   ```

   **问题：**

   1) 添加远程仓库可能报错：`fatal: remote origin already exists.` 

   ```sh
   git remote -v：             #查看远程仓库详细信息，可以看到仓库名称
   git remote rm origin        #先删除远程 Git 仓库
   git remote add origin 仓库地址      #再添加远程 Git 仓库
   
   #也可以手动修改gitconfig文件的内容，把 [remote “origin”] 那一行删掉就好了
   vi .git/config              
   ```

   2) 不使用pull直接push可能报如下错误：`Updates were rejected because the remote contains work that you do`

   3)直接使用pull可能报如下错误：`fatal: refusing to merge unrelated histories` 

   ```sh
   git pull origin master --allow-unrelated-histories
   ```

   

### 将文件取消版本控制

以idea为例：

如果在.gitignore文件中没有指定忽略.idea文件夹（这个文件夹包含的是本地对项目的配置，如maven，字符编码等，不需要共享，所以无需提交），那么提交时就会将其提交到远程代码库中。如果已经.idea已经在远程仓库，那么再修改.gitignore文件就已经没用了，所以需要通过命令将远程的.idea文件夹取消版本控制

```sh
git rm -r --cached "要取消版本控制的文件或文件夹"		#将文件或文件夹取消版本控制
git commit -m "提交的信息"						  #提交到本地仓库 
git push origin master				#提交到远程分支，远程仓库的文件或文件夹将会被删除
```

最后在.gitignore文件中添加忽略.idea文件夹，并提交到远程仓库，如果需要将.idea文件夹添加版本控制，只需要将.gitignore文件中的.idea/删除即可

## Path

### jar包加载文件路径

a.txt 和 Application.java 在同一个目录下，b.txt 在类路径下

```java
public class Application {
    public static void main(String[] args) throws IOException {
        System.out.println(Application.class.getResource(""));
        System.out.println(Application.class.getResource("a.txt"));

        System.out.println(Application.class.getResource("/"));
        System.out.println(Application.class.getResource("/b.txt"));
        getFileContent(Application.class.getResource("/b.txt").getPath());

        System.out.println(Application.class.getClassLoader().getResource(""));
        System.out.println(Application.class.getClassLoader().getResource("b.txt"));
        getFileContent(Application.class.getClassLoader().getResource("b.txt").getPath());

        //报错空指针异常
        /*InputStream is = Application.class.getResourceAsStream("a.txt");
        byte[] bytes = new byte[100];
        is.read(bytes);
        System.out.println(new String(bytes));*/
        InputStream is2 = Application.class.getClassLoader().getResourceAsStream("b.txt");
        byte[] bytes2 = new byte[5];
        is2.read(bytes2);
        System.out.println(new String(bytes2));

    }

    private static void getFileContent(String path) throws IOException {
        FileInputStream fi=new FileInputStream(path);
        byte[] bytes = new byte[5];
        fi.read(bytes);
        System.out.println(new String(bytes));
    }
}

//本地输出
file:/E:/IdeaProjects/redis-master/redis-test/target/classes/com/huawei/fusioninsight/test/
null
    
file:/E:/IdeaProjects/redis-master/redis-test/target/classes/
file:/E:/IdeaProjects/redis-master/redis-test/target/classes/b.txt
bbbbb

file:/E:/IdeaProjects/redis-master/redis-test/target/classes/
file:/E:/IdeaProjects/redis-master/redis-test/target/classes/b.txt
bbbbb

bbbbb

//打成jar包输出
PS E:\IdeaProjects\redis-master\redis-test\target\jars> java -jar redis-test.jar

jar:file:/E:/IdeaProjects/redis-master/redis-test/target/jars/redis-test.jar!/com/huawei/fusioninsight/test/
null
    
null
jar:file:/E:/IdeaProjects/redis-master/redis-test/target/jars/redis-test.jar!/b.txt
java.io.FileNotFoundException: file:\E:\IdeaProjects\redis-master\redis-test\target\jars\redis-test.jar!\b.txt (文件名、目录名或卷标语法不正确。)

null
jar:file:/E:/IdeaProjects/redis-master/redis-test/target/jars/redis-test.jar!/b.txt
java.io.FileNotFoundException: file:\E:\IdeaProjects\redis-master\redis-test\target\jars\redis-test.jar!\b.txt (文件名、目录名或卷标语法不正确。)

bbbbb
```

- 编译时只会加载在类路径下的文件
- 打成 jar 包后无法获取类路径目录，但是可以获取类路径下具体文件路径
- 读取文件无法识别 redis-test.jar! 目录，只能使用 getResourceAsStream 方法读取文件

[Java代码打成jar后 classgetClassLoadergetResource("")返回为null](https://blog.csdn.net/wqc19920906/article/details/79263269)

[读取Jar包中的资源问题探究](https://blog.csdn.net/withiter/article/details/11924095)





## Java基础

### java -cp命令

jvm搜索类，系统会先在当前包下找，然后会在 jre 中的 rt.jar 文件下找，最后会在 classpath 所指向的路径下找； -cp 即 -classpath，可以指定classpath；java -cp 和 -classpath 一样，是指定类运行所依赖其他类的路径，通常是类库，jar包之类，需要全路径到jar包 。

```sh
#windows
#编译
$ javac -cp 绝对路径1.jar;绝对路径2.jar java文件名.java

#运行
$ java -cp .;../lib/*;../common.jar;../list/*.jar;../conf packname.mainclassname(此类有main方法)
```

```sh
#linux
#编译
$ javac -cp 绝对路径1.jar:绝对路径2.jar java文件名.java

#运行
$ java -cp .:../lib/*:../common.jar:../list/*.jar:../conf packname.mainclassname(此类有main方法)
```



### 引用 jar 包中的 jar 包

 [java命令执行jar包的方式](https://www.cnblogs.com/zpbolgs/p/7267384.html)

### 启动 jar 包

jar 包内目录 META-INF 下的 MANIFEST.MF 文件可以指定入口的方法，

```java
//META-INF\MANIFEST.MF的内容：
Manifest-Version: 1.0 
Main-Class: test.core.Core 
```

```sh
#pom中build指定mainClass && META-INF\MANIFEST.MF文件中增加了Main-Class: test.core.Core
$ java -cp test-jar-with-dependencies.jar  test.core.Core  //执行成功
$ java -jar test-jar-with-dependencies.jar  //执行成功
```

[启动jar包](https://www.cnblogs.com/klb561/p/10850803.html)






































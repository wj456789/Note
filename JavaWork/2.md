## Java8

```java
// 把几个小的list转换到一个大的list
public class Test {
    public static void main(String args[]) {
        List<String> teamIndia = Arrays.asList("Virat", "Dhoni", "Jadeja");
        List<String> teamAustralia = Arrays.asList("Warner", "Watson", "Smith");
        List<String> teamEngland = Arrays.asList("Alex", "Bell", "Broad");
        
        List<List<String>> playersInWorldCup2016 = new ArrayList<>();
        playersInWorldCup2016.add(teamIndia);
        playersInWorldCup2016.add(teamAustralia);
        playersInWorldCup2016.add(teamEngland);
        
        // before Java 8
        List<String> listOfAllPlayers = new ArrayList<>();
        for(List<String> team : playersInWorldCup2016){
            for(String name : team){
                listOfAllPlayers.add(name);
            }
        }
        System.out.println("Players playing in world cup 2016");
        System.out.println(listOfAllPlayers);
        
        
        // in Java 8 using FlatMap
        List<String> flatMapList = playersInWorldCup2016.stream()
                                                        .flatMap(pList -> pList.stream())
                                                        .collect(Collectors.toList());
        System.out.println("List of all Players using Java 8");
        System.out.println(flatMapList);
    }

}
```

[时间，字符串和Long时间戳互转](https://blog.csdn.net/u012843361/article/details/80496272)

## 多线程

**Locked ownable synchronizers**

每个线程线的最后部分输出的当前线程持有的锁对象，类型和地址。

[Locked ownable synchronizers（转）](https://www.cnblogs.com/softidea/p/4440290.html)

[ForkJoinPool](https://segmentfault.com/a/1190000039267451)



## CPU使用率飙升

CPU 使用率高的关键因素是计算密集型操作 

日常程序中常见的耗CPU的操作：

1、频繁GC，访问量高时，有可能造成频繁的GC、甚至FGC。当调用量大时，内存分配过快，就会造成GC线程不停的执行，导致CPU飙高

2、序列化与反序列化，后文中举了一个真实的案例，程序执行xml解析的时，调用量增大的情况下，导致了CPU被打满

3、加密解密

4、正则表达式校验，曾经线上发生一次血案，正则校验将CPU打满。大概原因是：Java 正则表达式使用的引擎实现是 NFA 自动机，这种引擎在进行字符匹配会发生回溯（backtracking）

5、线程上下文切换、当启动了很多线程，而这些线程都处于不断的阻塞状态（锁等待、IO等待等）和执行状态的变化过程中。当锁竞争激烈时，很容易出现这种情况

6、某些线程在做无阻塞的运算，简单的例子while(true)中不停的做运算，没有任何阻塞。写程序时，如果需要做很久的计算，可以适当将程序sleep下

7、Excel 导出事件

[CPU使用率飙升](https://cloud.tencent.com/developer/article/1650717)



## 工具

```java
public static void main(String[] args) {
    ExportInterFaceDomain exportInterFaceDomain=new ExportInterFaceDomain();
    exportInterFaceDomain.setTableDesc("123");
    try {
        System.out.println(BeanUtils.getProperty(exportInterFaceDomain, "tableDesc"));
    } catch (IllegalAccessException e) {
        e.printStackTrace();
    } catch (InvocationTargetException e) {
        e.printStackTrace();
    } catch (NoSuchMethodException e) {
        e.printStackTrace();
    }
}
```



## Linux

```sh
deleteJar/datacatalog.war/WEB-INF/lib/elasticsearch-7.3.1.jar

# -q 不显示指令执行过程。-d 从压缩文件内删除指定的文件。
$ cd deleteJar/
$ zip -q -d datacatalog.war WEB-INF/lib/elasticsearch-7.3.1.jar
```



```sh
$ cat /etc/*release

# 将当前目录下的所有文件打成jar包，jar包名为main.jar
$ jar -cvf ./main.jar ./

# 使用jar命令替换jar中的一个或多个文件
https://blog.csdn.net/ab7253957/article/details/77850111

# 运行jar包，会自动到 jar 包中查询mainfest中定义的启动类并运行
$ java -jar  *.jar param1 param2

# 将lib下的所有jar文件以及etc下的所有配置文件添加到 classpath 中，并在classpath 中寻找 com.Start类（main方法类）并运行
$ java -cp lib/*;etc/ com.Start
# jar 文件引入classpath，通配符不能写成*.jar， 只能使用*或123*，配置文件引入classpath，只能写到目录/， 不能添加*
```

### set

```sh
# 命令行下不带任何参数，直接运行set，会显示所有的环境变量和 Shell 函数。
$ set

# 在shell脚本中，set命令用来修改 Shell 环境的运行参数，也就是可以定制环境，如：
#!/bin/bash
set -ex
```

```sh
# 遇到不存在的变量就会报错，并停止执行
set -u

# 用来在运行结果之前，先输出执行的那一行命令。
set -x

# 脚本只要发生错误，就终止执行。
set -e

#set -e有一个例外情况，就是不适用于管道命令。
#所谓管道命令，就是多个子命令通过管道运算符（|）组合成为一个大的命令。Bash 会把最后一个子命令的返回值，作为整个命令的返回值。也就是说，只要最后一个子命令不失败，管道命令总是会执行成功，因此它后面命令依然会执行，set -e就失效了。set -o pipefail用来解决这种情况，只要一个子命令失败，整个管道命令就失败，脚本就会终止执行。
set -o pipefail

# 整合写法，建议放在所有 Bash 脚本的头部。
# 写法一
set -euxo pipefail

# 写法二
set -eux
set -o pipefail

#另一种办法是在执行 Bash 脚本的时候，从命令行传入这些参数。
$ bash -euxo pipefail script.sh
```



[Bash 脚本 set 命令教程](http://www.ruanyifeng.com/blog/2017/11/bash-set.html)

[set命令详解](https://www.cnblogs.com/insane-Mr-Li/p/9096859.html)

## Maven

在使用maven命令的时候 添加忽略SSL证书校验。

```sh
maven命令 -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true -Dmaven.wagon.http.ssl.ignore.validity.dates=true

# 例如：
$ mvn help:system -Dmaven.wagon.http.ssl.insecure=true -Dmaven.wagon.http.ssl.allowall=true -Dmaven.wagon.http.ssl.ignore.valid
```



## Normalizer.normalize()

normalize方法对外部输入字符串做归一化/标准化处理，如：

```java
//将全角形式的字符转化为半角形式的字符，"＜root＞"-->"<root>"
Normalizer.normalize(str,Normalizer.Form.NFKC);
```

[关于Normalizer.normalize()方法的用途](https://blog.csdn.net/u010512607/article/details/79921353)







## IDEA

1. 手动按快捷键删除无用的包引用： CTRL+ALT+O.
2. 自动删除无用的包引用。 CTRL+ALT+S打开Setting界面，点击Editor->General->Auto **Import**。 并将 【Optimize **imports** on the fly】选项选中后保存。 编辑器就会自动清除无用的包引用。



用`F2/Shift+F2`来快速定位错误和警告 



Settings→Editor→General→Auto Import 
然后勾选Add unambiguous imports on the fly以及Optimize imports on the fly



Add unambiguous imports on the fly：快速添加明确的导入。

Optimize imports on the fly：快速优化导入，优化的意思即自动帮助删除无用的导入。




## 正则表达式

```java
System.out.println("as/asdas/as".replaceAll("(?<=/).*?(?=/)","*"));		// as/*/as
System.out.println("as/asdas/as".replaceAll("(?=/).*?(?<=/)","*"));		// as*asdas*as
```

在频繁调用的场景（例如在方法体内或循环语句中）中，定义Pattern会导致重复预编译正则表达式，降低程序执行效率。另外，对于JDK中的某些API会接受字符串格式的正则表达式作为参数，如`String.replaceAll`、`String.split`等，对于这些API的使用也要考虑性能问题。 

```java
【反例】
public class RegexExp {
    // 该方法被频繁调用
    private boolean isLowerCase(String str) {
        Pattern pattern = Pattern.compile("[a-z]+");
        if (pattern.matcher(str).find()) {
            return true;
        }
        return false;
    }
}
【正例】
public class RegexExp {
    private static final Pattern CHARSET_REG = Pattern.compile("[a-z]+");
    // 该方法被频繁调用
    private boolean isLowerCase(String str) {
        if (CHARSET_REG.matcher(str).find()) {
            return true;
        }
        return false;
    }
}

【反例】
public void doSomething() {
    ...
    for(String temp : strList) {
        temp.replaceAll(regex, "XXX");
        ...
     }
     ...
}
【正例】
public void doSomething() {
    ...
    Pattern pattern = Pattern.compile(regex);  
    for(String temp : strList) {
        pattern.matcher(temp).replaceAll("XXX");
        ...
     }
     ...
}
```

```java
(?i) 表示所在位置右侧的表达式开启忽略大小写模式
(?s) 表示所在位置右侧的表达式开启单行模式，更改句点字符 (.) 的含义，以使它与每个字符（而不是除 \n 之外的所有字符）匹配，通常在匹配有换行的文本时使用
(?m) 表示所在位置右侧的表示式开启指定多行模式，更改 ^ 和 $ 的含义，以使它们分别与任何行的开头和结尾匹配,而不只是与整个字符串的开头和结尾匹配，只有在正则表达式中涉及到多行的“^”和“$”的匹配时，才使用Multiline模式,
上面的匹配模式可以组合使用，比如(?is),(?im)，另外，还可以用(?i:exp)或者(?i)exp(?-i)来指定匹配的有效范围

附：
.表示除\n之外的任意字符

public static void main(String[] args) {
    System.out.println("1.xLSx".matches("^.+\\.(?i)(xlsx)$"));
    System.out.println("\t\n1.xlsx".matches("^(?s)(.+\\.xlsx)$"));
    System.out.println("\t\n1.xlsx".matches(".+\\.xlsx$"));
    System.out.println("789\na".matches("^\\d+\n\\w*$"));
    System.out.println("789\na".matches("(?m)(^\\d+$\n\\w*)"));
    System.out.println("789\na".matches("^\\d+$\n\\w*"));
    
}

true
true
false
true
true
false

(?x)：表示如果加上该修饰符，表达式中的空白字符将会被忽略，除非它已经被转义。 
(?e)：表示本修饰符仅仅对于replacement有用，代表在replacement中作为PHP代码。 
(?A)：表示如果使用这个修饰符，那么表达式必须是匹配的字符串中的开头部分。比如说"/a/A"匹配"abcd"。 
(?E)：与"m"相反，表示如果使用这个修饰符，那么"$"将匹配绝对字符串的结尾，而不是换行符前面，默认就打开了这个模式。 
(?U)：表示和问号的作用差不多，用于设置"贪婪模式"。
```



### SQL

#### case when then用法

```sql
--简单case函数
case sex
  when '1' then '男'
  when '2' then '女’
  else '其他' end
  
--case搜索函数
case when sex = '1' then '男'
     when sex = '2' then '女'
     else '其他' end  
```



```sql
> select u.id,u.name,u.sex,
      (case u.sex
        when 1 then '男'
        when 2 then '女'
        else '空的'
        end
       )性别
    from users u;
 
id name                        sex	 性别
--------------------------------------------
1 张一                            	空的
2 张二                          1 	男
3 张三                            	空的
4 张四                            	空的
5 张五                          2 	女
6 张六                          1 	男
7 张七                          2 	女
8 张八                          1 	男

8 rows selected
```

```sql
> select
      sum(case u.sex when 1 then 1 else 0 end)男性,
      sum(case u.sex when 2 then 1 else 0 end)女性,
      sum(case when u.sex <>1 and u.sex<>2 then 1 else 0 end)性别为空
    from users u;
 
男性         女性       性别为空
---------- ---------- ----------
 3          2          0
```

### 精度误差

#### epslon

Math.abs(x)<1e-6 其实相当于 x == 0

1e-6 (也就是0.000001)叫做 epslon ，用来抵消浮点运算中因为误差造成的相等无法判断的情况。它通常是一个非常小的数字（具体多小要看你的运算误差），只要两数差值小于 epslon 可以视为相等

```java
//反例1
float a = 1.0f - 0.9f;
float b = 0.9f - 0.8f;
System.out.println(a == b);
//反例2
Float x = Float.valueOf(a);
Float y = Float.valueOf(b);
System.out.println(x.equals(y));

//正例
//指定一个误差范围，两个浮点数的插值在此范围之内，则认为是相等的
float diff = 1e-6f;
System.out.println(Math.abs(a - b) < diff);

//使用 Bigdecimal 来定义值，在进行浮点数运算操作
BigDecimal b1 = new BigDecimal("1.0");
BigDecimal b2 = new BigDecimal("0.9");
BigDecimal b3 = new BigDecimal("0.8");
BigDecimal s1 = b1.subtract(b2);
BigDecimal s2 = b2.subtract(b3);
System.out.println(s1.equals(s2));

输出：
false
false
true
true
```



```
String nowTime= DateTimeFormatter.ofPattern("yyyyMMdd").format(LocalDate.now());
```

## docker

**docker build** 命令用于使用 Dockerfile 创建镜像。 

```sh
#使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1
$ docker build -t runoob/ubuntu:v1 .

#-f 指定 Dockerfile 文件的位置
$ docker build -f /path/to/a/Dockerfile .
```

## JVM

### 内存泄露和内存溢出

- 内存泄漏（memory leak）：是指程序在申请内存后，**无法释放**已申请的内存空间，导致系统无法及时回收内存并且分配给其他进程使用。

- 内存溢出 （out of memory）：指程序**申请内存**时，没有足够的内存供申请者使用，导致数据无法正常存储到内存中。

内存泄露最终会导致内存溢出

[如何打破双亲委派机制](https://blog.csdn.net/cy973071263/article/details/104129163)

## Java基础

### 覆写, 重载, 隐藏, 遮蔽, 遮掩

重写方法名、返回值和形参 都不能改变，发生在父子类中；

重载形参必须不同，修饰符和返回值可以不同；

#### 隐藏(hide) 存在于子类和父类间

在子类中定义一个和父类相同的**属性, 静态方法或内部类**，父类成员则被隐藏，被隐藏后，将阻止其被继承

#### 遮蔽 (shadow) 存在于类内部

在类中定义和其他外部类名称相同的内部类，内部类中定义和外部类相同的**变量, 方法**，则其他外部类、外部类中的变量方法就被遮蔽了，在内部类中无法调用被遮蔽的变量方法。

#### 遮掩(obscure) 存在于类内部

一个变量可以遮掩具有相同名字的一个类

[Java 之 覆写, 重载, 隐藏, 遮蔽, 遮掩](https://blog.csdn.net/Beyond_Nothing/article/details/112465710)

### static

子类重写父类的静态方法，只要是父类的引用，无论是否指向子类的对象甚至指向null，调用的依然是父类的静态方法

https://blog.csdn.net/q306507291/article/details/118638850

### 远程调试

[IDEA 进行远程 Debug ](https://www.cnblogs.com/javastack/p/15484248.html)

[idea远程Remote使用](https://blog.csdn.net/weixin_42582494/article/details/115312211)

## 流

[BIO、NIO、AIO](https://www.cnblogs.com/williamjie/p/11194561.html)

## 回车换行符

System.getProperties("line.separator");获取换行符 



> line.separator（windows:"\r\n"；unix:"\n"）； 
>
> file.separator（windows:"\"；unix:"/"）； 
>
> path.separator（windows:";"；unix:":"）； 

Windows系统下，换行符中的"\r\n"：

\r 表示：回车符(ACSII：13 或0x0d)，就是我们常说的硬回车。

\n 表示：换行(ACSII：10 或0x0a)，就是我们常说的软回车。

\r 表示回车，仅表示完成，把光标回到行首

\n 表示换行，位置是当前光标位置的下一行的竖直位置。

\r\n 表示回车和换行，表示完成后，光标移动到下一行的行首。

按键盘上回车键时，会自动产生 \r\n.



Unix系统里，每行结尾只有“<换行>”，即“\n”；Windows系统里面，每行结尾是“<回车><换行>”，即“\r\n”；Mac系统里，每行结尾是“<回车>”。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。 



## SQL

### gaussDB

```mysql
# 修改 where 查询条件字段值
UPDATE DAMSDB.DATA_ASSETS_INFO_CONFIG SET ENTITY_TYPE=13 WHERE DATA_CONFIG_ID IN 
(SELECT DISTINCT DATA_CONFIG_ID FROM DAMSDB.DATA_ASSETS_INFO_CONFIG WHERE ENTITY_TYPE=10);

# 批量插入
INSERT INTO DAMSDB.DATA_ASSETS_INFO_CONFIG 
(DATA_CONFIG_ID,ENTITY_COLUMN,ENTITY_COLUMN_NAME,ENTITY_COLUMN_NAME_EN,ENTITY_COLUMN_ORDER,IS_HIDE,IS_TEMPLATE,ENTITY_TYPE,
TENEMENT,IS_FIELD,TEMPLATE_ORDER,FIELD_LENGTH) 
VALUES 
('1000','DATAPRODUCT_CODE','数据产品编码','DATA_DATAPRODUCT_INFO.DATAPRODUCT_CODE',1000,0,0,10,'GX',1,1000,'100'),
('1001','DATAPRODUCT_NAME_EN','数据产品英文名称','DATA_DATAPRODUCT_INFO.DATAPRODUCT_NAME_EN',1001,0,0,10,'GX',1,1001,'200'),
('1002','DATAPRODUCT_NAME_CN','数据产品中文名称','DATA_DATAPRODUCT_INFO.DATAPRODUCT_NAME_CN',1002,0,0,10,'GX',1,1002,'200');

# 单个添加表字段
ALTER TABLE DATA_API_INFO ADD COLUMN SHARING_SYSTEM_INFORMATION VARCHAR(2000) COMMENT '服务API共享系统信息';

# 批量添加表字段(表中旧字段已有记录，新加字段非空，默认空格，空包括空字符串)
ALTER TABLE DATA_DATAPRODUCT_INFO ADD  (
	DATAPRODUCT_UPDATE_TIME VARCHAR(20) COMMENT '数据产品更新时间',
	DATAPRODUCT_BUSINESS_DEPARTMENT VARCHAR(100) NOT NULL DEFAULT ' ' COMMENT '数据产品局方业务部门',
	DATAPRODUCT_BUSINESS_PIC VARCHAR(100) NOT NULL DEFAULT ' ' COMMENT '数据产品局方业务责任人'
);

# 修改表字段注释
COMMENT ON COLUMN DAMSDB.DATA_DATAPRODUCT_INFO.DATAPRODUCT_RELEASE_TYPE IS '发布类型';

# 修改表字段名称
ALTER TABLE DAMSDB.DATA_DATAPRODUCT_INFO RENAME COLUMN DATAPRODUCT_RELEASE_TYPE TO DATAPRODUCT_RELEASE_MODE;

# 删除表字段
ALTER TABLE DAMSDB.DATA_DATAPRODUCT_INFO DROP COLUMN DATAPRODUCT_BUSINESS_DEPARTMENT;
```



[java 将下划线方式命名的字符串转换为驼峰式](https://blog.csdn.net/qq_34626094/article/details/122578870)

[java将驼峰式命名的字符串转换为下划线大写方式](https://blog.csdn.net/sdgames/article/details/106471352)

 

IntelliJ IDEA中可以在主菜单中选择Navigate | Call Hierarchy命令查看一个Java方法调用树 

IntelliJ IDEA中可以在主菜单中选择Analyze | Data flow from/to Here两个命令查看表达式、变量和方法参数的传递关系树。 

IntelliJ IDEA的"Find Usage"可以查看一个Java类、方法或变量的直接使用情况。 

类关系图 在包或类上右键点击Diagram或者用快捷键Ctrl+Alt+U。

```sql
-- MINUS 集合前减后
select id,employee_name from employees 
minus 
select id,employee_name from dependents
order by id;
```

```sql
-- 查询多个字段并链接在一起
MySQL: CONCAT()
Oracle: CONCAT(), ||
SQL Server: +

CONCAT(字串1, 字串2, 字串3, ...): 将字串1、字串2、字串3，等字串连在一起。请注意，Oracle的CONCAT()只允许两个参数；
```

```sql
-- merge into 将源数据(来源于实际的表,视图,子查询)根据条件判断更新或插入到指定的表中(必须实际存在)
-- 这个语法仅需要一次全表扫描就完成了全部工作，执行效率要高于insert＋update，尤其是在大数据量面前，效率越明显。
```

[SQL语句merge into的用法](https://blog.csdn.net/peterwanghao/article/details/107559583)

## mybatis

sql中有一些特殊的字符的话，在解析xml文件的时候会被转义，但我们不希望他被转义，所以我们要使用<![CDATA[ ]]> 

<![CDATA[   ]]> 是XML语法。在CDATA内部的所有内容都会被解析器忽略。 

如果文本包含了很多的"<"字符 <=和"&"字符，那么最好把他们都放到CDATA部件中。 

**mybatis动态SQL  if 和 trim 标签**



**xml 中调用存储过程**



```xml
<select id="synchronousDataQualityFromBdi" databaseId="gauss" resultType="String">
    CALL p_synch_data_quality_d (#{statDate,mode=IN,jdbcType=VARCHAR})
</select>
```



```sql
/*sql中存储过程*/
CREATE OR REPLACE PROCEDURE P_SYNCH_DATA_QUALITY_D (
                             iv_stat_date in varchar2   --同步日期
                             ) 
as
/** head
  * @name                    p_synch_data_quality_d
  * @caption                 将数据质量数据同步到资产可视通用数据质量
  * @type                    iv_stat_date varchar2,format yyyymmdd
  * @parameter               oi_result integer 0 成功
  * @version                 2.0.0
  * @author                  w00212040
  * @create_date             2020-04-28
  * @copyright               Huawei
  * @modify1                 修改时请标注修改内容
  */
begin

  --同步到t_dataquality_rule_details
  delete from t_dataquality_rule_details a
   where a.stat_date = to_number(iv_stat_date) and a.data_source_id='1';

  insert into t_dataquality_rule_details
              (stat_date,
               ruleid,
               rulecode,
               rulename,
               objecttype,
               typeid,
               objecttypestr,
               createtime,
               createtimeformat,
               data_cycle,
               data_source_id
              )
     select to_number(iv_stat_date) as stat_date,
              a.rule_id,
              a.rule_id as rule_code,
              a.rule_name,
              '' as objecttype,
              case when a.type_description='唯一性' then 'Unique'
                when a.type_description='准确性' then 'Accuracy'
                when a.type_description='一致性' then 'Consistency'
                when a.type_description='完整性' then 'Integrity'
                when a.type_description='及时性' then 'Timeliness'
                else 'Validity'
              end typeid,
              case
                when a.column_name is not null then 'Field'
                else 'Table'
              end object_type_str,
              to_char(SYSDATE,'yyyymmdd hh24:mi:ss') as createtime,
              to_char(SYSDATE,'yyyymmdd hh24:mi:ss') as createtimeformat,
              a.data_cycle,
              '1' as data_source_id
         from t_dq_rule_def a;
  commit;

end;/
```





**databaseIdProvider多数据库支持**

MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前数据库 databaseId 属性的所有语句；如果带或者不带的语句都有，则不带的会被忽略。新增，修改和删除都有这个属性。 



[MyBatis之databaseIdProvider多数据库支持](https://blog.csdn.net/likewindy/article/details/51396576)

```java
// springboot中
@Configuration
public class DatabaseSwitchConfig {
    /**
     * 自动识别使用的数据库类型
     * 在mapper.xml中databaseId的值就是跟这里对应，
     * 如果没有databaseId选择则说明该sql适用所有数据库
     *
     * @return DatabaseIdProvider
     */
    @Bean
    public DatabaseIdProvider getDatabaseIdProvider() {
        Properties properties = new Properties();
        properties.setProperty("Oracle", "oracle");
        properties.setProperty("MySQL", "mysql");
        properties.setProperty("DB2", "db2");
        properties.setProperty("Derby", "derby");
        properties.setProperty("H2", "h2");
        properties.setProperty("HSQL", "hsql");
        properties.setProperty("Informix", "informix");
        properties.setProperty("MS-SQL", "ms-sql");
        properties.setProperty("PostgreSQL", "postgresql");
        properties.setProperty("Sybase", "sybase");
        properties.setProperty("Hana", "hana");
        properties.setProperty("Zenith", "gauss");
        DatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
        databaseIdProvider.setProperties(properties);
        return databaseIdProvider;
    }
}
```

```sql
<select id="getAssetsSquareSource" resultMap="AssetsSquare" databaseId="gauss">
        select NVL(COUNT(*),0) NUM
        FROM LOGICAL_ENTITY_INFO LOGICAL
        LEFT JOIN PHYSICAL_ENTITY_INFO PHYSICAL ON LOGICAL.LOGICALENTITY_ID = PHYSICAL.LOGICALENTITY_ID
        LEFT JOIN DATA_ASSETS_INFO LOGICALASSETS ON LOGICAL.DATA_CODE = LOGICALASSETS.DATA_CODE
        WHERE PHYSICAL.DATA_LEVEL = '1'
        AND LOGICALASSETS.STATE = '2'
        AND (LOGICALASSETS.ISPRIVATE = '0' OR LOGICALASSETS.DAMS_BEID =  #{damsBeId, jdbcType=VARCHAR})
        GROUP BY LOGICALASSETS.DATA_TYPE
</select>
    
    
<select id="getAssetsSquareSource" resultMap="AssetsSquare" databaseId="mysql">
        select IFNULL(COUNT(*),0) NUM
        FROM LOGICAL_ENTITY_INFO LOGICAL
        LEFT JOIN PHYSICAL_ENTITY_INFO PHYSICAL ON LOGICAL.LOGICALENTITY_ID = PHYSICAL.LOGICALENTITY_ID
        LEFT JOIN DATA_ASSETS_INFO LOGICALASSETS ON LOGICAL.DATA_CODE = LOGICALASSETS.DATA_CODE
        WHERE PHYSICAL.DATA_LEVEL = '1'
        AND LOGICALASSETS.STATE = '2'
        AND (LOGICALASSETS.ISPRIVATE = '0' OR LOGICALASSETS.DAMS_BEID =  #{damsBeId, jdbcType=VARCHAR})
        GROUP BY LOGICALASSETS.DATA_TYPE
</select>
```









[使用＜where＞标签替换where 1=1](https://blog.csdn.net/AttleeTao/article/details/114319763)

where标签只会在它包含的标签中有返回值的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where标签也会将它们去除。 











## 内部类

内部类主要为了实现多重继承问题，每个内部类都能独立地继承类 ，可以在单个外围类中，让多个内部类以不同的方式实现同一个接口，或者继承同一个类。

内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类。

成员内部类、局部内部类和匿名内部类会创建隐式引用，内部可以访问外部类的所有变量方法，外部访问内部必须先创建外部类对象，其中局部内部类作用域在方法内，在方法内部可以直接当成常规类使用。

静态内部类无隐式引用，内部可以访问外部类的所静态变量方法，不依赖于外部类可以直接当成常规类使用。

[方法中定义内部类](https://blog.csdn.net/weixin_46245201/article/details/111687848)



## Java 8 

[字符串和时间相互转换](https://blog.csdn.net/WLFIGHTER/article/details/113752001)



## 日志

**对info及以下级别的日志，应使用条件形式或占位符的方式进行输出。**

**【反例】**

如果日志级别设置为warning，下面日志不会打印，但是会执行字符串拼接操作，如果symbol是对象，会执行`toString()`方法，这样执行了上述操作，浪费系统资源，最终日志却没有打印。

```java
LOGGER.debug("Processing trade with id: " + id + " and symbol: " + symbol);
```

**【正例】**

```java
// 如果日志库提供了带"msgSupplier"的API，如下这样调用可以消除不必要的消息创建
LOGGER.debug(() ->    "Processing trade with id: " + id + " and symbol: " + symbol.fetchBigMessage());

// 采用条件方式
if (LOGGER.isDebugEnabled()) {    
    LOGGER.debug("Processing trade with id: " + id + " and symbol: " + symbol);
}

// 或者使用占位符
LOGGER.debug("Processing trade with id: {} and symbol: {}" , id, symbol);
```







## SpringBoot 

### 启动时实现自动执行代码 

#### java自身的启动时加载方式

##### static代码块

static静态代码块，在类加载的时候即自动执行。

##### 构造方法

在对象初始化时执行。执行顺序在static静态代码块之后。

#### Spring启动时加载方式

##### @PostConstruct注解

PostConstruct注解使用在方法上，这个方法在对象依赖注入初始化之后执行。

##### ApplicationRunner和CommandLineRunner

SpringBoot提供了两个接口来实现Spring容器启动完成后执行的功能，两个接口分别为`CommandLineRunner`和`ApplicationRunner`。

这两个接口需要实现一个run方法，将代码在run中实现即可。这两个接口功能基本一致，其区别在于run方法的入参。`ApplicationRunner`的run方法入参为`ApplicationArguments`，为`CommandLineRunner`的run方法入参为String数组。

**Order注解**

当有多个类实现了`CommandLineRunner`和`ApplicationRunner`接口时，可以通过在类上添加@Order注解来设定运行顺序。

```java
// TestPostConstruct
@Component
public class TestPostConstruct {
    static {
        System.out.println("static");
    }
    public TestPostConstruct() {
        System.out.println("constructer");
    }
    @PostConstruct
    public void init() {
        System.out.println("PostConstruct");
    }
}

// TestApplicationRunner
@Component
@Order(1)
public class TestApplicationRunner implements ApplicationRunner{
    @Override
    public void run(ApplicationArguments applicationArguments) throws Exception {
        System.out.println("order1:TestApplicationRunner");
    }
}

// TestCommandLineRunner
@Component
@Order(2)
public class TestCommandLineRunner implements CommandLineRunner {
    @Override
    public void run(String... strings) throws Exception {
        System.out.println("order2:TestCommandLineRunner");
    }
}
```



### 总结

Spring应用启动过程中，肯定是要自动扫描有`@Component`注解的类，加载类并初始化对象进行自动注入。加载类时首先要执行static静态代码块中的代码，之后再初始化对象时会执行构造方法。

在对象注入完成后，调用带有`@PostConstruct`注解的方法。当容器启动成功后，再根据@Order注解的顺序调用`CommandLineRunner`和`ApplicationRunner`接口类中的run方法。

因此，加载顺序为`static`>`constructer`>`@PostConstruct`>`CommandLineRunner`和`ApplicationRunner`.



## BUG

#### springboot升级版本2.6.7报错

```java
1、Failed to instantiate [org.springframework.boot.autoconfigure.quartz.QuartzDataSourceScriptDatabaseInitializer]: Factory method 'quartzDataSourceScriptDatabaseInitializer' threw exception; nested exception is java.lang.IllegalStateException: Unable to detect database type


// 解决方式
Platform used for Quartz, Session, Integration, and Batch schema initialization cannot be configured 
// 配置文件添加
spring.quartz.jdbc.initialize-schema=never

2、循环依赖
// 解决方式:配置文件添加
spring.main.allow-circular-references=true
```


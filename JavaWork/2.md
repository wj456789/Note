[ForkJoinPool](https://segmentfault.com/a/1190000039267451)



## Normalizer.normalize()

normalize方法对外部输入字符串做归一化/标准化处理，如：

```java
//将全角形式的字符转化为半角形式的字符，"＜root＞"-->"<root>"
Normalizer.normalize(str,Normalizer.Form.NFKC);
```

[关于Normalizer.normalize()方法的用途](https://blog.csdn.net/u010512607/article/details/79921353)




## 正则表达式

```java
System.out.println("as/asdas/as".replaceAll("(?<=/).*?(?=/)","*"));		// as/*/as
System.out.println("as/asdas/as".replaceAll("(?=/).*?(?<=/)","*"));		// as*asdas*as
```

## Java8

```
String nowTime= DateTimeFormatter.ofPattern("yyyyMMdd").format(LocalDate.now());
```



## JVM

### 内存泄露和内存溢出

- 内存泄漏（memory leak）：是指程序在申请内存后，**无法释放**已申请的内存空间，导致系统无法及时回收内存并且分配给其他进程使用。

- 内存溢出 （out of memory）：指程序**申请内存**时，没有足够的内存供申请者使用，导致数据无法正常存储到内存中。

内存泄露最终会导致内存溢出

[如何打破双亲委派机制](https://blog.csdn.net/cy973071263/article/details/104129163)

## Java基础

### 覆写, 重载, 隐藏, 遮蔽, 遮掩

重写方法名、返回值和形参 都不能改变，发生在父子类中；

重载形参必须不同，修饰符和返回值可以不同；

#### 隐藏(hide) 存在于子类和父类间

在子类中定义一个和父类相同的**属性, 静态方法或内部类**，父类成员则被隐藏，被隐藏后，将阻止其被继承

#### 遮蔽 (shadow) 存在于类内部

在类中定义和其他外部类名称相同的内部类，内部类中定义和外部类相同的**变量, 方法**，则其他外部类、外部类中的变量方法就被遮蔽了，在内部类中无法调用被遮蔽的变量方法。

#### 遮掩(obscure) 存在于类内部

一个变量可以遮掩具有相同名字的一个类

[Java 之 覆写, 重载, 隐藏, 遮蔽, 遮掩](https://blog.csdn.net/Beyond_Nothing/article/details/112465710)

### static

子类重写父类的静态方法，只要是父类的引用，无论是否指向子类的对象甚至指向null，调用的依然是父类的静态方法

https://blog.csdn.net/q306507291/article/details/118638850

### 远程调试

[IDEA 进行远程 Debug ](https://www.cnblogs.com/javastack/p/15484248.html)

[idea远程Remote使用](https://blog.csdn.net/weixin_42582494/article/details/115312211)

## 流

[BIO、NIO、AIO](https://www.cnblogs.com/williamjie/p/11194561.html)

## 回车换行符

System.getProperties("line.separator");获取换行符 



> line.separator（windows:"\r\n"；unix:"\n"）； 
>
> file.separator（windows:"\"；unix:"/"）； 
>
> path.separator（windows:";"；unix:":"）； 

Windows系统下，换行符中的"\r\n"：

\r 表示：回车符(ACSII：13 或0x0d)，就是我们常说的硬回车。

\n 表示：换行(ACSII：10 或0x0a)，就是我们常说的软回车。

\r 表示回车，仅表示完成，把光标回到行首

\n 表示换行，位置是当前光标位置的下一行的竖直位置。

\r\n 表示回车和换行，表示完成后，光标移动到下一行的行首。

按键盘上回车键时，会自动产生 \r\n.



Unix系统里，每行结尾只有“<换行>”，即“\n”；Windows系统里面，每行结尾是“<回车><换行>”，即“\r\n”；Mac系统里，每行结尾是“<回车>”。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。 



## SQL

### gaussDB

```mysql
# 修改 where 查询条件字段值
UPDATE DAMSDB.DATA_ASSETS_INFO_CONFIG SET ENTITY_TYPE=13 WHERE DATA_CONFIG_ID IN 
(SELECT DISTINCT DATA_CONFIG_ID FROM DAMSDB.DATA_ASSETS_INFO_CONFIG WHERE ENTITY_TYPE=10);

# 批量插入
INSERT INTO DAMSDB.DATA_ASSETS_INFO_CONFIG 
(DATA_CONFIG_ID,ENTITY_COLUMN,ENTITY_COLUMN_NAME,ENTITY_COLUMN_NAME_EN,ENTITY_COLUMN_ORDER,IS_HIDE,IS_TEMPLATE,ENTITY_TYPE,
TENEMENT,IS_FIELD,TEMPLATE_ORDER,FIELD_LENGTH) 
VALUES 
('1000','DATAPRODUCT_CODE','数据产品编码','DATA_DATAPRODUCT_INFO.DATAPRODUCT_CODE',1000,0,0,10,'GX',1,1000,'100'),
('1001','DATAPRODUCT_NAME_EN','数据产品英文名称','DATA_DATAPRODUCT_INFO.DATAPRODUCT_NAME_EN',1001,0,0,10,'GX',1,1001,'200'),
('1002','DATAPRODUCT_NAME_CN','数据产品中文名称','DATA_DATAPRODUCT_INFO.DATAPRODUCT_NAME_CN',1002,0,0,10,'GX',1,1002,'200');

# 单个添加表字段
ALTER TABLE DATA_API_INFO ADD COLUMN SHARING_SYSTEM_INFORMATION VARCHAR(2000) COMMENT '服务API共享系统信息';

# 批量添加表字段(表中旧字段已有记录，新加字段非空，默认空格，空包括空字符串)
ALTER TABLE DATA_DATAPRODUCT_INFO ADD  (
	DATAPRODUCT_UPDATE_TIME VARCHAR(20) COMMENT '数据产品更新时间',
	DATAPRODUCT_BUSINESS_DEPARTMENT VARCHAR(100) NOT NULL DEFAULT ' ' COMMENT '数据产品局方业务部门',
	DATAPRODUCT_BUSINESS_PIC VARCHAR(100) NOT NULL DEFAULT ' ' COMMENT '数据产品局方业务责任人'
);

# 修改表字段注释
COMMENT ON COLUMN DAMSDB.DATA_DATAPRODUCT_INFO.DATAPRODUCT_RELEASE_TYPE IS '发布类型';

# 修改表字段名称
ALTER TABLE DAMSDB.DATA_DATAPRODUCT_INFO RENAME COLUMN DATAPRODUCT_RELEASE_TYPE TO DATAPRODUCT_RELEASE_MODE;

# 删除表字段
ALTER TABLE DAMSDB.DATA_DATAPRODUCT_INFO DROP COLUMN DATAPRODUCT_BUSINESS_DEPARTMENT;
```



[java 将下划线方式命名的字符串转换为驼峰式](https://blog.csdn.net/qq_34626094/article/details/122578870)

[java将驼峰式命名的字符串转换为下划线大写方式](https://blog.csdn.net/sdgames/article/details/106471352)

 

IntelliJ IDEA中可以在主菜单中选择Navigate | Call Hierarchy命令查看一个Java方法调用树 

IntelliJ IDEA中可以在主菜单中选择Analyze | Data flow from/to Here两个命令查看表达式、变量和方法参数的传递关系树。 

IntelliJ IDEA的"Find Usage"可以查看一个Java类、方法或变量的直接使用情况。 

类关系图 在包或类上右键点击Diagram或者用快捷键Ctrl+Alt+U。

```sql
-- MINUS 集合前减后
select id,employee_name from employees 
minus 
select id,employee_name from dependents
order by id;
```

```sql
-- 查询多个字段并链接在一起
MySQL: CONCAT()
Oracle: CONCAT(), ||
SQL Server: +

CONCAT(字串1, 字串2, 字串3, ...): 将字串1、字串2、字串3，等字串连在一起。请注意，Oracle的CONCAT()只允许两个参数；
```

```sql
-- merge into 将源数据(来源于实际的表,视图,子查询)根据条件判断更新或插入到指定的表中(必须实际存在)
-- 这个语法仅需要一次全表扫描就完成了全部工作，执行效率要高于insert＋update，尤其是在大数据量面前，效率越明显。
```

[SQL语句merge into的用法](https://blog.csdn.net/peterwanghao/article/details/107559583)

## mybatis

sql中有一些特殊的字符的话，在解析xml文件的时候会被转义，但我们不希望他被转义，所以我们要使用<![CDATA[ ]]> 

<![CDATA[   ]]> 是XML语法。在CDATA内部的所有内容都会被解析器忽略。 

如果文本包含了很多的"<"字符 <=和"&"字符，那么最好把他们都放到CDATA部件中。 

**mybatis动态SQL  if 和 trim 标签**



**xml 中调用存储过程**



```xml
<select id="synchronousDataQualityFromBdi" databaseId="gauss" resultType="String">
    CALL p_synch_data_quality_d (#{statDate,mode=IN,jdbcType=VARCHAR})
</select>
```



```sql
/*sql中存储过程*/
CREATE OR REPLACE PROCEDURE P_SYNCH_DATA_QUALITY_D (
                             iv_stat_date in varchar2   --同步日期
                             ) 
as
/** head
  * @name                    p_synch_data_quality_d
  * @caption                 将数据质量数据同步到资产可视通用数据质量
  * @type                    iv_stat_date varchar2,format yyyymmdd
  * @parameter               oi_result integer 0 成功
  * @version                 2.0.0
  * @author                  w00212040
  * @create_date             2020-04-28
  * @copyright               Huawei
  * @modify1                 修改时请标注修改内容
  */
begin

  --同步到t_dataquality_rule_details
  delete from t_dataquality_rule_details a
   where a.stat_date = to_number(iv_stat_date) and a.data_source_id='1';

  insert into t_dataquality_rule_details
              (stat_date,
               ruleid,
               rulecode,
               rulename,
               objecttype,
               typeid,
               objecttypestr,
               createtime,
               createtimeformat,
               data_cycle,
               data_source_id
              )
     select to_number(iv_stat_date) as stat_date,
              a.rule_id,
              a.rule_id as rule_code,
              a.rule_name,
              '' as objecttype,
              case when a.type_description='唯一性' then 'Unique'
                when a.type_description='准确性' then 'Accuracy'
                when a.type_description='一致性' then 'Consistency'
                when a.type_description='完整性' then 'Integrity'
                when a.type_description='及时性' then 'Timeliness'
                else 'Validity'
              end typeid,
              case
                when a.column_name is not null then 'Field'
                else 'Table'
              end object_type_str,
              to_char(SYSDATE,'yyyymmdd hh24:mi:ss') as createtime,
              to_char(SYSDATE,'yyyymmdd hh24:mi:ss') as createtimeformat,
              a.data_cycle,
              '1' as data_source_id
         from t_dq_rule_def a;
  commit;

end;/
```





**databaseIdProvider多数据库支持**

MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前数据库 databaseId 属性的所有语句；如果带或者不带的语句都有，则不带的会被忽略。新增，修改和删除都有这个属性。 



[MyBatis之databaseIdProvider多数据库支持](https://blog.csdn.net/likewindy/article/details/51396576)

```java
// springboot中
@Configuration
public class DatabaseSwitchConfig {
    /**
     * 自动识别使用的数据库类型
     * 在mapper.xml中databaseId的值就是跟这里对应，
     * 如果没有databaseId选择则说明该sql适用所有数据库
     *
     * @return DatabaseIdProvider
     */
    @Bean
    public DatabaseIdProvider getDatabaseIdProvider() {
        Properties properties = new Properties();
        properties.setProperty("Oracle", "oracle");
        properties.setProperty("MySQL", "mysql");
        properties.setProperty("DB2", "db2");
        properties.setProperty("Derby", "derby");
        properties.setProperty("H2", "h2");
        properties.setProperty("HSQL", "hsql");
        properties.setProperty("Informix", "informix");
        properties.setProperty("MS-SQL", "ms-sql");
        properties.setProperty("PostgreSQL", "postgresql");
        properties.setProperty("Sybase", "sybase");
        properties.setProperty("Hana", "hana");
        properties.setProperty("Zenith", "gauss");
        DatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
        databaseIdProvider.setProperties(properties);
        return databaseIdProvider;
    }
}
```

```sql
<select id="getAssetsSquareSource" resultMap="AssetsSquare" databaseId="gauss">
        select NVL(COUNT(*),0) NUM
        FROM LOGICAL_ENTITY_INFO LOGICAL
        LEFT JOIN PHYSICAL_ENTITY_INFO PHYSICAL ON LOGICAL.LOGICALENTITY_ID = PHYSICAL.LOGICALENTITY_ID
        LEFT JOIN DATA_ASSETS_INFO LOGICALASSETS ON LOGICAL.DATA_CODE = LOGICALASSETS.DATA_CODE
        WHERE PHYSICAL.DATA_LEVEL = '1'
        AND LOGICALASSETS.STATE = '2'
        AND (LOGICALASSETS.ISPRIVATE = '0' OR LOGICALASSETS.DAMS_BEID =  #{damsBeId, jdbcType=VARCHAR})
        GROUP BY LOGICALASSETS.DATA_TYPE
</select>
    
    
<select id="getAssetsSquareSource" resultMap="AssetsSquare" databaseId="mysql">
        select IFNULL(COUNT(*),0) NUM
        FROM LOGICAL_ENTITY_INFO LOGICAL
        LEFT JOIN PHYSICAL_ENTITY_INFO PHYSICAL ON LOGICAL.LOGICALENTITY_ID = PHYSICAL.LOGICALENTITY_ID
        LEFT JOIN DATA_ASSETS_INFO LOGICALASSETS ON LOGICAL.DATA_CODE = LOGICALASSETS.DATA_CODE
        WHERE PHYSICAL.DATA_LEVEL = '1'
        AND LOGICALASSETS.STATE = '2'
        AND (LOGICALASSETS.ISPRIVATE = '0' OR LOGICALASSETS.DAMS_BEID =  #{damsBeId, jdbcType=VARCHAR})
        GROUP BY LOGICALASSETS.DATA_TYPE
</select>
```









[使用＜where＞标签替换where 1=1](https://blog.csdn.net/AttleeTao/article/details/114319763)

where标签只会在它包含的标签中有返回值的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where标签也会将它们去除。 











## 内部类

内部类主要为了实现多重继承问题，每个内部类都能独立地继承类 ，可以在单个外围类中，让多个内部类以不同的方式实现同一个接口，或者继承同一个类。

内部类是个编译时的概念，一旦编译成功后，它就与外围类属于两个完全不同的类。

成员内部类、局部内部类和匿名内部类会创建隐式引用，内部可以访问外部类的所有变量方法，外部访问内部必须先创建外部类对象，其中局部内部类作用域在方法内，在方法内部可以直接当成常规类使用。

静态内部类无隐式引用，内部可以访问外部类的所静态变量方法，不依赖于外部类可以直接当成常规类使用。

[方法中定义内部类](https://blog.csdn.net/weixin_46245201/article/details/111687848)



## Java 8 

[字符串和时间相互转换](https://blog.csdn.net/WLFIGHTER/article/details/113752001)



## 日志

**对info及以下级别的日志，应使用条件形式或占位符的方式进行输出。**

**【反例】**

如果日志级别设置为warning，下面日志不会打印，但是会执行字符串拼接操作，如果symbol是对象，会执行`toString()`方法，这样执行了上述操作，浪费系统资源，最终日志却没有打印。

```java
LOGGER.debug("Processing trade with id: " + id + " and symbol: " + symbol);
```

**【正例】**

```java
// 如果日志库提供了带"msgSupplier"的API，如下这样调用可以消除不必要的消息创建
LOGGER.debug(() ->    "Processing trade with id: " + id + " and symbol: " + symbol.fetchBigMessage());

// 采用条件方式
if (LOGGER.isDebugEnabled()) {    
    LOGGER.debug("Processing trade with id: " + id + " and symbol: " + symbol);
}

// 或者使用占位符
LOGGER.debug("Processing trade with id: {} and symbol: {}" , id, symbol);
```

## BUG

#### springboot升级版本2.6.7报错

```java
1、Failed to instantiate [org.springframework.boot.autoconfigure.quartz.QuartzDataSourceScriptDatabaseInitializer]: Factory method 'quartzDataSourceScriptDatabaseInitializer' threw exception; nested exception is java.lang.IllegalStateException: Unable to detect database type


// 解决方式
Platform used for Quartz, Session, Integration, and Batch schema initialization cannot be configured 
// 配置文件添加
spring.quartz.jdbc.initialize-schema=never

2、循环依赖
// 解决方式:配置文件添加
spring.main.allow-circular-references=true
```


# 算法和数据结构

## 数据结构

> 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。
>
> 通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。

数据结构包括数据的逻辑结构、数据的存储结构以及数据的运算；

- 逻辑结构有：集合结构、线性结构、树形结构和图状结构.
- 物理结构有：线性存储结构和非线性存储结构，线性存储结构(线性表)有顺序(顺序表)、链式(链表)、索引和散列4种结构；非线性存储结构有树形存储结构、图形存储结构。
  - 顺序使用连续地址空间存储元素
  - 链式中指针指向下一个元素地址
  - 索引使用索引表存放元素地址
  - 散列通过散列算法计算地址

线性表有栈，队列，实现方式可以是顺序表也可以是链表；顺序表有数组；非线性存储结构有树、堆、图。

集合中ArrayList是顺序表，LinkedList是链表；



## 算法

> 按照某种逻辑关系组织起来的一批数据，按一定的方式把它存放在计算机的内存里，在这个基础上为了实现某个功能（比如查找某个元素，删除某个元素，给所有元素排序等等）而进行的一些列操作，我们把这一些列的操作步骤描述出来就是算法。

**时间复杂度和空间复杂度是衡量算法优劣的重要指标：**

- 时间复杂度：是用程序执行的次数来衡量，不是程序执行的时间。

- 空间复杂度：用程序执行所需要的最大内存。

其中基本操作执行次数的函数 T(n)，若存在函数 f(n)，使得当n趋近于无穷大时，T(n)/ f(n)的极限值为不等于零的常数，则称 f(n)是T(n)的同数量级函数。

记作 T(n)= O(f(n))，称O(f(n)) 为算法的**渐进时间复杂度**，简称**时间复杂度**。渐进时间复杂度用大写O来表示，所以也被称为**大O表达式**。

**大O表达式                                     算法的好坏**

O(1) 												最好					大O常数阶

O(logn) 										  比较好				大O对数阶

O(n)                                                良好					大O线性阶

O(n^2)                                            不好					大O平方阶

O(n^3)                                            很不好				

O(2^n)                                            很很不好

O(n!)                                               最不好



**比如：**

> 给小灰一条长16寸的面包，小灰每5天吃掉面包剩余长度的一半，第一次吃掉8寸，第二次吃掉4寸，第三次吃掉2寸......那么小灰把面包吃得只剩下1寸，需要多少天呢？
>
> 这个问题翻译一下，就是数字16不断地除以2，除几次以后的结果等于1？这里要涉及到数学当中的对数，以2位底，16的对数，可以简写为lg16。
>
> 因此，把面包吃得只剩下1寸，需要 5 X lg16 = 5 X 4 = 20 天。
>
> 如果面包的长度是 N 寸呢？
>
> 需要 5 X lgN = 5lgN天，记作 T(n) = 5lgN

```java
void eat2(int n){
   for(int i=1; i<n; i*=2){     
       System.out.println("等待一天");
       System.out.println("等待一天");
       System.out.println("等待一天");
       System.out.println("等待一天");
       System.out.println("吃一半面包");
   }
}
```

程序的设计中要不就是时间换空间，要不就是用空间去换时间。并且时间和空间是可以进行相互转化的；我们在程序当中，请求分页，请求分段，都属于用时间去换空间。在项目当中使用各种缓存技术，都属于利用空间去换时间。

### 查找算法

> 有序数组的二分查找

```java
public int find(Integer[] array,int searchKey){
    int lowerBound=0;
    int upperBound=array.length-1;
    int curIn;

    while(true){
        curIn=(lowerBound+upperBound)/2;
        if(array[curIn]== searchKey){
            return curIn;
        }else if(lowerBound>upperBound){
            return array.length;
        }else{
            if(array[curIn]<searchKey){
                lowerBound=curIn+1;
            }else {
                upperBound=curIn-1;
            }
        }
    }
}
```



### 排序算法

#### 冒泡排序

```java
public static void main(String[] args) {
    Integer[] is=new Integer[]{2,3,1};
    bubSort(is);
    System.out.println(Arrays.asList(is));
}

public static void bubSort(Integer[] array){
    int outer;	//冒泡出来的元素放置的下标位置，从后向前 
    int inner;
    for(outer=array.length-1;outer>=1;outer--){
        for(inner=0;inner<outer;inner++){
            if(array[inner]>array[inner+1]){	//前面的元素比后面大，交换位置
                int temp=array[inner];
                array[inner]=array[inner+1];
                array[inner+1]=temp;
            }
        }
    }
}
```

#### 选择排序

```java
public static void selectSort(Integer[] array){
    int outer;	//选择出来的元素放置的下标位置，从前向后
    int inner;
    int min;

    for(outer=0;outer<array.length-1;outer++){
        min=outer;	//每次循环初始化min指向outer的位置，剩下的元素中的第一个
        for(inner=outer+1;inner<=array.length-1;inner++){
            if(array[inner]<array[min]){
                min=inner;
            }
        }//每次循环完成后，min指向的元素才是真正最小元素
        
        if(min!=outer){
            int temp=array[min];
            array[min]=array[outer];
            array[outer]=temp;
        }
    }
}
```



#### 插入排序

```java
public static void insertSort(Integer[] array){
    int outer;
    int inner;
    int temp;

    for(outer=1;outer<=array.length-1;outer++){
        inner=outer-1;
        temp=array[outer];
        while(inner>=0&&array[inner]>temp){
            array[inner+1]=array[inner];
            inner--;
        }
        array[inner+1]=temp;
    }
}
```



```java
public static void main(String[] args) {
    int[] array=new int[]{1,67,9,32,54,7,12};
    sort(array);
    for(int i:array){
        System.out.println(i);
    }
}

//数列中每一个数和之前数据比较，如果之前的数较大，往后移位，直到之前的数较小，在这之后插入这个数
public static void sort(int[] array){
    int preIndex;
    int current;
    for(int i=1;i<=array.length-1;i++){
        preIndex=i-1;
        current=array[i];
        while(preIndex>=0&&array[preIndex]>current){
            array[preIndex+1]=array[preIndex];
            preIndex--;
        }
        array[preIndex+1]=current;
    }
}
```

#### 希尔排序

也是一种插入排序

将数组按照增量分组，对每组使用直接插入排序算法排序，初始增量gap=length/2，然后缩小增量gap=gap/2，直到增量为1将整个数组分为一组

如100个数据，先分为100/2=50组，每组2个值，每组分别排序

​						  再分为50/2=25组，每组4个值

​						  再分为25/2=12组，每组9或8个值

​						  ...

​						  最后分为2/2=1组，100为一组整体排序

```java
public static void main(String[] args) {
    int[] array=new int[]{1,67,9,32,54,7,12};
    sort(array);
    for(int i:array){
        System.out.println(i);
    }
}

public static void sort(int[] array){
    int gap=array.length/2;
    while(gap>0){
        int preIndex;
        int current;
        for(int i=gap;i<=array.length-1;i++){
            preIndex=i-gap;
            current=array[i];
            while(preIndex>=0&&array[preIndex]>current){
                array[preIndex+gap]=array[preIndex];
                preIndex-=gap;
            }
            array[preIndex+gap]=current;
        }
        gap/=2;
    }
}
```



#### 快速排序

对于一个数列进行排序，比基准小的放在基准前，比基准大的放在基准后，然后再将小于基准的子序列和大于基准的子序列递归排序

```java
public static void main(String[] args) {
    int[] array=new int[]{1,67,9,32,54,7,12};
    quickSort(array, 0, array.length - 1);
    for(int i:array){
        System.out.println(i);
    }
}

public static void quickSort(int[] array,int start,int end){
    if(start>=end){
        return;
    }else{
        int patition = patition(array, start, end);
        if(patition>start){
            quickSort(array,start,patition-1);
        }
        if(patition<end){
            quickSort(array,patition+1,end);
        }
    }
}

//选开始值为基准，从前开始找到大于基准的坐标，从后开始找到小于基准的坐标，将两个值交换，然后在两个坐标之间继续循环，直到从后开始的坐标小于从前开始的坐标
public static int patition(int[] array,int start,int end){
    int i=start;
    int j=end+1;
    int pivot=array[start];		//pivot为基准值
    while(true){
        while(i<end&&array[++i]<pivot){}	//取大于基准的坐标
        while(j>start&&array[--j]>pivot){}	//取小于基准的坐标
        if(i>=j){
            break;
        }else{
            swap(array,i,j);
        }
    }
    swap(array,j,start);
    return j;
}

public static int[] swap(int[] array,int i,int j){
    int temp=array[i];
    array[i]=array[j];
    array[j]=temp;
    return array;
}
```


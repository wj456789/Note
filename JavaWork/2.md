## maven

### plugin

#### maven-war-plugin

```xml
<!-- 打包成war包 -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-war-plugin</artifactId>
    <version>2.2</version>
    <configuration>
        <webResources>
            <resource>
                <directory>../data-assest-common/src/lib</directory>
                <targetPath>WEB-INF/lib/</targetPath>
                <includes>
                    <include>**/*.jar</include>
                </includes>
            </resource>
        </webResources>
        <!--如果想在没有web.xml文件的情况下构建WAR，请设置为false。-->
        <failOnMissingWebXml>false</failOnMissingWebXml>
    </configuration>
</plugin>
```



```xml
<!-- 
	1.可以打成直接运行的Jar包
	2.一般的maven项目的打包命令，不会把依赖的jar包也打包进去的，只是会放在jar包的同目录下，能够引用就可以了，但是spring-boot-maven-plugin插件，会将依赖的jar包全部打包进jar包内部。
	3.可以指定默认执行类
 -->
<plugin>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-maven-plugin</artifactId>
    <version>2.2.4.RELEASE</version>
    <configuration>
        <mainClass>com.huawei.DataAssetApplicationHttp</mainClass>
        <!--<skip>true</skip>-->
        <!--<includeSystemScope>true</includeSystemScope>-->
        <!--<layout>ZIP</layout>-->
        <!--<includes>
            <include>
                <groupId>nothing</groupId>
                <artifactId>nothing</artifactId>
            </include>
        </includes>-->
    </configuration>
    <executions>
        <execution>
            <goals>
                <goal>repackage</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

**repackage作用：**

1、在原始 Maven 打包形成的 jar 包基础上，进行重新打包，新形成的 jar 包不但包含应用类文件和配置文件，而且还会包含应用所依赖的 jar 包以及 Springboot 启动相关类，以此来满足Springboot独立应用的特性；

2、将原始 Maven 打包的 jar 重命名为 XXX.jar.original 作为原始文件；


[spring-boot-maven-plugin打包war包](https://cloud.tencent.com/developer/article/1768906)



```xml
<!-- 设置打包的时候跳过测试用例,相当于 mvn package -Dmaven.test.skip=true -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <configuration>
        <skip>true</skip>
    </configuration>
</plugin>
```



```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.6.2</version>
    <configuration>
        <encoding>utf-8</encoding>
        <source>1.8</source>
        <target>1.8</target>
    </configuration>
</plugin>

https://www.cnblogs.com/east7/p/13363069.html
```





## Normalizer.normalize()

normalize方法对外部输入字符串做归一化/标准化处理，如：

```java
//将全角形式的字符转化为半角形式的字符，"＜root＞"-->"<root>"
Normalizer.normalize(str,Normalizer.Form.NFKC);
```

[关于Normalizer.normalize()方法的用途](https://blog.csdn.net/u010512607/article/details/79921353)





## Java8

```java
// 获取当前时间并格式化
String now  = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss").format(LocalDateTime.now());

// 获取 LocalDateTime 对象
LocalDateTime.now()：获取系统当前时间。

LocalDateTime.of(int year,int month,int dayOfMonth,int hour,int minute,int second) 按指定日期和时间创建LocalDateTime对象。

// LocalDateTime 对象方法
getYear()：返回日期中的年份。

getMonth()：返回日期中的月份。

getDayOfMonth()：返回月份中的日。

getHour()：返回小时。

getMinute()：返回分钟。

getSecond()：返回秒。
```



## IDEA

1. 手动按快捷键删除无用的包引用： CTRL+ALT+O.
2. 自动删除无用的包引用。 CTRL+ALT+S打开Setting界面，点击Editor->General->Auto **Import**。 并将 【Optimize **imports** on the fly】选项选中后保存。 编辑器就会自动清除无用的包引用。



用`F2/Shift+F2`来快速定位错误和警告 



Settings→Editor→General→Auto Import 
然后勾选Add unambiguous imports on the fly以及Optimize imports on the fly



Add unambiguous imports on the fly：快速添加明确的导入。

Optimize imports on the fly：快速优化导入，优化的意思即自动帮助删除无用的导入。




## 正则表达式

```java
System.out.println("as/asdas/as".replaceAll("(?<=/).*?(?=/)","*"));		// as/*/as
System.out.println("as/asdas/as".replaceAll("(?=/).*?(?<=/)","*"));		// as*asdas*as
```

在频繁调用的场景（例如在方法体内或循环语句中）中，定义Pattern会导致重复预编译正则表达式，降低程序执行效率。另外，对于JDK中的某些API会接受字符串格式的正则表达式作为参数，如`String.replaceAll`、`String.split`等，对于这些API的使用也要考虑性能问题。 

```java
【反例】
public class RegexExp {
    // 该方法被频繁调用
    private boolean isLowerCase(String str) {
        Pattern pattern = Pattern.compile("[a-z]+");
        if (pattern.matcher(str).find()) {
            return true;
        }
        return false;
    }
}
【正例】
public class RegexExp {
    private static final Pattern CHARSET_REG = Pattern.compile("[a-z]+");
    // 该方法被频繁调用
    private boolean isLowerCase(String str) {
        if (CHARSET_REG.matcher(str).find()) {
            return true;
        }
        return false;
    }
}

【反例】
public void doSomething() {
    ...
    for(String temp : strList) {
        temp.replaceAll(regex, "XXX");
        ...
     }
     ...
}
【正例】
public void doSomething() {
    ...
    Pattern pattern = Pattern.compile(regex);  
    for(String temp : strList) {
        pattern.matcher(temp).replaceAll("XXX");
        ...
     }
     ...
}
```



### SQL

#### case when then用法

```sql
--简单case函数
case sex
  when '1' then '男'
  when '2' then '女’
  else '其他' end
  
--case搜索函数
case when sex = '1' then '男'
     when sex = '2' then '女'
     else '其他' end  
```



```sql
> select u.id,u.name,u.sex,
      (case u.sex
        when 1 then '男'
        when 2 then '女'
        else '空的'
        end
       )性别
    from users u;
 
id name                        sex	 性别
--------------------------------------------
1 张一                            	空的
2 张二                          1 	男
3 张三                            	空的
4 张四                            	空的
5 张五                          2 	女
6 张六                          1 	男
7 张七                          2 	女
8 张八                          1 	男

8 rows selected
```

```sql
> select
      sum(case u.sex when 1 then 1 else 0 end)男性,
      sum(case u.sex when 2 then 1 else 0 end)女性,
      sum(case when u.sex <>1 and u.sex<>2 then 1 else 0 end)性别为空
    from users u;
 
男性         女性       性别为空
---------- ---------- ----------
 3          2          0
```

### 精度误差

#### epslon

Math.abs(x)<1e-6 其实相当于 x == 0

1e-6 (也就是0.000001)叫做 epslon ，用来抵消浮点运算中因为误差造成的相等无法判断的情况。它通常是一个非常小的数字（具体多小要看你的运算误差），只要两数差值小于 epslon 可以视为相等

```java
//反例1
float a = 1.0f - 0.9f;
float b = 0.9f - 0.8f;
System.out.println(a == b);
//反例2
Float x = Float.valueOf(a);
Float y = Float.valueOf(b);
System.out.println(x.equals(y));

//正例
//指定一个误差范围，两个浮点数的插值在此范围之内，则认为是相等的
float diff = 1e-6f;
System.out.println(Math.abs(a - b) < diff);

//使用 Bigdecimal 来定义值，在进行浮点数运算操作
BigDecimal b1 = new BigDecimal("1.0");
BigDecimal b2 = new BigDecimal("0.9");
BigDecimal b3 = new BigDecimal("0.8");
BigDecimal s1 = b1.subtract(b2);
BigDecimal s2 = b2.subtract(b3);
System.out.println(s1.equals(s2));

输出：
false
false
true
true
```



```
String nowTime= DateTimeFormatter.ofPattern("yyyyMMdd").format(LocalDate.now());
```

## docker

**docker build** 命令用于使用 Dockerfile 创建镜像。 

```sh
#使用当前目录的 Dockerfile 创建镜像，标签为 runoob/ubuntu:v1
$ docker build -t runoob/ubuntu:v1 .

#-f 指定 Dockerfile 文件的位置
$ docker build -f /path/to/a/Dockerfile .
```

## JVM

### 内存泄露和内存溢出

- 内存泄漏（memory leak）：是指程序在申请内存后，**无法释放**已申请的内存空间，导致系统无法及时回收内存并且分配给其他进程使用。

- 内存溢出 （out of memory）：指程序**申请内存**时，没有足够的内存供申请者使用，导致数据无法正常存储到内存中。

内存泄露最终会导致内存溢出

## Java基础

### 覆写, 重载, 隐藏, 遮蔽, 遮掩

#### 隐藏(hide) 存在于子类和父类间

一个**属性, 静态方法或内部类**可以分别隐藏(hide) 在其超类中可以访问到的具有相同名字的所有属性, 方法或者内部类. 上述成员被隐藏后, 将阻止其被继承

#### 遮蔽 (shadow) 存在于类内部

一个**变量, 方法或类**可以分别 遮蔽(shadow) 在类内部具有相同名字的变量, 方法 或类. 如果一个实体被遮蔽了, 那么就无法用简单名引用到它, 简单名将引用到遮蔽声明中的实体

#### 遮掩(obscure) 存在于类内部

一个变量可以遮掩具有相同名字的一个类, 只要它们都在同一个范围内，如果这个名字被用于变量与类都许可的范围, 那么它将引用到变量上

遮蔽发生在相同类型之间，遮掩发生在不同类型之间

[Java 之 覆写, 重载, 隐藏, 遮蔽, 遮掩](https://blog.csdn.net/Beyond_Nothing/article/details/112465710)

### static

子类重写父类的静态方法，只要是父类的引用，无论是否指向子类的对象甚至指向null，调用的依然是父类的静态方法

https://blog.csdn.net/q306507291/article/details/118638850

### 远程调试

[IDEA 进行远程 Debug ](https://www.cnblogs.com/javastack/p/15484248.html)

[idea远程Remote使用](https://blog.csdn.net/weixin_42582494/article/details/115312211)

## 流

[BIO、NIO、AIO](https://www.cnblogs.com/williamjie/p/11194561.html)

## 回车换行符

System.getProperties("line.separator");获取换行符 



> line.separator（windows:"\r\n"；unix:"\n"）； 
>
> file.separator（windows:"\"；unix:"/"）； 
>
> path.separator（windows:";"；unix:":"）； 

Windows系统下，换行符中的"\r\n"：

\r 表示：回车符(ACSII：13 或0x0d)，就是我们常说的硬回车。

\n 表示：换行(ACSII：10 或0x0a)，就是我们常说的软回车。

\r 表示回车，仅表示完成，把光标回到行首

\n 表示换行，位置是当前光标位置的下一行的竖直位置。

\r\n 表示回车和换行，表示完成后，光标移动到下一行的行首。

按键盘上回车键时，会自动产生 \r\n.



Unix系统里，每行结尾只有“<换行>”，即“\n”；Windows系统里面，每行结尾是“<回车><换行>”，即“\r\n”；Mac系统里，每行结尾是“<回车>”。一个直接后果是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。 



## SQL

### gaussDB

```mysql
# 修改 where 查询条件字段值
UPDATE DAMSDB.DATA_ASSETS_INFO_CONFIG SET ENTITY_TYPE=13 WHERE DATA_CONFIG_ID IN 
(SELECT DISTINCT DATA_CONFIG_ID FROM DAMSDB.DATA_ASSETS_INFO_CONFIG WHERE ENTITY_TYPE=10);

# 批量插入
INSERT INTO DAMSDB.DATA_ASSETS_INFO_CONFIG 
(DATA_CONFIG_ID,ENTITY_COLUMN,ENTITY_COLUMN_NAME,ENTITY_COLUMN_NAME_EN,ENTITY_COLUMN_ORDER,IS_HIDE,IS_TEMPLATE,ENTITY_TYPE,
TENEMENT,IS_FIELD,TEMPLATE_ORDER,FIELD_LENGTH) 
VALUES 
('1000','DATAPRODUCT_CODE','数据产品编码','DATA_DATAPRODUCT_INFO.DATAPRODUCT_CODE',1000,0,0,10,'GX',1,1000,'100'),
('1001','DATAPRODUCT_NAME_EN','数据产品英文名称','DATA_DATAPRODUCT_INFO.DATAPRODUCT_NAME_EN',1001,0,0,10,'GX',1,1001,'200'),
('1002','DATAPRODUCT_NAME_CN','数据产品中文名称','DATA_DATAPRODUCT_INFO.DATAPRODUCT_NAME_CN',1002,0,0,10,'GX',1,1002,'200');

# 单个添加表字段
ALTER TABLE DATA_API_INFO ADD COLUMN SHARING_SYSTEM_INFORMATION VARCHAR(2000) COMMENT '服务API共享系统信息';

# 批量添加表字段(表中旧字段已有记录，新加字段非空，默认空格，空包括空字符串)
ALTER TABLE DATA_DATAPRODUCT_INFO ADD  (
	DATAPRODUCT_UPDATE_TIME VARCHAR(20) COMMENT '数据产品更新时间',
	DATAPRODUCT_BUSINESS_DEPARTMENT VARCHAR(100) NOT NULL DEFAULT ' ' COMMENT '数据产品局方业务部门',
	DATAPRODUCT_BUSINESS_PIC VARCHAR(100) NOT NULL DEFAULT ' ' COMMENT '数据产品局方业务责任人'
);

# 修改表字段注释
COMMENT ON COLUMN DAMSDB.DATA_DATAPRODUCT_INFO.DATAPRODUCT_RELEASE_TYPE IS '发布类型';

# 修改表字段名称
ALTER TABLE DAMSDB.DATA_DATAPRODUCT_INFO RENAME COLUMN DATAPRODUCT_RELEASE_TYPE TO DATAPRODUCT_RELEASE_MODE;

# 删除表字段
ALTER TABLE DAMSDB.DATA_DATAPRODUCT_INFO DROP COLUMN DATAPRODUCT_BUSINESS_DEPARTMENT;
```



[java 将下划线方式命名的字符串转换为驼峰式](https://blog.csdn.net/qq_34626094/article/details/122578870)

[java将驼峰式命名的字符串转换为下划线大写方式](https://blog.csdn.net/sdgames/article/details/106471352)

 

IntelliJ IDEA中可以在主菜单中选择Navigate | Call Hierarchy命令查看一个Java方法调用树 

IntelliJ IDEA中可以在主菜单中选择Analyze | Data flow from/to Here两个命令查看表达式、变量和方法参数的传递关系树。 

IntelliJ IDEA的"Find Usage"可以查看一个Java类、方法或变量的直接使用情况。 

类关系图 在包或类上右键点击Diagram或者用快捷键Ctrl+Alt+U。



## mybatis

sql中有一些特殊的字符的话，在解析xml文件的时候会被转义，但我们不希望他被转义，所以我们要使用<![CDATA[ ]]> 

<![CDATA[   ]]> 是XML语法。在CDATA内部的所有内容都会被解析器忽略。 

如果文本包含了很多的"<"字符 <=和"&"字符，那么最好把他们都放到CDATA部件中。 















































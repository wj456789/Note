## NIO

NIO（Non-blocking I/O，在Java领域，也称为New I/O）：一种同步非阻塞的I/O模型

Buffer（缓冲区）、Channel（通道）、Selector（选择器） 

client-->Buffer-->Channel<-->Channel-->Buffer-->server

### Buffer

Buffer：缓冲区本质为一块可读写数据的内存，Java中包装为Buffer对象，并提供了一组操作方法

Java NIO不同于IO的一点：NIO面向缓冲区，而IO面向流

- 读中，limit和capacity的含义相同；写中，capacity仍然代表这块缓冲区的大小，limit代表写的范围。 
- 标记（mark）一个备忘位置，调用mark()方法的话，mark值将存储当前position的值，等下次调用reset()方法时，会设定position的值为之前的标记值； 
- (capacity、limit、position、mark) 四个属性值之间的关系：0 <= mark <= position <= limit <= capacity

### Channel

- 双向异步，可读可写
- 通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入

### Selector

Selector：用于侦听多个通道是否已做好读写准备，配合非阻塞IO实现单个线程管理多个通道。













### 外部和内部类

1. 外部类初次加载，会初始化静态变量、静态代码块、静态方法，但不会加载内部类和静态内部类。
2. 实例化外部类，调用外部类的静态方法、静态变量，则外部类必须先进行加载，但只加载一次。
3. 直接调用静态内部类时，外部类不会加载。



## JVM

### 栈内存



```sh
# 打印当前对象的个数和大小
$ jmap -histo <java_pid>

# 打印当前存活对象的个数和大小,此命令会触发一次full gc
$ jmap -histo:live <java_pid>

# 查看gc情况
$ jstat -gc <pid> 

# 获取内存信息
$ jmap -heap:format=b <java_pid> 
在启动时增加-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath="具体的路径"，当系统OutOfMemory之后，会将内存信息收集下来。


jmap -dump:live,format=b,file=aaa 29082
```

```sh

# 查询物理CPU个数  
$ cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l

# 查询CPU内核个数  
$ cat /proc/cpuinfo| grep "cpu cores"| uniq


$ cat /proc/cpuinfo| grep "cpu cores"
cpu cores       : 4
cpu cores       : 4
cpu cores       : 4
cpu cores       : 4
cpu cores       : 4
cpu cores       : 4
cpu cores       : 4
cpu cores       : 4

$ cat /proc/cpuinfo| grep "cpu cores"| uniq
cpu cores       : 4

$ cat /proc/cpuinfo| grep "physical id"
physical id     : 0
physical id     : 0
physical id     : 0
physical id     : 0
physical id     : 0
physical id     : 0
physical id     : 0
physical id     : 0

$ cat /proc/cpuinfo| grep "physical id"| sort| uniq| wc -l
1
```

```java
GC日志:
-XX:PrintGCTimeStamps：打印 GC 时间
-XX:PrintGCDetails ：打印 GC 日志；
-Xloggc: path：保存GC 日志路径。
jstat –gcutil: 显示垃圾收集信息
```









### 堆内存

Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。 

### 引用类型

- 强引用：发生 gc 的时候不会被回收。
- 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。
- 弱引用：有用但不是必须的对象，在下一次GC时会被回收。
- 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。

#### 详解

##### strong reference

Object c = new Car(); //只要c还指向car object, car object就不会被回收，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

##### soft reference 

当系统内存不足时， soft reference指向的object才会被回收。

有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。 

##### weak reference

描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 

`WeakReference<Car> weakCar = new WeakReference<Car>(car);`

当一个对象仅仅被 weak reference 指向, 而没有任何其他 strong reference 指向的时候, 如果GC运行, 那么这个对象就会被回收。当要获得 weak reference 引用的 object 时, 首先需要判断它是否已经被回收     :`if(weakCar.get()!=null)`。

另外， java提供了一个ReferenceQueue来保存这些所指向的对象已经被回收的reference。

##### PhantomReference

无用对象，这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。 

### 垃圾识别

不会被访问到的对象是垃圾 

#### GC root 可达性分析

**GC root原理**：通过对枚举GC root对象做引用可达性分析，即从GC roots对象开始，向下搜索，形成的路径称之为引用链（从GC Roots开始遍历对象，没有被遍历到的对象为垃圾 ）。如果一个对象到GC roots对象没有任何引用，没有形成引用链，那么该对象等待GC回收。 

**Java中可以作为GC Roots的对象**

1、虚拟机栈（javaStack）中引用的对象，也就是方法栈使用到的参数、局部变量、临时变量等。

2、方法区中的类静态属性引用的对象。

3、方法区中常量引用的对象。

4、本地方法栈中 JNI (Native方法)引用的对象。

#### 引用计数法

记录每个对象被引用的数量，当被引用的数量为0时，则标记为垃圾

缺点：无法处理循环引用的问题

### 垃圾回收

#### 清除(sweep) 

将垃圾对象所占据的内存标记为空闲内存，然后存在一个空闲列表(free list)中。当需要创建对象时，从空闲列表中寻找空闲内存，分配给新创建的对象

#### 整理(compact)

把存活的对象搬到内存的起始位置，然后在连续的空间内顺序分配

#### 复制(copy)

将内存分为两个部分，并分别用 from 和 to 指针来维护。每次只在 from 指向的内存中分配内存，当发生垃圾回收时，将 from 指向区域中存活的对象复制到 to 指向的内存区域，然后将 from 指针和 to 指针互换位置。



年轻代的GC使用“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中） 

老年代 gc 用的是标记-整理算法，即标记存活的对象，向一端移动，保证内存的完整性，然后将未标记的清掉 

gc 主要的回收的内存区域有堆区和方法区



### 垃圾回收器

#### Minor GC

特点：发生次数多，采用时间短，回收掉大量对象

收集器：serial, Parallel Scavenge, Parallel New.均采用复制算法. Serial是单线程,Parallel New可以看成Serial多线程版本. Parallel Scanvenge和Parallel New类似，但更注重吞吐率，且不能与CMS一起使用

#### Full GC

特点：发生次数少，耗时长

收集器：Serial Old(整理), Parallel Old(整理), CMS(清除). Serial Old是单线程的，Parallel Old可以看成Serial Old的多线程版本.  CMS是并发收集器，除了初始标记和重新标记操作需要Stop the world，其它时间可以与应用程序一起并发执行



Full GC 触发条件

老年代空间不足；

方法区(Metaspace)空间不足；

通过minor GC进入老年代的平均大小大于老年代的可用内存；

老年代被写满；



## 远程调试

### server

- **jdk1.3x或之前**：-Xnoagent -Djava.compiler=NONE -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8788
- **jdk1.4x**： -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8788
- **jdk1.5-8**：-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8788

####  参数解析

- -Xrunjdwp/-agentlib:jdwp:  使用jdwp来运行调试环境
- transport: 通信方式，dt_socket使用的是socket,dt_shmem使用的是共享内存，其中dt_shmem只适用于windows
- server: 是否以作为调试服务端运行jvm
- suspend: 程序启动后先暂停，等待客户端连接
- address: 服务端监听的地址
- onuncaught：当出现uncaught exception 后，是否中断jvm运行

### client

- jdb  -connect com.sun.jdi.SocketAttach:port=5005,hostname=localhost
- stop, step, next, cont, locals, print, threads… , 可在jdk中通过help查看
- 也可以通过eclipse，IDEA 远程调试功能连接

**应用**

```sh
# linux可以在server端直接运行
$ java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8788

# client在linux调试
$ jdb -connect com.sun.jdi.SocketAttach:port=5005,hostname=localhost

# tomcat在 catalina.sh 开头加上下面一句话即可远程debug
CATALINA_OPTS="-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8788"
```

-client，-server 这两个参数用于设置虚拟机使用何种运行模式，一定要作为第一个参数，client模式启动比较快，但运行时性能和内存管理效率不如server模式，通常用于客户端应用程序。相反，server模式启动比client慢，但可获得更高的运行性能。 在windows上，缺省的虚拟机类型为client模式，如果要使用server模式，就需要在启动虚拟机时加-server参数，以获得更高性能，对服务器端应用，推荐采用server模式，尤其是多个CPU的系统。在Linux，Solaris上缺省采用server模式。  此外，在多cup下，建议用server模式 



JAVA_OPTS 直接设置 jvm 参数， 另一个 CATALINA_OPTS 设置 tomcat 参数

在linux和windows常使用不同方式设置：

Linux服务器：  在catalina.sh的第一行增加：  JAVA_OPTS=  -Xms64m  -Xmx256m  -XX:PermSize=128M  -XX:MaxNewSize=256m  -XX:MaxPermSize=256m 

Windows服务器：  在catalina.bat的第一行增加：  set JAVA_OPTS=-Xms64m -Xmx256m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=256m  





**容量(Capacity)**：缓冲区能够容纳的数据元素的最大数量; 位置(Position)：下一个要被读或写的元素的索引; 边界(Limit)：缓冲区的第一个不能被读或写的元素;标记(Mark)：一个备忘位置。** 



**ZipEntry.getSize()方法判断其大小，以试图解决之前的问题。但不幸的是，恶意攻击者可以伪造ZIP文件中用来描述解压条目大小的字段** 



**unmodifiableMap.clear()执行时报异常java.lang.UnsupportedOperationException**



规则7.2 方法抛出的异常，应该与本身的抽象层次相对应**

**规则7.3 在****ﬁ****nally****块中不要使用return、break或continue使****ﬁ****nally****块非正常结束**





Files.exists()



**如果List<String> list = new ArrayList<>();那么删除倒数第2个不会抛出异常，其他都抛出异常。**

**如果是LinkedList，那么最后一个和倒数第2个不会抛出异常不会抛出异常，其他都抛出异常。**

并且删除倒数第二个之后循环结束



List<? super T>（下界） 适合用来存放数据。只能添加T类型或其子类类型；添加存放之后这些类型都会转换为T的任意超类类型；取出元素可以强转为T泛型，也可以直接使用Object接受；

```java
ArrayList<? super Number> superList = new ArrayList<>();

Integer a = 10;
superList.add(a);

Number number = (Number) superList.get(0);
Object object = superList.get(0);
```



List<? extends T>（上界） 适合用来读取数据。 假如使用T类型不同的子类去添加到list中时，各种子类无法相互转换从而导致编译失败，因此不能添加元素，但是可以接收初始化赋值；读取出来的数据必须使用T类型或其父类接受，因为不确定具体的类型；

```java
ArrayList<? extends Number> extendsList = new ArrayList<>();

//extendsList.add(10); // 直接添加会报错

ArrayList<Integer> list = new ArrayList<>();
list.add(10);
extendsList = list; // 虽然不能直接添加元素，但是可以使用这种方式初始化，相当于将一个容器的东西倒入另一个容器，这种情况只能使用Number的子类作为泛型的集合才能给extendsList赋值，但是使用Number的父类做泛型的集合进行赋值就会报错。

// ArrayList<Object> objects = new ArrayList<>();
// objects.add("123");
// extendsList = objects; // Object是Number的父类，编译失败

Number number1 = extendsList.get(0);
Object object2 = extendsList.get(0);

//ArrayList<? extends Number> list1 = new ArrayList<Integer>();
//Integer number2 = list1.get(0); // 这样会报错，因为list1可能指的是List<Double>
```



1. 调用`invalidate()` 方法会使该Session无效，无效只是不能调用`setAttribute`或者`getAttribute`之类的方法了，Session对象还在；
2. 调用过`invalidate()`方法的Session对象如果再执行`setAttribute`或者`getAttribute`方法会抛出`IllegalStateException`；
3. 调用`invalidate()` 方法会将该Session绑定的对象全部解绑，因此如果调用`request.getSession(false)`方法，返回值会是null——即此时request没有绑定任何Session;
4. 如果调用`invalidate()` 方法后执行`request.getSession()`或者`request.getSession(true)`,那么此时会创建一个新的Session给该Request对象绑定；需要特殊说明的是，`getSession()`无参和参数为true的效果是一样的，并且此时如果你再次执行`request.getSession(false)`方法，返回的就不是null了，而是上面新创建的Session对象。

 










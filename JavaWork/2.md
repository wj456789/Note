# Maven

## 生命周期

> 创建项目、编写代码、清理已编译的代码、编译代码、执行单元测试、打包、集成测试、验证、部署、生成站点等，这些环节组成了项目的生命周期，这些过程也叫做项目的构建过程。

maven中定义的3套**生命周期**：

- clean生命周期
- default生命周期
- site生命周期

上面这3套生命周期是相互独立的，没有依赖关系的，而每套生命周期中有多个**阶段**，每套中的多个阶段是有先后顺序的，并且后面的阶段依赖于前面的阶段；当执行某个阶段时，这个阶段前面的阶段也会执行；同时每个阶段中需要执行什么，可以通过插件的方式让用户自己去配置。而用户可以直接使用`mvn 阶段1 [阶段2] [阶段3] ...`命令来调用这些阶段去完成项目生命周期中具体的操作。

### clean生命周期

clean生命周期的目的是清理项目，它包含三个阶段：

| **生命周期阶段** | **描述**                              |
| ---------------- | ------------------------------------- |
| pre-clean        | 执行一些需要在clean之前完成的工作     |
| clean            | 移除所有上一次构建生成的文件          |
| post-clean       | 执行一些需要在clean之后立刻完成的工作 |

比如用户可以通过mvn pre-clean来调用clean生命周期中的pre-clean阶段需要执行的操作。

调用mvn post-clean会执行上面3个阶段所有的操作

### default生命周期

这个是maven主要的生命周期，主要被用于构建应用，包含了23个阶段。

| **生命周期阶段**        | **描述**                                                     |
| ----------------------- | ------------------------------------------------------------ |
| validate                | 校验：校验项目是否正确并且所有必要的信息可以完成项目的构建过程。 |
| initialize              | 初始化：初始化构建状态，比如设置属性值。                     |
| generate-sources        | 生成源代码：生成包含在编译阶段中的任何源代码。               |
| process-sources         | 处理源代码：处理源代码，比如说，过滤任意值。                 |
| generate-resources      | 生成资源文件：生成将会包含在项目包中的资源文件。             |
| process-resources       | 编译：复制和处理资源到目标目录，为打包阶段最好准备。         |
| compile                 | 处理类文件：编译项目的源代码。                               |
| process-classes         | 处理类文件：处理编译生成的文件，比如说对Java class文件做字节码改善优化。 |
| generate-test-sources   | 生成测试源代码：生成包含在编译阶段中的任何测试源代码。       |
| process-test-sources    | 处理测试源代码：处理测试源代码，比如说，过滤任意值。         |
| generate-test-resources | 生成测试源文件：为测试创建资源文件。                         |
| process-test-resources  | 处理测试源文件：复制和处理测试资源到目标目录。               |
| test-compile            | 编译测试源码：编译测试源代码到测试目标目录.                  |
| process-test-classes    | 处理测试类文件：处理测试源码编译生成的文件。                 |
| test                    | 测试：使用合适的单元测试框架运行测试（Juint是其中之一）。    |
| prepare-package         | 准备打包：在实际打包之前，执行任何的必要的操作为打包做准备。 |
| package                 | 打包：将编译后的代码打包成可分发格式的文件，比如JAR、WAR或者EAR文件。 |
| pre-integration-test    | 集成测试前：在执行集成测试前进行必要的动作。比如说，搭建需要的环境。 |
| integration-test        | 集成测试：处理和部署项目到可以运行集成测试环境中。           |
| post-integration-test   | 集成测试后：在执行集成测试完成后进行必要的动作。比如说，清理集成测试环境。 |
| verify                  | 验证：运行任意的检查来验证项目包有效且达到质量标准。         |
| install                 | 安装：安装项目包到本地仓库，这样项目包可以用作其他本地项目的依赖。 |
| deploy                  | 部署：将最终的项目包复制到远程仓库中与其他开发者和项目共享。 |

### site生命周期

site生命周期的目的是建立和发布项目站点，Maven能够基于pom.xml所包含的信息，自动生成一个友好的站点，方便团队交流和发布项目信息。主要包含以下4个阶段：

| **阶段**    | **描述**                                                   |
| ----------- | ---------------------------------------------------------- |
| pre-site    | 执行一些需要在生成站点文档之前完成的工作                   |
| site        | 生成项目的站点文档                                         |
| post-site   | 执行一些需要在生成站点文档之后完成的工作，并且为部署做准备 |
| site-deploy | 将生成的站点文档部署到特定的服务器上                       |

 

## 插件

> **maven插件主要是为maven中生命周期中的阶段服务的**，maven中只是定义了3套生命周期，以及每套生命周期中有哪些阶段，具体每个阶段中执行什么操作，完全是交给插件去干的。 

- maven中的插件就相当于一些工具，比如编译代码的工具，运行测试用例的工具，打包代码的工具，将代码上传到本地仓库的工具，将代码部署到远程仓库的工具等等，这些都是maven中的插件。
  - 插件可以通过mvn命令的方式调用直接运行
  - 将插件和maven生命周期的阶段进行绑定，然后通过mvn 阶段的方式执行阶段的时候，会自动执行和这些阶段绑定的插件

### 插件目标

> 一个插件可能包含了多个功能，比如编译代码的插件，可以编译源代码、也可以编译测试代码；插件中的每个功能就叫做插件的目标（Plugin Goal），每个插件中可能包含一个或者多个插件目标（Plugin Goal）。 

```sh
#列出插件所有目标
mvn 插件groupId:插件artifactId[:插件version]:help
mvn 插件前缀:help
```

maven只是定义了生命周期中的阶段，而没有定义每个阶段中具体的实现，这些实现是由插件的目标来完成的。所以需要**将阶段和插件目标进行绑定，来让插件目标帮助生命周期的阶段做具体的工作**，生命周期中的每个阶段支持绑定多个插件的多个目标。 

#### maven内置插件以及绑定

> 我们不用做任何配置就可以执行清理代码、编译代码、测试、打包、安装到本地仓库、上传到远程仓库等阶段的操作，是因为maven内部已经默认给这些阶段绑定好了插件目标，所以不需要我们再去配置，就直接可以运行

##### clean生命周期阶段与插件绑定关系

| 生命周期阶段 | 插件:目标                |
| ------------ | ------------------------ |
| pre-clean    |                          |
| clean        | maven-clean-plugin:clean |
| post-clean   |                          |

##### default生命周期阶段与插件绑定关系

default生命周期中有23个阶段，我只列出有默认绑定的，其他的没有列出的没有绑定任何插件，因此没有任何实际的行为。

| 生命周期阶段           | 插件:目标                            | 执行任务                       |
| ---------------------- | ------------------------------------ | ------------------------------ |
| process-resources      | maven-resources-plugin:resources     | 复制主资源文件至主输出目录     |
| compile                | maven-compiler-plugin:compile        | 编译主代码至主输出目录         |
| process-test-resources | maven-resources-plugin:testResources | 复制测试资源文件至测试输出目录 |
| test-compile           | maven-compiler-plugin:testCompile    | 编译测试代码至测试输出目录     |
| test                   | maven-surefile-plugin:test           | 执行测试用例                   |
| package                | maven-jar-plugin:jar                 | 创建项目jar包                  |
| install                | maven-install-plugin:install         | 将输出构件安装到本地仓库       |
| deploy                 | maven-deploy-plugin:deploy           | 将输出的构件部署到远程仓库     |

##### site生命周期阶段与插件绑定关系

| 生命周期阶段 | 插件:目标                |
| ------------ | ------------------------ |
| pre-site     |                          |
| site         | maven-site-plugin:site   |
| post-site    |                          |
| site-deploy  | maven-site-plugin:deploy |

#### 自定义绑定

除了默认绑定的一些操作，我们自己也可以将一些阶段绑定到指定的插件目标上来完成一些操作，这种自定义绑定让maven项目在构件的过程中可以执行更多更丰富的操作。

常见的一个案例是：创建项目的源码jar包，将其安装到仓库中，内置插件绑定关系中没有涉及到这一步的任务，所以需要用户自己配置。插件`maven-source-plugin`的`jar-no-fork`可以帮助我们完成该任务，我们将这个目标绑定在default生命周期的verify阶段上面，这个阶段没有任何默认绑定，verify是在测试完成之后并将构件安装到本地仓库之前执行的阶段，在这个阶段我们生成源码

### maven-compiler-plugin

> 编译Java源码，一般只需设置编译的jdk版本 

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.6.0</version>
    <configuration>
        <source>1.8</source>
        <target>1.8</target>
    </configuration>
</plugin>
<!-- 也可以在在properties设置jdk版本 -->
<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
 </properties
```

### maven-jar-plugin

> 打成jar时，设定manifest的参数，比如指定运行的Main class，还有依赖的jar包，加入classpath中 

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-jar-plugin</artifactId>
    <version>2.4</version>
    <configuration>
        <archive>
            <manifest>
                <addClasspath>true</addClasspath>
                <classpathPrefix>/data/lib</classpathPrefix>
                <mainClass>com.zhang.spring.App</mainClass>
            </manifest>
        </archive>
    </configuration>
</plugin>
```

### tomcat7-maven-plugin

> 用于远程部署Java Web项目 

```xml
<plugin>
    <groupId>org.apache.tomcat.maven</groupId>
    <artifactId>tomcat7-maven-plugin</artifactId>
    <version>2.2</version>
    <configuration>
        <url>http://59.110.162.178:8080/manager/text</url>
        <username>linjinbin</username>
        <password>linjinbin</password>
    </configuration>
</plugin>
```

### maven-shade-plugin

> 用于把多个jar包，打成1个jar包 一般Java项目都会依赖其他第三方jar包，最终打包时，希望把其他jar包包含在一个jar包里。 

### maven-assembly-plugin

#### 内置

要使用maven-assembly-plugin，需要指定至少一个要使用的assembly descriptor 文件。默认情况下，maven-assembly-plugin内置了几个可以用的assembly descriptor：

- bin ： 类似于默认打包，会将bin目录下的文件打到包中；
- jar-with-dependencies ： 会将所有依赖都解压打包到生成物中；
- src ：只将源码目录下的文件打包；
- project ： 将整个project资源打包。

如：使用 descriptorRefs来引用(官方提供的定制化打包方式)【不建议使用】 

##### 在pom中引入插件

```xml
<!-- pom引入 -->
<plugin>  
    <artifactId>maven-assembly-plugin</artifactId>  
    <configuration>  
        <descriptorRefs>  
            <descriptorRef>jar-with-dependencies</descriptorRef>  
        </descriptorRefs>  
    </configuration>  
</plugin>
```

##### 默认assembly配置文件

> 上述直接配置jar-with-dependencies打包方式。不需要引入额外文件。实际上，上述4中预定义的assembly descriptor有对应的xml。要查看它们的详细定义，可以到maven-assembly-plugin.jar里去看，例如对应 bin 的assembly descriptor 原始文件如下：

```xml
<assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0 http://maven.apache.org/xsd/assembly-1.1.0.xsd">
    <id>bin</id>
    <formats>
        <format>tar.gz</format>
        <format>tar.bz2</format>
        <format>zip</format>
    </formats>
    <fileSets>
        <fileSet>
            <directory>${project.basedir}</directory>
            <outputDirectory>/</outputDirectory>
            <includes>
                <include>README*</include>
                <include>LICENSE*</include>
                <include>NOTICE*</include>
            </includes>
        </fileSet>
        <fileSet>
            <directory>${project.build.directory}</directory>
            <outputDirectory>/</outputDirectory>
            <includes>
                <include>*.jar</include>
            </includes>
        </fileSet>
        <fileSet>
            <directory>${project.build.directory}/site</directory>
            <outputDirectory>docs</outputDirectory>
        </fileSet>
    </fileSets>
</assembly>
```

#### 自定义

##### 在pom中引入插件

```xml
<projects>
    <build>
        <plugins>
            <plugin>       
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-assembly-plugin</artifactId>
                <!-- 子pom也会执行execution -->
                <inherited>true</inherited> 
                <executions>
                    <execution><!-- 配置执行器 -->
                        <id>make-assembly</id>
                        <phase>package</phase><!-- 绑定到package生命周期阶段上 -->
                        <goals>
                            <goal>single</goal><!-- 插件目标为single，只运行一次 -->   
                        </goals>
                        <!-- configuration标签可以和executions同级 -->
                        <configuration>  
                            <finalName>demo</finalName> 
                            <archive>
                                <manifest>
                                    <addClasspath>true</addClasspath>
                                    <!-- 主类名 -->
                                    <mainClass>com.***.startup.BootStrap</mainClass> 
                                </manifest>
                            </archive>
                            <!-- 最后默认在目录output下会生成一个demo-demo.jar 文件，其中前一个demo来自标签finalName，后一个demo来自assembly.xml中的id,设置false就不会跟上AssemblyId -->
                            <appendAssemblyId>false</appendAssemblyId>  
                            <descriptors>
                                <!--配置描述文件路径(相对于pom的路径)--> 
                                <descriptor>src/assembly/assembly.xml</descriptor>  
                            </descriptors>  
                            <!-- outputDirectory定义了压缩包最终的位置，${basedir}为pom所在的位置 -->
                            <outputDirectory>output</outputDirectory>
                        </configuration> 
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</projects>

<!-- 多重的复杂情况存在的时候，也可以考虑使用profile的方式，这样可以有条件判断 -->
<profile>
    <id>example</id>
    <activation>
        <file>
            <!-- 先判断有没有descriptor文件然后再跑，这里也可以添加其他条件 -->
            <exists>src/package.xml</exists>
        </file>
    </activation>
    <build>
        <plugins>
            ...
        </plugins>
    </build>
</profile>
```

##### 指定assembly配置文件

使用 `descriptors`，指定打包文件 `src/assembly/assembly.xml`，即在配置文件内指定打包操作要使用这个自定义assembly descriptor(自定义的xml中配置)，需要如下配置，即要引入描述文件：

```xml
<!-- src/assembly/assembly.xml: -->
<?xml version='1.0' encoding='UTF-8'?>
<assembly xmlns="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/plugins/maven-assembly-plugin/assembly/1.1.0  
                    http://maven.apache.org/xsd/assembly-1.1.0.xsd">
    <id>demo</id>
    
    <formats>
        <format>jar</format>
    </formats>
    
    <includeBaseDirectory>false</includeBaseDirectory>
    
    <fileSets>
        <fileSet>
            <directory>${project.build.directory}/classes</directory>
            <outputDirectory>/</outputDirectory>
        </fileSet>
    </fileSets>
</assembly>
```

- format：指定打包类型；支持的打包格式有zip、tar、tar.gz (or tgz)、tar.bz2 (or tbz2)、jar、dir、war，可以同时指定多个打包格式 

- includeBaseDirectory：指定是否包含打包层目录（比如finalName是output，当值为true，所有文件被放在output目录下，否则直接放在包的根目录下）；

- fileSets：指定要包含的文件集，可以定义多个fileSet；

  管理一组文件的存放位置，核心元素如下表所示。

  | 元素            | 类型           | 作用                                                         |
  | --------------- | -------------- | ------------------------------------------------------------ |
  | outputDirectory | String         | 指定文件集合的输出目录，该目录是相对于根目录                 |
  | includes        | `List<String>` | 包含文件                                                     |
  | excludes        | `List<String>` | 排除文件                                                     |
  | fileMode        | String         | 指定文件属性，使用八进制表达，分别为(User)(Group)(Other)所属属性，默认为 0644 |

  

- dependencySets

  用来定制工程依赖 jar 包的打包方式，核心元素如下表所示。

  | 元素            | 类型           | 作用                                 |
  | --------------- | -------------- | ------------------------------------ |
  | outputDirectory | String         | 指定包依赖目录，该目录是相对于根目录 |
  | includes        | `List<String>` | 包含依赖                             |
  | excludes        | `List<String>` | 排除依赖                             |

  ```xml
  <dependencySets>
      <dependencySet>
          <outputDirectory>/lib</outputDirectory>
          <excludes>
              <exclude>${project.groupId}:${project.artifactId}</exclude>
          </excludes>
      </dependencySet>
      <dependencySet>
          <outputDirectory>/</outputDirectory>
          <includes>
              <include>${project.groupId}:${project.artifactId}</include>
          </includes>
          <!-- 将scope为runtime的依赖包打包到lib目录下。 -->
          <scope>runtime</scope>
      </dependencySet>
  </dependencySets>
  ```

参考：

[maven--插件篇（assembly插件）](https://www.cnblogs.com/sidesky/p/10651266.html)





[Maven 插件之 docker-maven-plugin 的使用](https://www.cnblogs.com/jpfss/p/10945324.html)

```sh
在命令行下,到pom.xml所在目录下,执行 mvn assembly:assembly -Dmaven.test.skip=true
mvn assembly:assembly -Dmaven.test.skip=true
```



[maven](https://blog.csdn.net/sxyandapp/category_5839321.html?spm=1001.2014.3001.5482)

[idea执行maven命令的三种方式](https://www.cnblogs.com/aaabbbcccddd/p/15049355.html)

## profile

> 每个profile对应不同的激活条件和配置信息 ，多个profile可以实现不同环境使用不同配置信息。

### 定义位置

对于使用Maven3，我们可以有多个地方定义profile。定义的地方不同，它的作用范围也不同。

- 针对于特定项目的profile配置我们可以定义在该项目的pom.xml中。
- 针对于特定用户的profile配置，我们可以在用户的settings.xml文件中定义profile。该文件在用户家目录下的`.m2`目录下。
- 全局的profile配置。全局的profile是定义在Maven安装目录下的`conf/settings.xml`文件中的。

### 定义信息

#### 定义在settings.xml中

当profile定义在settings.xml中时意味着该profile是全局的，它会对所有项目或者某一用户的所有项目都产生作用 。能够定义在settings.xml中的信息有`<repositories>`、`<pluginRepositories>`和`<properties>`。定义在`<properties>`里面的键值对可以在pom.xml中使用。 

#### 定义在pom.xml中

定义在pom.xml中的profile可以定义更多的信息。主要有以下这些：

`<repositories>`

`<pluginRepositories>`

`<dependencies>`

`<plugins>`

`<properties>`

`<dependencyManagement>`

`<distributionManagement>`

还有build元素下面的子元素，主要包括：

`<defaultGoal>`

`<resources>`

`<testResources>`

`<finalName>`

### 激活方式

```sh
#查看处于激活状态的profile
$ mvn help:active-profiles
```



#### -P命令参数

```sh
#激活profileTest
$ mvn package –P profileTest
```

```sh
#当我们使用activeByDefault或settings.xml中定义了处于激活的profile，但是当我们在进行某些操作的时候又不想它处于激活状态，这个时候我们可以这样做： 
$ mvn package –P !profileTest1  
#假设profileTest1是在settings.xml中使用activeProfile标记的处于激活状态的profile，那么当我们使用“-P !profile”的时候就表示在当前操作中该profile将不处于激活状态。 
```

#### activeByDefault

> 当没有指定条件，然后指定activeByDefault为true的时候就表示当没有指定其他profile为激活状态时，该profile就默认会被激活。 

```xml
<profiles>  
    <profile>  
        <id>profileTest1</id>  
        <properties>  
            <hello>world</hello>  
        </properties>  
        <activation>  
            <activeByDefault>true</activeByDefault>  
        </activation>  
    </profile>  

    <profile>  
        <id>profileTest2</id>  
        <properties>  
            <hello>andy</hello>  
        </properties>  
    </profile>  
</profiles> 
```

#### activeProfiles

> 可以在settings.xml中使用activeProfiles来指定需要激活的profile，这种方式激活的profile将所有情况下都处于激活状态。 

```xml
<profiles>  
    <profile>  
        <id>profileTest1</id>  
        <properties>  
            <hello>world</hello>  
        </properties>  
    </profile>  

    <profile>  
        <id>profileTest2</id>  
        <properties>  
            <hello>andy</hello>  
        </properties>  
    </profile>  
</profiles>

<activeProfiles>  
     <activeProfile>profileTest1</activeProfile>  
</activeProfiles>  
```

```xml
<!-- 在activeProfiles下同时定义了多个需要激活的profile -->
<activeProfiles>  
    <activeProfile>profileTest1</activeProfile>  
    <activeProfile>profileTest2</activeProfile>  
</activeProfiles>  
<!-- 不是根据activeProfile定义的顺序，后面的覆盖前面的。而是根据profile定义的先后顺序来进行覆盖取值的，然后后面定义的会覆盖前面定义的 -->
```

#### 其他

##### 根据环境

```xml
<!-- 在jdk为1.5版本系列的时候激活profileTest1 -->
<profiles>  
    <profile>  
        <id>profileTest1</id>  
        <jdk>1.5</jdk>  
    </profile>  
<profiles>  

<!-- 在jdk为1.4、1.5和1.6的时候激活profileTest1 -->
<profiles>  
    <profile>  
        <id>profileTest1</id>  
        <jdk>[1.4,1.7)</jdk>  
    </profile>  
<profiles>  
```

##### 根据操作系统

```xml
<profiles>  
    <profile>  
        <id>profileTest1</id>  
        <activation>  
            <os>  
                <name>Windows XP</name>  
                <family>Windows</family>  
                <arch>x86</arch>  
                <version>5.1.2600</version>  
            </os>  
        </activation>  
    </profile>  
</profiles>  
```

##### 根据系统属性

```xml
<!-- 将在提供了系统属性hello，并且其值为world的时候激活,或者直接使用命令激活"mvn package –Dhello=world" -->
<profiles>  
    <profile>  
        <id>profileTest1</id>  
        <activation>  
            <property>  
                <name>hello</name>  
                <value>world</value>  
            </property>  
        </activation>  
    </profile>  
</profiles> 


<!-- 在指定了系统属性hello，且其值为任意值的时候被激活 -->
<profiles>  
    <profile>  
        <id>profileTest1</id>  
        <activation>  
            <property>  
                <name>hello</name>  
            </property>  
        </activation>  
    </profile>  
</profiles>  
```

##### 根据文件是否存在

```xml
<!-- 当存在target文件时激活profileTest1 -->
<profiles>  
    <profile>  
        <id>profileTest1</id>  
        <activation>  
            <file>  
                <exists>target</exists>  
            </file>  
        </activation>  
    </profile>  
</profiles>  
```



[Maven简介（三）——profile介绍](https://www.iteye.com/blog/elim-1900568)

























## try-with-resource

- 传统的`try-finally`方式存在复杂易出错和异常抑制(Suppressed)等问题。 使用`try-with-resource`，可以更安全、简洁地申请和关闭资源，同时解决了异常抑制问题。 
- `try-with-resource`是语法糖，其最终仍然会被编译成`try-finally`方式并调用close方法关闭资源。 
- 为了支持`try-with-resource`，资源类必须要实现`AutoClosable接口`，否则无法使用。在使用`try-with-resource`之前，请务必确认下资源类是否已经实现了`AutoClosable接口`。
- `try-with-resource`使用方式
  - `try-with-resource`使用很简单，申请资源的代码写在try后面的()中即可，无需显式调用`close方法`来关闭资源。 
  - 为了使程序更加健壮，在`try-with-resouce`中使用装饰器时，建议显式声明被装饰/包裹对象的引用。 

### 使用

能够借助`try-with-resource`关闭资源的类必须实现`AutoClosable接口`，重写`close方法`。如果是自定义资源类， 为了支持`try-with-resource`，请务必实现`AutoClosable接口`。 

```java
//申请资源的代码写在try后面的()中即可，资源关闭无需显式close
public void twrClose2NotCatch(String src, String dst) throws IOException {
    try (FileInputStream ins = new FileInputStream(src);
         OutputStream outs = new FileOutputStream(dst)) {
        byte[] buf = new byte[BUF_SIZE];
        int n;
        while ((n = ins.read(buf)) >= 0) {
            outs.write(buf, 0, n);
        }
    }
}
```

`try-with-resource`主要做了两件事：

- 添加调用close方法的代码，关闭资源。
- 使用addSuppressed方法附加异常，消除异常抑制的问题。

#### try-finally举例

##### 异常抑制

异常抑制（Suppressed）也有叫异常覆盖和异常屏蔽

```java
public class ConnectionNormal {
    public void send() throws Exception {
        throw new SendException("send fail.");
    }

    public void close() throws Exception {
        throw new CloseException("close fail");
    }
}

//按照程序逻辑，应该先抛出SendException，再抛出CloseException：
public static void main(String[] args) {
    try {
        test();
    } catch (Exception e) {
        e.printStackTrace();
    }
}


private static void test() throws Exception {
    ConnectionNormal conn = null;
    try {
        conn = new ConnectionNormal();
        conn.send();
    } finally {
        if (conn != null) {
            conn.close();
        }
    }
}

//运行后我们发现：
com.CloseException: close fail
at com.ConnectionNormal.close(ConnectionNormal.java:10)
    at com.TryWithResource.test(TryWithResource.java:20)
    at com.TryWithResource.main(TryWithResource.java:6)
```

SendException明明先被抛出了，但是没有丝毫痕迹，被后抛的CloseException给抑制了，这就是异常抑制，SendException被称为Suppressed Exception。关键的异常信息丢失，这会导致某些bug变得极其隐蔽而难以发现！

#### try-with-resource举例

`try-with-resource`为`Throwable类`新增了`addSuppressed方法`，支持将一个异常附加到另一个之上，从而解决异常抑制。

```java
public class ConnectionAutoClose implements AutoCloseable{
    public void send() throws Exception {
        throw new SendException("send fail.");
    }
    @Override
    public void close() throws Exception {
        throw new CloseException("close fail");
    }
}

private static void test2() {
    try (ConnectionAutoClose conn = new ConnectionAutoClose()) {
        conn.send();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

运行结果：
com.SendException: send fail.
    at com.ConnectionAutoClose.send(ConnectionAutoClose.java:5)
    at com.TryWithResource.test2(TryWithResource.java:27)
    at com.TryWithResource.main(TryWithResource.java:6)
    Suppressed: com.CloseException: close fail
at com.ConnectionAutoClose.close(ConnectionAutoClose.java:10)
        at com.TryWithResource.test2(TryWithResource.java:28)
        ... 1 more
```

### 原理

```java
//try-with-resource反编译.class
private static void test2() {
    try {
        ConnectionAutoClose conn = new ConnectionAutoClose();
        Throwable var1 = null;
        try {
            conn.send();
        } catch (Throwable var11) {
            var1 = var11;
            throw var11;
        } finally {
            if (conn != null) {
                if (var1 != null) {
                    try {
                        conn.close();
                    } catch (Throwable var10) {
                        var1.addSuppressed(var10);
                    }
                } else {
                    conn.close();
                }
            }
        }
    } catch (Exception var13) {
        var13.printStackTrace();
    }
}
```

### 显式声明

为了使程序更加健壮，在try-with-resouce中使用装饰器时，建议显式声明被装饰 / 包裹对象的引用。

```java
//在finally中仅调用了out.close()，在GZIPOutputStream.close内部，会关闭被包裹的FileOutputStream，但是这个关闭可能会失败
public void gzipWrapper(File file) throws IOException {
   try (GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(file))) {
      ...
  }
}
```

```java
//fout.close一定会被调用
public void gzipWrapperRobust(File file) throws IOException {
   try (FileOutputStream fout = new FileOutputStream(file); // 显式声明
        GZIPOutputStream out = new GZIPOutputStream(fout)) {
      ...
  }
}
```



# 正则表达式

```java
//IPv4的地址格式，总长度 32位=4段*8位，每段之间用.分割， 每段都是0-255之间的十进制数值
System.out.println("10.45.168.74".matches("^((25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d)))\\.){3}(25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d)))$"));
//端口号0-65535
System.out.println("8080".matches("^([0-9]|[1-9]\\d|[1-9]\\d{2}|[1-9]\\d{3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5])$"));
```



## Java基础

### 类型强转

```java
Object obj;
List<Integer> list = castList(obj,Integer.class);
//list强转
private static <T> List<T> castList(Object obj, Class<T> clazz) {
    List<T> result = new ArrayList<T>();
    if (obj instanceof List<?>) {
        for (Object o : (List<?>) obj) {
            result.add(clazz.cast(o));
        }
        return result;
    }
    return null;
}
```

```java
Object obj;
Map<String,Object> map = castHashMap(obj,String.class,Object.class);

/**
 * 防止出现强转警告
 *
 * @param obj 强转对象
 * @param clazz1 HashMap的key
 * @param clazz2 HashMap的value
 * @param <K> Key泛型
 * @param <V> Value泛型
 * @return 强转后对象
 */
private <K, V> HashMap<K, V> castHashMap(Object obj, Class<K> clazz1, Class<V> clazz2) {
    HashMap<K, V> result = new HashMap<K, V>();
    if (obj instanceof HashMap<?, ?>) {
        for (Object o : ((HashMap<?, ?>) obj).keySet()) {
            result.put(clazz1.cast(o), clazz2.cast(((HashMap<?, ?>) obj).get(o)));
        }
        return result;
    }
    return null;
}
```


# 算法和数据结构

## 数据结构

> 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。
>
> 通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。

数据结构包括数据的逻辑结构、数据的存储结构以及数据的运算；

- 逻辑结构有：集合结构、线性结构、树形结构和图状结构。
- 物理结构有：线性存储结构和非线性存储结构，线性存储结构(线性表)有顺序(顺序表)、链式(链表)、索引和散列4种结构；非线性存储结构有树形存储结构、图形存储结构。
  - 顺序使用连续地址空间存储元素
  - 链式中指针指向下一个元素地址
  - 索引使用索引表存放元素地址
  - 散列通过散列算法计算地址

线性表有栈，队列，实现方式可以是顺序表也可以是链表；顺序表有数组；非线性存储结构有树、堆、图。

集合中ArrayList是顺序表，LinkedList是链表；

### 数组

- 数组是静态的，一个数组实例具有固定的大小，一旦创建了就无法改变容量了。而集合是可以动态扩展容量，可以根据需要动态改变大小。

- 数组的存放的类型中`Object[]`可以存放多种类型，其他只能是一种（基本类型/引用类型）；集合存放的类型可以不是一种(不加泛型时添加的类型是Object，取出时转换成自己的类型就行了)，但是添加泛型时只能是一种。

#### 稀疏数组

> 所谓稀疏数组就是数组中大部分的内容值都未被使用（或都为零），在数组中仅有少部分的空间使用。因此造成内存空间的浪费，为了节省内存空间，并且不影响数组中原有的内容值，我们可以采用一种压缩的方式来表示稀疏数组的内容。

假设有一个9*7的数组，其内容如下：

![clipboard (5)](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard%20(5).png)

在此数组中，共有63个空间，但却只使用了5个元素，造成58个元素空间的浪费。

以下我们就使用稀疏数组重新来定义这个数组：

![clipboard (6)](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard%20(6).png)

在稀疏数组中第一部分所记录的是原数组的列数和行数以及元素使用的个数；

第二部分所记录的是原数组中元素的位置和内容；

经过压缩之后，原来需要声明大小为63的数组，而使用压缩后，只需要声明大小为6*3的数组，仅需18个存储空间。

```java
public class TestArray {
    public static void main(String[] args) {
        /*
        Integer[][] arr=new Integer[9][7];
        arr[1][1]=3;
        ...
        */

        Node[] nodes=new Node[6];
        nodes[0]=new Node(9,7,5);
        nodes[1]=new Node(1,1,3);
        nodes[2]=new Node(3,0,1);
        nodes[3]=new Node(3,1,4);
        nodes[4]=new Node(4,2,7);
        nodes[5]=new Node(5,5,5);

        for(int i=0;i<nodes[0].getRow();i++){
            for(int j=0;j<nodes[0].getCol();j++){
                int k;
                for(k=1;k<nodes.length;k++){
                    if(nodes[k].getRow()==i&&nodes[k].getCol()==j){
                        System.out.print(nodes[k].getVal()+"   ");
                        break;
                    }
                }
                if(k==nodes.length){
                    System.out.print("0   ");
                }
            }
            System.out.println("");
        }
    }
}

@Data
@AllArgsConstructor
class Node{
    private int row;
    private int col;
    private int val;
}

输出：
0   0   0   0   0   0   0   
0   3   0   0   0   0   0   
0   0   0   0   0   0   0   
1   4   0   0   0   0   0   
0   0   7   0   0   0   0   
0   0   0   0   0   5   0   
0   0   0   0   0   0   0   
0   0   0   0   0   0   0   
0   0   0   0   0   0   0
```



### 集合

#### ArrayList

<img src="img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211114160523563.png" alt="image-20211114160523563" style="zoom:80%;" />

```java
//将arr1数组里从索引为2的元素开始, 复制到数组arr2里的索引为5的位置, 复制的元素个数为10个.
System.arrayCopy( arr1, 2, arr2, 5, 10);

//扩容1.5倍
newSize=arr.length+(arr.length>>1);
arr=Arrays.copyOf(arr,newSize);
```

```java
class MyArrayList{
    private Object[] arr;
    private int nElems;//数组的真实长度

    //初始化
    public MyArrayList(){
        //其中ArrayList初始容量也是10
        arr=new Object[10];
        nElems=0;
    }

    //遍历
    
    //查找
    
    //添加
    public void add(Object o){
        if(nElems==arr.length){
            arr=Arrays.copyOf(arr,arr.length+(arr.length>>1));
        }
        arr[nElems++]=o;
    }

    //删除
    public void delete(Object o){
        int i=0;
        //找出该元素在数组中的下标i
        //if(找到了)
        System.arraycopy(arr,i+1,arr,i,nElems-1-i);
        arr[nElems--]=0;
    }
}
```

#### 栈

<img src="img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211114160624460.png" alt="image-20211114160624460" style="zoom:80%;" />

> **栈**（英语：stack）又称为**堆栈**或**堆叠，**栈作为一种数据结构，是一种**只能在一端进行插入和删除操作的特殊线性表**。先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。
>
> 允许进行插入和删除操作的一端称为栈顶(top)，另一端为栈底(bottom)；栈中元素个数为零时称为空栈。插入一般称为进栈（PUSH），删除则称为退栈（POP）。

**数组实现栈：**

```java
public class TestStack {
    public static void main(String[] args) {
        MyStack myStack=new MyStack();
        myStack.push(1);
        myStack.push(2);
        myStack.push(3);
        myStack.push(4);
        myStack.push(5);
        myStack.push(6);
        myStack.push(7);
        myStack.push(8);
        myStack.push(9);
        myStack.push(10);
        myStack.push(11);

        while(!myStack.isEmpty()){
            System.out.println(myStack.pop());
        }
    }
}

class MyStack{
    private Object[] data;  //栈内部封装的数组，用来保存压入栈的数据元素
    private int maxSize;    //栈的最大长度
    private int top;        //变量始终指向栈顶第一个元素，栈是空栈，默认值是-1

    //初始化栈
    public MyStack(){
        data=new Object[10];
        this.maxSize=10;
        top=-1;
    }

    //压栈
    public void push(Object o){
        if(top==maxSize-1){
            if((maxSize<<1)>Integer.MAX_VALUE){
                maxSize=Integer.MAX_VALUE;
            }else {
                maxSize=maxSize<<1;
            }
            //扩容
            data= Arrays.copyOf(data,maxSize);
        }
        data[++top]=o;
    }

    //获取栈顶元素值
    public Object peek(){
        if(top==-1){
            throw new EmptyStackException();
        }
        return data[top];
    }

    //实现出栈
    public Object pop(){
        Object obj=peek();
        data[top--]=null;
        return obj;
    }

    //判断是不是空栈
    public boolean isEmpty(){
        return (top==-1);
    }

    //判断是不是满栈
    public boolean isFull(){
        return (top==maxSize-1);
    }
}
```

> **利用栈判断分隔符是否匹配**
>
> 写过xml标签或者html标签的，**我们都知道<必须和最近的>进行匹配**，**[ 也必须和最近的 ] 进行匹配。**
>
> 比如：<abc[123]abc>这是符号相匹配的，如果是 <abc[123>abc] 那就是不匹配的。
>
> 对于 12<a[b{c}]>，我们分析在栈中的数据：遇到匹配正确的就消除

```java
public static void main(String[] args) {
    String str="12<a[b{c}]>";
    char[] chars = str.toCharArray();
    Stack<Character> stack=new Stack<>();

    char ch;
    boolean flag=true;
    for(char c:chars){
        if(c=='<'||c=='['||c=='{'){
            stack.push(c);
        }
        if(c=='>'||c==']'||c=='}'){
            if(!stack.isEmpty()){
                char pop = stack.pop();
                if(!(c=='>'&&pop=='<'||c==']'&&pop=='['||c=='}'&&pop=='{')){
                    System.out.println("左符号"+pop+"和右符号"+c+"不匹配");
                    flag=false;
                }
            }else {
                //左边符号多余
                System.out.println("左符号"+c+"无匹配");
                flag=false;
                break;
            }
        }
    }

    //右边符号多余
    if(flag&&!stack.isEmpty()){
        flag=false;
        while(!stack.isEmpty()){
            System.out.println("右符号"+stack.pop()+"无匹配");
        }
    }

    if(flag){
        System.out.println("匹配成功");
    }
}
```

#### 队列

> 队列（queue）是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。
>

> 队列分为：
>
> - 单向队列（Queue）：只能在一端插入数据，另一端删除数据。
>
> - 双向队列（Deque）：每一端都可以进行插入数据和删除数据操作。
>
> - 优先级队列（Priority Queue），优先级队列是比栈和队列更专用的数据结构，在优先级队列中，数据项按照关键字进行排序，关键字最小（或者最大）的数据项往往在队列的最前面，而数据项在插入的时候都会插入到合适的位置以确保队列的有序。

```java
//单向循环队列
public class TestQueue {
    public static void main(String[] args) {
        MyQueue myQueue=new MyQueue(3);
        myQueue.insert(1);
        myQueue.insert(2);
        myQueue.insert(3);

        System.out.println(myQueue.peekFront());
        myQueue.remove();
        System.out.println(myQueue.peekFront());

        myQueue.insert(4);
        myQueue.insert(5);
    }
}

class MyQueue{
    private Object[] queArray;
    //队列总大小
    private int maxSize;
    //前端
    private int front;
    //尾端
    private int rear;
    //队列中元素的实际数目
    private int nItems;

    public MyQueue(int size){
        maxSize=size;
        queArray=new Object[maxSize];
        //虽然初始状态不同，始终指向第一个和最后一个元素
        front=0;
        rear=-1;
        nItems=0;
    }

    public void insert(int value){
        if(isFull()){
            System.out.println("队列已满");
        }else {
            //队尾已满，循环回来指向队列的第一个元素
            if(rear==maxSize-1){
                rear=-1;
            }
            queArray[++rear]=value;
            nItems++;
        }
    }

    public Object remove(){
        Object removeValue=null;
        if(!isEmpty()){
            removeValue=queArray[front];
            queArray[front++]=null;
            if(front==maxSize){
                front=0;
            }
            nItems--;
        }
        return removeValue;
    }

    //查看队头数据
    public Object peekFront(){
        return queArray[front];
    }

    public boolean isFull(){
        return (nItems==maxSize);
    }

    public boolean isEmpty(){
        return (nItems==0);
    }

    public int getSize(){
        return nItems;
    }
}
```















## 算法

> 按照某种逻辑关系组织起来的一批数据，按一定的方式把它存放在计算机的内存里，在这个基础上为了实现某个功能（比如查找某个元素，删除某个元素，给所有元素排序等等）而进行的一些列操作，我们把这一些列的操作步骤描述出来就是算法。

**时间复杂度和空间复杂度是衡量算法优劣的重要指标：**

- 时间复杂度：是用程序执行的次数来衡量，不是程序执行的时间。

- 空间复杂度：用程序执行所需要的最大内存。

其中基本操作执行次数的函数 T(n)，若存在函数 f(n)，使得当n趋近于无穷大时，T(n)/ f(n)的极限值为不等于零的常数，则称 f(n)是T(n)的同数量级函数。

记作 T(n)= O(f(n))，称O(f(n)) 为算法的**渐进时间复杂度**，简称**时间复杂度**。渐进时间复杂度用大写O来表示，所以也被称为**大O表达式**。

**大O表达式                                     算法的好坏**

O(1) 												最好					大O常数阶

O(logn) 										  比较好				大O对数阶

O(n)                                                良好					大O线性阶

O(n^2)                                            不好					大O平方阶

O(n^3)                                            很不好				

O(2^n)                                            很很不好

O(n!)                                               最不好



**比如：**

> 给小灰一条长16寸的面包，小灰每5天吃掉面包剩余长度的一半，第一次吃掉8寸，第二次吃掉4寸，第三次吃掉2寸......那么小灰把面包吃得只剩下1寸，需要多少天呢？
>
> 这个问题翻译一下，就是数字16不断地除以2，除几次以后的结果等于1？这里要涉及到数学当中的对数，以2位底，16的对数，可以简写为lg16。
>
> 因此，把面包吃得只剩下1寸，需要 5 X lg16 = 5 X 4 = 20 天。
>
> 如果面包的长度是 N 寸呢？
>
> 需要 5 X lgN = 5lgN天，记作 T(n) = 5lgN

```java
void eat2(int n){
   for(int i=1; i<n; i*=2){     
       System.out.println("等待一天");
       System.out.println("等待一天");
       System.out.println("等待一天");
       System.out.println("等待一天");
       System.out.println("吃一半面包");
   }
}
```

程序的设计中要不就是时间换空间，要不就是用空间去换时间。并且时间和空间是可以进行相互转化的；我们在程序当中，请求分页，请求分段，都属于用时间去换空间。在项目当中使用各种缓存技术，都属于利用空间去换时间。

### 查找算法

> 有序数组的二分查找

```java
public int find(Integer[] array,int searchKey){
    int lowerBound=0;
    int upperBound=array.length-1;
    int curIn;

    while(true){
        curIn=(lowerBound+upperBound)/2;
        if(array[curIn]== searchKey){
            return curIn;
        }else if(lowerBound>upperBound){
            return array.length;
        }else{
            if(array[curIn]<searchKey){
                lowerBound=curIn+1;
            }else {
                upperBound=curIn-1;
            }
        }
    }
}
```



### 排序算法

#### 冒泡排序

```java
public static void main(String[] args) {
    Integer[] is=new Integer[]{2,3,1};
    bubSort(is);
    System.out.println(Arrays.asList(is));
}

public static void bubSort(Integer[] array){
    int outer;	//冒泡出来的元素放置的下标位置，从后向前 
    int inner;
    for(outer=array.length-1;outer>=1;outer--){
        for(inner=0;inner<outer;inner++){
            if(array[inner]>array[inner+1]){	//前面的元素比后面大，交换位置
                int temp=array[inner];
                array[inner]=array[inner+1];
                array[inner+1]=temp;
            }
        }
    }
}
```

#### 选择排序

```java
public static void selectSort(Integer[] array){
    int outer;	//选择出来的元素放置的下标位置，从前向后
    int inner;
    int min;

    for(outer=0;outer<array.length-1;outer++){
        min=outer;	//每次循环初始化min指向outer的位置，剩下的元素中的第一个
        for(inner=outer+1;inner<=array.length-1;inner++){
            if(array[inner]<array[min]){
                min=inner;
            }
        }//每次循环完成后，min指向的元素才是真正最小元素
        
        if(min!=outer){
            int temp=array[min];
            array[min]=array[outer];
            array[outer]=temp;
        }
    }
}
```



#### 插入排序

```java
public static void insertSort(Integer[] array){
    int outer;	//指向需要插入的元素
    int inner;	//指向outer之前元素
    int temp;

    //数列中每一个数和它前面的数据比较，如果inner指向的数较大，数往后移位，inner向前遍历,直到inner指向的数较小，在这之后插入这个数
    for(outer=1;outer<=array.length-1;outer++){
        inner=outer-1;
        temp=array[outer];
        while(inner>=0&&array[inner]>temp){	//从小到大
            array[inner+1]=array[inner];
            inner--;
        }
        array[inner+1]=temp;
    }
}
```



```java
public static void main(String[] args) {
    int[] array=new int[]{1,67,9,32,54,7,12};
    sort(array);
    for(int i:array){
        System.out.println(i);
    }
}

//数列中每一个数和它前面的数据比较，如果前面的数较大，往后移位，直到前面的数较小，在这之后插入这个数
public static void sort(int[] array){
    int preIndex;
    int current;
    for(int i=1;i<=array.length-1;i++){
        preIndex=i-1;
        current=array[i];
        while(preIndex>=0&&array[preIndex]>current){
            array[preIndex+1]=array[preIndex];
            preIndex--;
        }
        array[preIndex+1]=current;
    }
}
```

#### 希尔排序

也是一种插入排序

将数组按照增量分组，对每组使用直接插入排序算法排序，初始增量gap=length/2，然后缩小增量gap=gap/2，直到增量为1将整个数组分为一组

如100个数据，先分为100/2=50组，每组2个值，每组分别排序

​						  再分为50/2=25组，每组4个值

​						  再分为25/2=12组，每组9或8个值

​						  ...

​						  最后分为2/2=1组，100为一组整体排序

```java
public static void main(String[] args) {
    int[] array=new int[]{1,67,9,32,54,7,12};
    sort(array);
    for(int i:array){
        System.out.println(i);
    }
}

public static void sort(int[] array){
    int gap=array.length/2;
    while(gap>0){
        int preIndex;
        int current;
        for(int i=gap;i<=array.length-1;i++){
            preIndex=i-gap;
            current=array[i];
            while(preIndex>=0&&array[preIndex]>current){
                array[preIndex+gap]=array[preIndex];
                preIndex-=gap;
            }
            array[preIndex+gap]=current;
        }
        gap/=2;
    }
}
```



#### 快速排序

对于一个数列进行排序，比基准小的放在基准前，比基准大的放在基准后，然后再将小于基准的子序列和大于基准的子序列递归排序

```java
public static void main(String[] args) {
    int[] array=new int[]{1,67,9,32,54,7,12};
    quickSort(array, 0, array.length - 1);
    for(int i:array){
        System.out.println(i);
    }
}

public static void quickSort(int[] array,int start,int end){
    if(start>=end){
        return;
    }else{
        int patition = patition(array, start, end);
        if(patition>start){
            quickSort(array,start,patition-1);
        }
        if(patition<end){
            quickSort(array,patition+1,end);
        }
    }
}

//选开始值为基准，从前开始找到大于基准的坐标，从后开始找到小于基准的坐标，将两个值交换，然后在两个坐标之间继续循环，直到从后开始的坐标小于从前开始的坐标
public static int patition(int[] array,int start,int end){
    int i=start;
    int j=end+1;
    int pivot=array[start];		//pivot为基准值
    while(true){
        while(i<end&&array[++i]<pivot){}	//取大于基准的坐标
        while(j>start&&array[--j]>pivot){}	//取小于基准的坐标
        if(i>=j){
            break;
        }else{
            swap(array,i,j);
        }
    }
    swap(array,j,start);
    return j;
}

public static int[] swap(int[] array,int i,int j){
    int temp=array[i];
    array[i]=array[j];
    array[j]=temp;
    return array;
}
```


### 设计模式概述



**工厂模式**：根据条件创建不同的类
	简单工厂：将代码中涉及创建对象的部分剥离到一个独立的类中，生成静态方法即可；也可以事先创建存放map缓存；
	工厂方法：定义接口，接口中定义创建方法，再定义不同实现类；
	抽象工厂：不同的类中有多种分类方式，并且每种方式中类定义类似，可以根据分类方式定义多个接口，最后在统一接口中定义接口数量的创建方法



**建造者模式**：创建对象。把必填属性通过set()方法设置 而不是放在构造函数，将类的属性之间依赖关系或者约束条件 判断放在build，对象在创建好之后，就不能再修改内部的属性值，也就是创建不可变对象。

**原型模式**：利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象。可以使用clone、对象序列化


**代理模式**：
	静态代理：

```java
基于接口：		
public interface IA {
      void f();
}

public class A implements IA { // 原始类
  public void f() { //... }
}

public class AProxy implements IA { // 代理类
  private IA a;
  public AProxy(IA a) {
    this.a = a;
  }
  public void f() {
    // 新添加的代理逻辑
    a.f();
    // 新添加的代理逻辑
  }
}

基于继承：
public class A{ // 原始类
  public void f() { //... }
}
public class AProxy extend A { // 代理类
  public void f() {
    // 新添加的代理逻辑
    super.f();
    // 新添加的代理逻辑
  }
}
```

动态代理：反射

**桥接模式**：将抽象和实现解耦，让它们可以独立变化。也就是说定义两个抽象接口，同时都存在多个实现，使用组合关系将两个抽象的实现类进行桥接。

**装饰器模式**：不改变现有对象结构的情况下，动态地给该对象增加额外功能的模式。使用组合来替代继承，装饰器类和原始类继承同样的父类

```java
public interface IA {
  void f();
}

public class A implements IA { // 原始类
  public void f() { //... }
}

public class ADecorator implements IA { // 装饰器类
  private IA a;
  public ADecorator(IA a) {
    this.a = a;
  }

  public void f() {
	// 代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。
    // 功能增强代码
    a.f();
    // 功能增强代码
  }
}
```



**适配器模式**：将不兼容的接口转换为可兼容的接口。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。

```java
// 类适配器: 基于继承
public interface ITarget {
  void f1();
  void f2();
  void fc();
}

public class Adaptee {
  public void fa() { //... }
  public void fb() { //... }
  public void fc() { //... }
}

public class Adaptor extends Adaptee implements ITarget {
  public void f1() {
    super.fa();
  }

  public void f2() {
    //...重新实现f2()...
  }

  // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点
}

// 对象适配器：基于组合
public interface ITarget {
  void f1();
  void f2();
  void fc();
}

public class Adaptee {
  public void fa() { //... }
  public void fb() { //... }
  public void fc() { //... }
}

public class Adaptor implements ITarget {
  private Adaptee adaptee;
  public Adaptor(Adaptee adaptee) {
    this.adaptee = adaptee;
  }

  public void f1() {
    adaptee.fa(); //委托给Adaptee
  }

  public void f2() {
    //...重新实现f2()...
  }

  public void fc() {
    adaptee.fc();
  }
}
```



**门面模式**：为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。假设有一个系统A，提供了a、b、c、d四个接口。系统B完成某个业务功能，需要调用A系统的a、b、d接口。利用门面模式，我们提供一个包裹a、b、d接口调用的门面接口x，给系统B直接使用。

**组合模式**：将一组对象组织（Compose）成树形结构，以表示一种“部分-整体”的层次结构。定义接口和文件目录实现类，将文件和目录对象组织成树形结构，以表示目录与子目录的嵌套结构

**享元模式**：共享对象。前提是享元对象是不可变对象。

**观察者模式**：在对象之间有一个一对多的关系，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。多个对象注册，一个对象通知。

**模板模式**：在一个方法中定义一个业务逻辑骨架，并将某些步骤推迟到子类中实现。 模板方法定义为final，可以避免被子类重写。需要子类重写的方法定义为abstract，可以强迫子类去实现。 

回调：A类事先注册某个函数F到B类，A类在调用B类的P函数的时候，B类反过来调用A类注册给它的F函数。这里的F函数就是“回调函数”。A调用B，B反过来又调用A，这种调用机制就叫作“回调”。 

```java
public interface ICallback {
  void methodToCallback();
}

public class BClass {
  public void process(ICallback callback) {
    //...
    callback.methodToCallback();
    //...
  }
}

public class AClass {
  public static void main(String[] args) {
    BClass b = new BClass();
    b.process(new ICallback() { //回调对象
      @Override
      public void methodToCallback() {
        System.out.println("Call back me.");
      }
    });
  }
}
// 或者
public class AClass {
  public static void main(String[] args) {
    BClass b = new BClass();
      
    class MyCallback{
        @Override
        public void methodToCallback() {
            System.out.println("Call back me.");
        }
    }

    b.process(new MyCallback());
  }
}



// 回调函数 methodToCallback
// 模板函数 process
```

**策略模式**：定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。 

- 定义一个策略接口和一组实现这个接口的策略类。
- 由工厂类来创建策略，封装策略创建的细节。
- 策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。

```java
// 策略定义
public interface Strategy {
  void algorithmInterface();
}

public class ConcreteStrategyA implements Strategy {
  @Override
  public void  algorithmInterface() {
    //具体的算法...
  }
}

public class ConcreteStrategyB implements Strategy {
  @Override
  public void  algorithmInterface() {
    //具体的算法...
  }
}


// 策略创建
public class StrategyFactory {
  private static final Map<String, Strategy> strategies = new HashMap<>();

  static {
    strategies.put("A", new ConcreteStrategyA());
    strategies.put("B", new ConcreteStrategyB());
  }

  public static Strategy getStrategy(String type) {
    if (type == null || type.isEmpty()) {
      throw new IllegalArgumentException("type should not be empty.");
    }
    return strategies.get(type);
  }
}


// 策略使用
public class UserCache {
  private Map<String, User> cacheData = new HashMap<>();
  private Strategy strategy;

  public UserCache(Strategy strategy) {
    this.strategy = strategy;
  }
    
    public void useStrategy(){
        // ...
        strategy.algorithmInterface();
        // ...
    }
  //...
}

// 运行时动态确定，根据配置文件的配置决定使用哪种策略
public class Application {
  public static void main(String[] args) throws Exception {
    Strategy strategy = null;
    Properties props = new Properties();
    props.load(new FileInputStream("./config.properties"));
    String type = props.getProperty("strategy_type");
    //
    strategy = StrategyFactory.getStrategy(type);
    UserCache userCache = new UserCache(strategy);
    userCache.useStrategy();
    //...
  }
}

// 非运行时动态确定，在代码中指定使用哪种策略
public class Application {
  public static void main(String[] args) {
    //...
    //
    Strategy strategy = new ConcreteStrategyA();
    UserCache userCache = new UserCache(strategy);
    userCache.useStrategy();  
    //...
  }
}
```

**职责链模式**：在职责链模式中，多个处理器依次处理同一个请求。一个请求先经过A处理器处理，然后再把请求传递给B处理器，B处理器处理完后再传递给C处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。 

```java
// 处理器接口或抽象类
public abstract class Handler {
  protected Handler successor = null;

  public void setSuccessor(Handler successor) {
    this.successor = successor;
  }

  public final void handle() {
    boolean handled = doHandle();
    if (successor != null && !handled) {
      successor.handle();
    }
  }

  protected abstract boolean doHandle();
}

public class HandlerA extends Handler {
  @Override
  protected boolean doHandle() {
    boolean handled = false;
    //...
    return handled;
  }
}

public class HandlerB extends Handler {
  @Override
  protected boolean doHandle() {
    boolean handled = false;
    //...
    return handled;
  }
}

// 处理器链
public class HandlerChain {
  private Handler head = null;
  private Handler tail = null;

  public void addHandler(Handler handler) {
    handler.setSuccessor(null);

    if (head == null) {
      head = handler;
      tail = handler;
      return;
    }

    // 上一个handle把当前handle记录在上一个handle的successor中
    tail.setSuccessor(handler);
    tail = handler;
  }

  public void handle() {
    if (head != null) {
      head.handle();
    }
  }
}

// 使用举例
public class Application {
  public static void main(String[] args) {
    HandlerChain chain = new HandlerChain();
    chain.addHandler(new HandlerA());
    chain.addHandler(new HandlerB());
    chain.handle();
  }
}
```







# 软件设计和重构

- MVC模型的基本工作原理是基于观察者模式，实现是基于命令模式。
- ASTRIDE面向软件，攻击树面向攻击，TVRA面向资产，没有面向风险的方法。ASTRIDE不能发现代码中的安全漏洞。CRC不能用于软件完整性校验。TVRA识别资产的目的是对资产进行分级保护。





- 禁止使用SSL2.0，SSL3.0协议，TLS1.0协议仅可遗留使用，推荐使用TLS1.1, TLS1.2版本
- 会话Token必须使用安全随机数算法生成、有效长度不少于24byte或192bit，且需要设置有效期
- 攻击应对：中间人攻击：双向认证，数字证书认证，公私钥对认证；重放攻击：引入时间戳，序列号，随机数等时变参数；反射攻击：双方采用不同的预共享密钥。认证信息包含身份ID，字符串，随机数等。关掉一侧的认证。
- 对称加密算法运算速度快，密钥长度短，密文长度少，安全性容易证明，缺点是：密钥分发困难，不可用于数字签名。 
- 非对称加密算法密钥分发容易，可以用于数字签名，缺点是：运算慢，密文长度剧烈增长，密钥长度长，安全性不容易证明。

 





- 不改变第三方库的代码，实现该库功能的对接：桥接模式和适配器模式。
- 软件经常需要在某个系统上增加其他系统已有的业务功能，设计时希望在不需要修改已有业务代码封装的同时使得这些功能模块可以同其他系统进行交互，可以使用下面的设计模式来完成这个意图：适配器模式，桥接模式。
- 一个论坛中已注册用户和游客的权限不同，已注册的用户拥有发帖，修改自己的注册信息，修改自己帖子的功能，而游客只能看到别人发的帖子，其他的权限，可以使用代理模式来设计权限管理模块。
- 某公司开发的软件系统，在启动时会远程的读取数据库，导致启动过程缓慢，为了加快启动速度增加了一个数据库本地的缓存模块，通过异步的方式回复数据，提升业务模块的启动速度：代理模式，给目标对象提供一个代理对象，并由代理对象控制对目标对象的引用
- 对象适配器模式是合成聚合复用原则的典型应用
- 依据设计模式思想，程序开发中应优先使用的是委派关系实现复用

**适配器模式：** 场景：现有类的接口不满足需求时。复用现有类，并使不兼容的类一起协同工作。复用现有的子类，通过对象适配器来适配父类接口 

**外观模式：** 场景：为一个复杂的系统对外提供一个统一的接口。对子系统进行分层，并简化层次间的接口依赖 



- 性能测试时，主要观察指标是：资源指标，数据库指标。
- 基于策略的访问控制模式中，一般包含：策略实施点PEP，策略信息点PIP，策略决策点PDP，策略管理点PAP。



- 防止CSRF攻击(Cross-site request forgery, 跨站请求伪造)的主流方法是隐藏域token ，校验Http Referrer 可以消减，但是可能被绕过。

  



- 在数字信封加密状态下，真正用来加密通信过程中传输数据（明文）的密钥是**对称加密密钥** 
-  数字信封是指发送方使用**接收方的公钥**来加密对称密钥后所得的数据







日志可以转存为其他格式，也就是说日志可以修改存储格式 







## 需求分析

> 需求=问题＋解决方案 
>
> 需求包括功能性需求、质量性能需求和约束。
>
> 需求分析定义：准确理解用户的要求，进行细致的调查分析，将用户非形式的需求陈述转化为完整的需求定义，再由需求定义转化到相应的形式功能规约（**需求规格说明**）的过程。



业务建模的过程 ->用例建模的过程

输入：项目目标，需要解决的问题，业务场景等。

输出：设计约束、形式化的功能规约等。



**需求的分层分类：**业务需求层->用户需求层->功能需求层次

业务需求层：反映组织结构或客户对系统、产品高层次的目标要求，在项目远景和范围文档中予以说明。

用户需求层 ：描述用户使用产品必须要完成的任务，在使用实例文档中予以说明。 

功能需求层 ：定义开发人员必须实现的软件功能 ，在软件需求规范中予以说明。 

### 流程

**需求分析主要活动：**

问题识别->分析和综合->规格说明->评审

### 需求分析方法

- 功能分解方法
- 结构化分析方法
- 信息建模法
- 面向对象的分析方法

华为常见需求分析方法：USE-CASE、功能分析。 

#### 基于用例（Use-Case）技术需求分析方法

用例（Use-Case）是一种捕获、组织、描述需求的方法。运用用例方法，来描述系统需求称之为用例建模。用例建模的单元为 “Use-Case” 方法。

交付件：用例模型（包括用例图、用例规格说明）、补充规约（可选）、词汇表（可选） 。

基于用例需求分析的主要活动：

| 分析步骤       | 关键点                                                       |
| -------------- | ------------------------------------------------------------ |
| 收集需求       | 通过访谈、考察、研讨等形式提前确认用户需求，识别功能、性能、质量、约束等需求。 |
| 定义系统边界   | 明确系统的分析范围，系统边界确定了，Use case的粒度也就确定了。比如产品SE分析的范围是单网元/网管，DE分析的边界是模块 |
| 识别Actor      | 1.   系统边界外。   2.   和系统有直接交互，而且是有意义的交互。   3.   可以是人，物，定时器。 |
| 识别Use   Case | 1. Actor可见。   2. 对Actor有价值。   3. 由系统实现。        |
| 整理场景       | 根据该功能可以在哪些客户场景下使用，有哪些输入因素，进行适当的组合归并后得出要分析的场景。 |
| 描述Use   case | 详细、完整地进行用例阐述。                                   |



##### 收集需求

常用需求优先级排序方法 

| 序号 | 方法             | 方法说明                                                     | 推荐场景         |
| ---- | ---------------- | ------------------------------------------------------------ | ---------------- |
| 1    | 入选与落选法     | 采用二分法确定下一个版本需求                                 | 一般项目都可使用 |
| 2    | 三层分级法       | 关注高优先级需求，如果高优先级需求超出下一版本工作量，需将高优先级需求再细分成高、更高、最高三个等级 | 一般项目都可使用 |
| 3    | KANO模型法       | 基本型需求必须满足、期望型需求实现程度与客户满意度成正比     | 一般项目都可使用 |
| 4    | 两两比较并排序法 | 针对少量需求的情况下，给出每条需求的排位                     | <20条需求        |
| 5    | 其它             | 1、100美元法：项目团队对每条需求出价购买，价高者优先级最高   2、二八原则：优先满足收入占比80%的核心用户需求，边缘用户需求靠后   3、性价比法：核心业务需求优先、投入产出比大的优先 | 仅供参考         |



##### 识别参与者Actor 

即确定在系统边界外部与系统进行有意义交互的人或物。因此，Actor并非指软件最终使用客户。

Actor可以是人、硬件、外部系统。

系统时钟是一类特殊的Actor，常用于触发系统内部一些周期性的操作。 

##### 识别用例（Use-Case） 

用例是系统执行的一系列动作，这些动作将生成特定参与者可观测的价值结果 

举例：

输入信息：每半个月用一个Excel表格来记录；每个员工将他的工时表格，用电子邮件发给我。这个表格有固定的格式……

用例： 1）记录员工工时(动宾短语)；2）汇总员工工时(动宾短语)

##### 整理场景

一个Use case通常会包含一到多个场景，每一个场景都是一条到达目标的可能路径

记录员工工时刷卡 :

| 基本场景 | 完成用例目标需要的一系列基本动作 | 1、员工刷卡，读卡器读取员工卡信息，输入到系统；      2、系统获取刷卡的时间，并将员工刷卡信息录入系统；     3、系统将员工刷卡信息持久化；   4、系统界面显示员工刷卡信息（刷卡成功） |
| -------- | -------------------------------- | ------------------------------------------------------------ |
| 异常场景 | 非基本的成功场景和失败场景       | 1、如果员工信息在系统中不存在，界面提示：员工不存在   2、如果员工刷卡方式不正确，导致读卡器未读到员工卡信息，界面提示：请重新刷卡     3、如果工时系统运行出现故障，界面提示：系统故障 |

##### 描述用例 

构建用例图：确定Actor和Actor、用例和用例、Actor和用例之间的关系 

用例阐述，即写用例规约 

用例规约组成：

- 用例名称
- 用例标识
- 涉及的参与者
- 描述
- 用例的规格说明
  - 前置条件 PreConditions
  - 后置条件 PostConditions
  - 正常事件流 Flow of events
  - 异常事件流 Alternate flow
- 其它
  - 非功能需求、设计约束、尚存在的问题

| 用例内容 | 内容解释                                | 写作举例                                                     |
| -------- | --------------------------------------- | ------------------------------------------------------------ |
| 用例名称 | 给用例一个名称                          | 记录员工工时                                                 |
| 用例编号 | 便于管理                                | XXX.YYY.ZZZ.001                                              |
| 简要说明 | 用例的概要描述                          | 当员工上班时需要刷卡，系统记录下员工工时                     |
| Actor    | 用例的所有Actor                         | 员工                                                         |
| 前置条件 | 启动用例前，系统必须满足的条件          | 系统管理员已启动工时系统，显示刷卡界面                       |
| 最小保证 | 用例对系统的最低要求                    | 工时系统在PC上稳定运行，读卡器正常工作                       |
| 后置条件 | 用例完成后，系统的输出或达到的状态      | 如果员工刷卡，则记录本次刷卡时间                             |
| 触法事件 | 启动用例的事件                          | 当员工刷卡时，触发用例                                       |
| 基本场景 | 完成用例目标需要的一系列基本动作        | 1、员工刷卡，读卡器读取员工卡信息，输入到系统；      2、系统获取刷卡的时间，并将员工刷卡信息录入系统；     3、系统将员工刷卡信息持久化；   4、系统界面显示员工刷卡信息（刷卡成功） |
| 异常场景 | 非基本的成功场景和失败场景              | 1、如果员工信息在系统中不存在，界面提示：员工不存在   2、如果员工刷卡方式不正确，导致读卡器未读到员工卡信息，界面提示：请重新刷卡     3、如果工时系统运行出现故障，界面提示：系统故障 |
| DFX属性  | 该用例涉及的DFX属性的要求和各架构的目标 | 1、员工刷卡后，0.5秒内在界面显示刷新信息；   2、已刷卡成功的员工信息，系统重启后，不丢失；      3、刷卡显示界面风格和内容，可以更换 |

### 输出质量要求

需求分析输出的质量准则包括完整性，正确性，可验证性和一致性。

## 需求管理

E2E需求管理流程：需求收集->需求分析->需求决策（变更）->需求实现->需求验证

### 需求管理活动

变更控制 、版本控制 、状态跟踪 、需求跟踪 e

#### 需求变更 

需求说明书一般要经过论证，如果在需求说明书经过论证以后，需要在原有需求基础上追加和补充新的需求，或对原有需求进行修改和削减，均属于需求变更 

##### 流程

需求评估->变更电子流 ->需求决策（RAT/RMT/CCB）->导入版本协同落地 

### 总结

- 软件项目唯一不变的就是不断变更，但在某个版本中，要**通过合理的版本管理和需求管理尽可能保持需求稳定**。
- 需求管理贯穿整个软件需求工程中。需求管理**最基本的任务是明确需求**，使项目团队和用户达成共识，即**建立需求基线**。
- 需求管理对项目的成功有着重要影响，需求的变更需要进行规范的流程管控，根据需求排序**及时拒绝低优级的需求**，可以减少后继的方案设计及开发工作量。

# 设计模式和应用

所有的设计原则和设计模式都是为了更容易的实现高内聚低耦合。 

正交四原则：

- 最小化重复
- 分离变化：识别变化方向并对变化预留扩展接口
- 缩小依赖范围：最小化知识原则；依赖接口，不要依赖实现；接口应该尽可能包含少的知识
- 向稳定方向依赖：站在需求的角度去定义API，而不是实现的方式去定义API。要站在客户的角度去定义API，而不是站在实现者的角度。这也是我们会什么经常要面向接口编程。因为接口是抽象的，是稳定的，实现是不稳定的。 

面向对象的SOLID原则：

- 单一职责（SRP）
- 向扩展开放/向修改封闭（OCP）
- 子类要能替换父类（LSP）
- 接口隔离/最小化接口依赖（ISP）
- 依赖倒置/只依赖接口（DIP）

## 设计模式

| 分类   | 设计模式                                                     |
| ------ | ------------------------------------------------------------ |
| 创建型 | 1.   **Factory Method（工厂方法）**：隔离创建对象的细节，使得创建对象的行为可扩展<br>2.   **Abstract Factory（抽象工厂）**：该模式抽象出创建一组相关对象的接口，其中每个方法即为factory method      <br>3.   Builder（建造者）：与factory不同的是，该模式包含了对象构造的若干过程，因此天然地与template结合     <br> 4.   Prototype（原型）: 用于以某个对象为模子创建一个新对象的场景，例如幻灯片中的母版与普通页、对象的克隆      <br>5.   Singleton（单例）： |
| 结构型 | 6.   **Adapter Class/Object（适配器）**：处理遗留系统的不二法宝，也可以用空方法实现接口作为抽象父类      <br>7.   Bridge（桥接）: 使用关联代替继承，解决类多维度的扩展导致的类爆炸的问题      <br>8.   Composite（组合）：将组件组装为整体使用      <br>9.   Decorator（装饰）：常见于各种wrapper，常用于在原函数执行前后做一些额外的工作      <br>10.   **Facade（外观）**：封装扇出，利用树状结构减少调用者的复杂度      <br>11.   Flyweight（享元）：复用变化少的对象      <br>12.   Proxy（代理）：是原对象的一个完整的替代品 |
| 行为型 | 13. Interpreter（解释器）：一般用于解释执行自定义的某种语法      <br>14.   Template Method（模板方法）：框架与钩子      <br>15.   **Chain of Responsibility（责任链）**：一组对象按照既定的顺序关联起来，依次处理请求，其中任一对象都有权停止调用传递      <br>16.   Command（命令）: 将行为抽象和解耦      <br>17.   Iterator（迭代器）：封装数据的访问行为（顺序、可见性等）      <br>18.   Mediator（中介者）：用一个中介对象来封装一系列的交互;新增一个模块处理两个模块的交互      <br>19.   Memento（备忘录）：将当前对象的状态信息保存为另一个对象，使得当前对象可以基于状态镜像快速恢复原状态      <br>20.   **Observer（观察者）**: 订阅/发布模型，用于事件驱动的设计      <br>21.   State（状态）：封装FSM（有限状态机）的状态与状态迁移，每个状态定义了自身的输入与状态迁移      <br>22.   Strategy（策略）：使用接口即使用strategy，用于隔离变化      <br>23.   Visitor（访问者）：数据与行为分离方法。通过这种分离，可达到一个被访问者动态添加新的操作而无需做其他的修改的效果 |



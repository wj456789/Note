## java基础

[Maven把项目依赖的所有jar包都打到同一个jar中](https://blog.51cto.com/u_12796481/2796873) 

[maven打jar包并引入依赖包(使用assembly和dependency插件)](https://blog.csdn.net/Luck_ZZ/article/details/108648753)

[maven中把依赖的JAR包一起打包](https://blog.csdn.net/xiaokanfuchen86/article/details/113919498)

## SpringBoot

### 国际化MessageSource

#### MessageSource接口

Spring中定义了一个MessageSource接口，以用于支持信息的国际化和包含参数的信息的替换。MessageSource接口的定义如下，对应的方法说明已经在方法上注释了。

```java
public interface MessageSource {

    /**
	 * 解析code对应的信息进行返回，如果对应的code不能被解析则返回默认信息defaultMessage。
	 * @param 需要进行解析的code，对应资源文件中的一个属性名
	 * @param 需要用来替换code对应的信息中包含参数的内容，如：{0},{1,date},{2,time}
	 * @param defaultMessage 当对应code对应的信息不存在时需要返回的默认值
	 * @param locale 对应的Locale
	 * @return
	 */
    String getMessage(String code, Object[] args, String defaultMessage, Locale locale);

    /**
	 * 解析code对应的信息进行返回，如果对应的code不能被解析则抛出异常NoSuchMessageException
	 * @param code 需要进行解析的code，对应资源文件中的一个属性名
	 * @param args 需要用来替换code对应的信息中包含参数的内容，如：{0},{1,date},{2,time}
	 * @param locale 对应的Locale
	 * @return 
	 * @throws NoSuchMessageException 如果对应的code不能被解析则抛出该异常
	 */
    String getMessage(String code, Object[] args, Locale locale) throws NoSuchMessageException;

    /**
	 * 通过传递的MessageSourceResolvable对应来解析对应的信息
	 * @param resolvable 
	 * @param locale 对应的Locale
	 * @return 
	 * @throws NoSuchMessageException 如不能解析则抛出该异常
	 */
    String getMessage(MessageSourceResolvable resolvable, Locale locale) throws NoSuchMessageException;

}
```

#### SpringBoot+MessageSource

springboot默认支持国际化，需要在类路径下创建国际化配置文件，注意名称必须以messages开始。 比如在resoure下新建i18n目录，在此目录下新建message.properties，messages.properties （默认的语言配置文件，当找不到其他语言的配置的时候，使用该文件进行展示）。yml文件中指定了messageSource的basename为message，即根资源文件应为类路径下的messages.properties，其它的都是需要带Locale后缀的，如中国大陆是messages_zh_CN.properties。 

```yaml
# application.yml
spring:
  messages:
    basename: classpath:i18n/messages
    encoding: UTF-8
    cache-duration: 3600ms
```

```properties
# messages.properties
LineAgeShow_100007=传入参数为空
LineAgeShow_100008=模型血缘关系异常
LineAgeShow_100009=模型血缘关系id为空

# messages_en_US.properties
LineAgeShow_100007=The incoming parameter is empty
LineAgeShow_100008=Model LineAge relationship exception 
LineAgeShow_100009=Model lineAge id is empty

# messages_zh_CN.properties
LineAgeShow_100007=传入参数为空
LineAgeShow_100008=模型血缘关系异常
LineAgeShow_100009=模型血缘关系id为空
```

```java
import org.springframework.context.MessageSource;
/**
 * 国际化语言获取工具类
 *
 */
@Component
public class LocaleMessageSourceUtil {
    @Resource
    private MessageSource messageSource;

    private Boolean isEN(HttpServletRequest request) {
        HttpSession session = request.getSession();
        if (session != null) {
            Object obj = session.getAttribute(AppConstant.LANGUAGESETTING);
            if (obj instanceof String) {
                String lang = NormalizerUtil.normalizeForString((String) obj);
                return lang.toLowerCase(Locale.ENGLISH).contains("en");
            }
        }
        return false;
    }

    public Boolean isEN() {
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();
        if (requestAttributes != null) {
            HttpServletRequest request = ((ServletRequestAttributes) requestAttributes).getRequest();
            return isEN(request);
        }
        return false;
    }

    public String getMessage(String code, Locale locale) {
        /**
         * code：信息的键，properties中的key
         * args：系统运行时参数，可为空
         * defaultMessage：默认信息，可为空
         * locale：区域信息，我们可以通过java.util.Locale类下面的静态常量找到对应的值。如：简体中文就是zh_CN；英文就是en_US，详见java.util.Locale中的常量值，Locale.US是en_US或Locale.SIMPLIFIED_CHINESE是zh_CN
         */
        return messageSource.getMessage(code, null, null, locale);
    }

    public String getMessage(String code, HttpServletRequest request) {
        return messageSource.getMessage(code, null, null, Locale.SIMPLIFIED_CHINESE);
    }

    public String getMessage(String code) {
        return messageSource.getMessage(code, null, Locale.SIMPLIFIED_CHINESE);
    }
}
```

```java
@Autowired
private LocaleMessageSourceUtil messageSourceUtil;

messageSourceUtil.getMessage("LineAgeShow_100007", Global.getHttpServletRequest())
```

```java
public class Global {
    public static HttpServletRequest getHttpServletRequest() {
        HttpServletRequest request = null;
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();

        if (requestAttributes == null) {
            return request;
        }
        return ((ServletRequestAttributes) requestAttributes).getRequest();
    }

    public static HttpSession getHttpSession() {
        return getHttpServletRequest().getSession();
    }
}
```

[国际化MessageSource](https://elim168.github.io/spring/bean/21.%E5%9B%BD%E9%99%85%E5%8C%96MessageSource.html)

## IDEA

修改IDE配置文件

Help -- Edit Custom VM Options

监控IDEA进程占用CPU

Help -- Diagnostic Tools -- Activity Monitor

插件启动时间分析器 

Help -- Diagnostic Tools -- Analyze Plugin Startup Performance

## Gson

使用Gson解析json成对象时默认的是将json里对应字段的值解析到java对象里对应字段的属性里面。 可以使用@SerializedName注解来将对象里的属性跟json里字段对应值匹配起来。 

```java
json数据如下：
{
    "id":"1"
    "n":"kyoya"
    "p":"123456"
    "s":"0"
}

public class User{
    private String id;
 
    @SerializedName("n")
    private String userName;
 
    @SerializedName("p")
    private String password;
 
    @SerializedName("s")
    private String sex;
}
// 使用Gson解析json字符串或使用Gson生成json字符串都可以相互匹配
```



## sql

### sequence

在Oracle中sequence就是序号，每次提取完都会自动增加，步幅固定，它与表没有直接关系 

序列(SEQUENCE)其实是序列号生成器，可以为表中的行自动生成序列号，产生一组等间隔的数值(类型为数字)。其主要的用途是生成表的主键值，可以在插入语句中引用，也可以通过查询检查当前值，或使序列增至下一个值。

创建序列需要CREATE SEQUENCE系统权限。

```sql
-- 创建sequence语句：
CREATE SEQUENCE seq_name-- seq_name为计数器的名字，自定；
INCREMENT BY 1 -- 每次加幅度:1,2,3,....；
START WITH 1 -- 起始序号，以实际生产情况而定；
MINVALUE 0 -- 最小值
NOMAXvalue -- 不设置最大值，或设定最大值： maxvalue 9999;
NOCYCLE -- 一直累加，不循环; 或循环使用 cycle ;
CACHE 10; --设置缓存序列个数，如果系统down掉了或者其它情况将会导致序列不连续，也可以设置为--NOCACHE



-- 修改sequence：
-- Alter sequence 可以修改sequence（除起始值）步幅、最大/最小值、是否循环、缓存个数 这些参数；
例：
Alter Sequence seq_name  
Increment  By  2 
Maxvalue 9999
Cycle
Cache 5;
-- 需要修改sequence的起始值，则需要删除原有sequence，重新创建；



-- 应用sequence：
-- sequence创建完成后，就可以使用sequence的两个参数 currval、nextval；
-- currval查询sequence的当前值：
select seq_name.currval from dual;
-- nextval增加sequence的值，然后返回sequence值：
select seq_name.nextval from dual;
-- 例：对某一张表使用：
insert into tb_name(id,name) values(seq_name.nextval,'下一个计数');



-- 删除sequence ：
drop sequence seq_name;
```

**注：**

- currval是取当前值，所以一个新的计数器sequence必须先使用nextval后才可以使用currval否则会报错;
- nextval是取下一个值，但第一次使用时取的是初始值，之后正常取下一个，且如果一个语句(不同的子句)里面有多个nextval，它们的取值可能是不同的；
- 如果指定CACHE值，ORACLE就可以预先在内存里面放置一些sequence，cache里面的取完后，oracle自动再取一组到cache。 
  - 优点：存取的快些，尤其是并发访问时。
  - 缺点：使用cache或许会跳号， 比如数据库突然不正常down掉（shutdown abort),cache中的sequence就会丢失. 所以可以在创建的时候用nocache防止这种情况。

**什么时候使用sequence?**

- 不包含子查询、snapshot/view的select的语句
- insert语句的子查询中
- insert语句的values中
- update的set中

如：update 表名 列值=序列名.nextval where 条件;

 

**在sqlserver和mysql中都可以在定义表的时候，直接给指定自增长。**

sqlserver中设置自增长

create table 表名(id int primary key identity(1,1),name varchar(32));

mysql中设置自增长

create table 表名(id int primary key auto_incrment,name varchar(32));

[数据库Sequence创建与使用](https://www.cnblogs.com/klb561/p/11333643.html)

## Python

[脚本样例](https://blog.csdn.net/m0_48978908/article/details/118881731)

### with open

[python文件读取with open替代try finally](https://www.jianshu.com/p/6f479f14eeac)

### zip

[`zipfile`](https://docs.python.org/zh-cn/3/library/zipfile.html#module-zipfile) --- 使用ZIP存档

[使用python自带的zipfile模块做压缩文件夹/解压缩zip文件功能](https://gist.github.com/hfeeki/ce7b6920b7d01012576b) 

### except

[Python中获取异常（Exception）信息](https://www.cnblogs.com/klchang/p/4635040.html)

### 文件

[python逐行读取文件内容的三种方法](https://blog.csdn.net/zhengxiangwen/article/details/55148287)

[python 实现将txt文件多行合并为一行并将中间的空格去掉方法](https://www.jb51.net/article/153111.htm)

[Python判断文件是否存在的三种方法](https://www.cnblogs.com/jhao/p/7243043.html)

[使用python删除一个文件或文件夹](https://www.cnblogs.com/aaronthon/p/9509538.html)

### 循环

[python跳出多层循环的几种方法](https://www.cnblogs.com/sjx1996/articles/10219812.html)

### 时间戳

[python - 获取时间戳（10位和13位）](https://blog.csdn.net/xuezhangjun0121/article/details/78083717)

### 字符串

[循环拼接字符串](https://blog.csdn.net/Rookie_Max/article/details/104043740)

[Python字符串拼接的十种方式](https://cloud.tencent.com/developer/article/1750006)











## Linux

### top

用top命令查看cpu 显示的所有的cpu加起来的使用率，说明你的CPU是多核，你运行top后按大键盘1看看，可以显示每个cpu的使用率，top里显示的是把所有使用率加起来

按下1后可以看到我的机器的CPU是双核的。%Cpu0，%Cpu1

### 查看文件系统的挂载时间 

#### ext文件系统

```sh
# 如果文件系统类型为ext3、ext4，那么可以使用命令tune2fs查看文件系统最后一次挂载时间。
$ tune2fs -l /dev/sda1
...
Last mount time:          Tue Feb 12 15:36:22 2019
...
```

[Linux查看文件系统的挂载时间浅析](https://blog.51cto.com/u_15338523/3586937) 

### df

```sh
$ df -h /tmp	# 查看目录/tmp空间信息
```



### jar

> spring boot替换jar包中的jar包（Unable to open nested entry 'BOOT-INF/lib/**.jar'. It has been compressed）

```sh
# 通过jar命令先将jar包解压
$ jar -xvf test.jar
# 手动替换内部jar包再压缩
$ jar -cfM0 test.jar ./
```



### hostname

```sh
# 查看主机名，-f 显示完整的内容
$ hostname -f

# 设置主机名
$ hostname 主机名
```



### zip

```sh
# zip把文件直接增加/更新到某个压缩包指定目录
$ zip -u 压缩包路径  要存进的目录/文件名

# /home/user/test.zip		/var/mail/123.txt
$ zip -u /home/user/test.zip /var/mail/123.txt	# 123.txt在压缩包中的路径仍为 var/mail/123.txt

# 假设test.zip压缩包中有个文件夹名为Hi，我想把123.txt放在Hi文件夹下，需要在当前目录创建目录Hi，将123.txt放在Hi目录下
$ cd 当前目录
$ zip -u /home/user/test.zip Hi/123.txt
```

### unzip

在linux下解压在windows下压缩的zip文件时，如果压缩包中的文件名或目录名包含中文，就会出现乱码 

```sh
# 可以使用以下两种方法解决
$ unzip -O CP936 xxx.zip
$ unzip -O GBK xxx.zip
```



### 变量作用域

Shell脚本中在函数外和函数内定义的变量是都是global（全局）的。

- 函数外定义的变量其作用域从被定义的地方开始，到shell结束或被显示删除的地方为止。
- 函数内定义的变量其作用域是从函数被调用时变量定义的地方开始，到shell结束或被显示删除的地方为止。注意，不是从定义函数的地方开始，而是从调用函数的地方开始。 

 

脚本接收的参数是global（全局）的。

函数接收的参数是local（局部）的，其作用域在函数内。函数内部可以用local定义局部变量。e.g:  local a1=200

当局部变量和全局变量重名的时候，局部变量会屏蔽全局变量

[Linux shell脚本 变量作用域](https://www.cnblogs.com/pass-ion/p/14372742.html)



### traceroute

traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。 

[traceroute和tracert用法详解](https://blog.csdn.net/zhouwei1221q/article/details/45370039)

### hosts文件

hosts文件是Linux系统上一个负责ip地址与域名快速解析的文件，以ascii格式保存在/etc/目录下。hosts文件包含了ip地址与主机名之间的映射，还包括主机的别名。在没有域名解析服务器的情况下，系统上的所有网络程序都通过查询该文件来解析对应于某个主机名的ip地址，否则就需要使用dns服务程序来解决。通过可以将常用的域名和ip地址映射加入到hosts文件中，实现快速方便的访问。

**hosts文件格式**

` ip地址 主机名/域名 (主机别名)`

**主机名和域名的区别在于**：

- 主机名通常在局域网内使用，通过hosts文件，主机名就被解析到对应的ip。
- 域名通常在internet上使用，但是优先级低于hosts文件中内容，因此如果你不想使用internet上的域名解析，可以更改自己的hosts文件，加入自己的域名解析。

修改`www.baidu.com`的ip为127.0.0.1： 

```sh
$ cat /etc/hosts
127.0.0.1 localhost
127.0.0.1 www.baidu.com

$ ping www.baidu.com
64 bytes from localhost(127.0.0.1): icmp_seq=1 ttl=56 time=21.5 ms
```

### expect

expect是一个**自动化交互**套件，主要应用于执行命令和程序时，系统以交互形式要求输入指定字符串，实现交互通信。

expect自动交互流程：

spawn启动指定进程---expect获取指定关键字---send向指定程序发送指定字符---执行完成退出。

```sh
# 注意该脚本能够执行的前提是安装了expect
$ yum install -y expect
```

```
expect常用命令总结:
spawn               交互程序开始后面跟命令或者指定程序
expect              获取匹配信息匹配成功则执行expect后面的程序动作
send exp_send       用于发送指定的字符串信息
exp_continue        在expect中多次匹配就需要用到
send_user           用来打印输出 相当于shell中的echo
exit                退出expect脚本
eof                 expect执行结束 退出
set                 定义变量
puts                输出变量
set timeout         设置超时时间
$argv			   expect脚本可以接受从bash传递过来的参数.可以使用[lindex $argv n]获得，n从0开始，分别表示第一个,第二个,第三个....参数
interact		   允许用户交互；执行完成后保持交互状态，把控制权交给控制台，这个时候就可以手工操作了。如果没有这一句登录完成后会退出，而不是留在远程终端上。
```

#### except脚本

```sh
# 这一行告诉操作系统脚本里的代码使用那一个shell来执行，需要在脚本的第一行
#!/usr/bin/expect -f
# “set 自定义变量名”：设置超时时间，计时单位是：秒。timeout -1 为永不超时
set timeout 10
# spawn是进入expect环境后才可以执行的expect内部命令，主要的功能是给运行进程加个壳，用来传递交互指令。可以理解为启动一个新进程
spawn sudo su - root
# 从进程接收字符串，这里的expect是expect的一个内部命令。这个命令的意思是判断上次输出结果里是否包含“*password*”的字符串，如果有则立即返回，否则就等待一段时间后返回，这里等待时长就是前面设置的10秒； 
expect "*password*"
# send接收一个字符串参数"123456"，并将该参数发送到进程。这里就是执行交互动作，与手工输入密码的动作等效。 命令字符串结尾加上“\r”，表示“回车键”。 
send "123456\r"
expect "#*"	#进程返回#*时
send "ls\r"	#向进程输入ls\r
expect "#*"
send "df -Th\r"
# 单一分支模式
expect "hi" {send "You said hi"}
# 多分支模式，匹配到hi,hello,bye任意一个字符串时，执行相应的输出
expect {
    "hi" { send "You said hi\n"}
    "hello" { send "Hello yourself\n"}
    "bye" { send "That was unexpected\n"}
}
send "exit\r"
expect eof
```

#### shell调用expect 

```sh
#!/bin/bash
# 密码过期需要批量修改密码
for i in `cat /root/soft/ip.txt`
do
    /usr/bin/expect << EOF
    spawn /usr/bin/ssh root@$i
    expect {
    	"UNIX password" { send "Huawei@123\r" }
    }
    expect {
    	"New password:" { send "xxHuzzawexxi@1234#\r" }
    }
    expect {
    	"Retype new password:" { send "xxHuzzawexxi@1234#\r" }
    }
    expect "*]#"
    send "echo Huawei@123|passwd --stdin root\r"
    expect "*]#"
    send "exit\r"
    expect eof
EOF
done
```

[Linux expect 介绍和用法一](https://www.cnblogs.com/saneri/p/10819348.html)

[linux expect spawn的用法](https://www.cnblogs.com/bulh/articles/12779173.html)

### 用户

切换用户只执行一条命令的可以用: `su - oracle -c command`

切换用户执行一个shell文件可以用:`su - oracle -s /bin/bash shell.sh`

### awk

AWK 是一种处理文本文件的语言

```sh
# -F 指定输入文件折分隔符

$ cat log.txt
2 this, is a test
10 There are orange,apple,mongo

# 每行按空格或TAB分割，输出文本中的1、4项
$ awk '{print $1,$4}' log.txt
2 a
10 orange,apple,mongo

# 使用","分割
$ awk -F, '{print $1,$2}' log.txt
2 this  is a test
10 There are orange apple
```

**awk、sed、grep更适合的方向：**

- grep 更适合单纯的查找或匹配文本
- sed 更适合编辑匹配到的文本
- awk 更适合格式化文本，对文本进行较复杂格式处理

### su

su命令和su -命令最大的本质区别就是：

su是switch user 或set user id的一个缩写。这个命令让你开启一个子进程，成为新的用户 ID 和赋予你存取与这个用户ID 关联所有文件的存取权限；也就是说只是切换了用户身份，但Shell环境仍然是之前用户的Shell，工作目录仍然是之前用户的工作目录。su username是获得username的文件存取执行权限，不能获得环境变量。

su -是用户和Shell环境一起切换成新用户身份，切换了Shell环境不会出现PATH环境变量错误，可以用echo $PATH命令查看环境变量，工作目录变成新用户的工作目录了。su - username是获得username的文件存取执行权限和环境变量 。

su 后面不加用户是默认切到 root

## Shell

### 数组

```sh
for var in ${array[@]};do
    USERNAME="$var"
    if [[ ${USERNAME} != "pc" && ${USERNAME} != "pcm" && ${USERNAME} != "ckm" && ${USERNAME} != "portal" ]]; then
        continue
    fi
    if id -u ${USERNAME} >/dev/null 2>&1 ; then
        if [ -e /home/Software_temp/Software/${USERNAME}/ ]; then
            currentarray[$index]=${USERNAME};
            index=$(($index+1));
        fi
    fi
done
log_info "execute user: ${currentarray[@]}"
```

[Shell数组的增删改查](https://www.cnblogs.com/tangshengwei/p/5446315.html)

### 运算符

#### 算数运算符

```sh

==	相等。用于比较两个数字，相同则返回 true。
!=	不相等。用于比较两个数字，不相同则返回 true。
```

```sh
val=`expr 2 + 2`
val=`expr $b / $a`
1.表达式和运算符之间要有空格，例如 2+2 是不对的，必须写成 2 + 2
2.完整的表达式要被``包含，注意使用的是反引号 `` 而不是单引号 ''
3.expr 是一款表达式计算工具
```

```sh
1.使用let命令 
等号右边以及运算符和括号的两边都不能有空格
let "sum=3+5"
let "sum=3*5"
let "sum=(-6-9)*5"

2.使用expr命令  
乘号(*), 左括号( , 右括号)必须使用反斜杠(\)转义。expr右边以及运算符和括号的两边必须有空格; 
val=`expr $a + $b`
val=`expr $a - $b`
val=`expr $a \* $b` # 乘号*前边必须加反斜杠\才能实现乘法运算；
val=`expr \( $b - $a \) \* $c`


3.使用(( ... )) 的形式  
无需对运算符和括号做转义处理，也可以采用松散或紧凑的格式
sum=$((3+5))
sum=$(( 3 * 5 ))
```



#### 关系运算符

关系运算符只支持数字，不支持字符串，除非字符串的值是数字。 

```sh
-eq -ne -gt -lt -ge -le
```

#### 布尔运算符

```sh
!	非运算，表达式为 true 则返回 false，否则返回 true。	[ ! false ] 返回 true。
-o	或运算，有一个表达式为 true 则返回 true。	[ $a -lt 20 -o $b -gt 100 ] 返回 true。
-a	与运算，两个表达式都为 true 才返回 true。	[ $a -lt 20 -a $b -gt 100 ] 返回 false。
```

#### 逻辑运算符

**&&**：

```sh
command1  && command2
1.命令之间使用 && 连接，实现逻辑与的功能。
2.只有在 && 左边的命令返回真（命令返回值 $? == 0），&& 右边的命令才会被执行；只要有一个命令返回假（命令返回值 $? == 1），后面的命令就不会被执行。
```

**||**：

```sh
command1 || command2
1.命令之间使用 || 连接，实现逻辑或的功能。
2.只有在 || 左边的命令返回假（命令返回值 $? == 1），|| 右边的命令才会被执行；只要有一个命令返回真（命令返回值 $? == 0），后面的命令就不会被执行。
```

```sh
[[ $a -lt 100 && $b -gt 100 ]] 返回 false
[[ $a -lt 100 || $b -gt 100 ]] 返回 true
```

#### 字符串运算符

```sh
=	检测两个字符串是否相等，相等返回 true。	[ $a = $b ] 返回 false。
!=	检测两个字符串是否不相等，不相等返回 true。	[ $a != $b ] 返回 true。
-z	检测字符串长度是否为0，为0返回 true。	[ -z $a ] 返回 false。
-n	检测字符串长度是否不为 0，不为 0 返回 true。	[ -n "$a" ] 返回 true。
$	检测字符串是否不为空，不为空返回 true。	[ $a ] 返回 true。
```

#### 文件运算符

```sh
-b file	检测文件是否是块设备文件，如果是，则返回 true。	[ -b $file ] 返回 false。
-c file	检测文件是否是字符设备文件，如果是，则返回 true。	[ -c $file ] 返回 false。
-d file	检测文件是否是目录，如果是，则返回 true。	[ -d $file ] 返回 false。
-f file	检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。	[ -f $file ] 返回 true。
-g file	检测文件是否设置了 SGID 位，如果是，则返回 true。	[ -g $file ] 返回 false。
-k file	检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。	[ -k $file ] 返回 false。
-p file	检测文件是否是有名管道，如果是，则返回 true。	[ -p $file ] 返回 false。
-u file	检测文件是否设置了 SUID 位，如果是，则返回 true。	[ -u $file ] 返回 false。
-r file	检测文件是否可读，如果是，则返回 true。	[ -r $file ] 返回 true。
-w file	检测文件是否可写，如果是，则返回 true。	[ -w $file ] 返回 true。
-x file	检测文件是否可执行，如果是，则返回 true。	[ -x $file ] 返回 true。
-s file	检测文件是否为空（文件大小是否大于0），不为空返回 true。	[ -s $file ] 返回 true。
-e file	检测文件（包括目录）是否存在，如果是，则返回 true。	[ -e $file ] 返回 true。
```



**|**：

```sh
command 1 | command 2 
管道符号，把第一个命令command 1执行的结果作为command2的输入传给command 2
```

**()**：

```sh
(command1;command2;command3....)               多个命令之间用;分隔
1.把几个命令合在一起执行，命令之间使用命令分隔符（;）分隔。
2.使用()括起来的命令在执行前面都不会切换当前工作目录，也就是说命令组合都是在当前工作目录下被执行的，尽管命令中有切换目录的命令。
```

[shell 中| && || () {} 用法以及shell的逻辑与或非](https://www.cnblogs.com/aaronLinux/p/8340281.html)

### 重定向

在shell脚本中，默认情况下，总是有三个文件处于打开状态，标准输入(键盘输入)、标准输出（输出到屏幕）、标准错误（也是输出到屏幕），它们分别对应的文件描述符是0，1，2 。输出重定向到相应的文件中，而不再屏幕显示。

```
> 默认为标准输出重定向，与 1> 相同
2>&1  意思是把 标准错误输出 重定向到 标准输出.

&>file  意思是把标准输出 和 标准错误输出 都重定向到文件file中
```

```sh
$ nohup java -jar app.jar >log 2>&1 &
本来1----->屏幕 （1指向屏幕）
执行>log后， 1----->log (1指向log)
执行2>&1后， 2----->1 (2指向1，而1指向log,因此2也指向了log
所以>log 2>&1顺序不能错误
```

### 当前时间

```sh
time=$(date "+%Y-%m-%d %H:%M:%S")
echo "${time}"
```



### 跳出循环 

continue、break、continue、return、exit

**break**：跳出当前一层循环	**break n**：跳出n层循环

**continue**：跳出一层本次循环	**continue n**：跳出n层本次循环，其效果相当于内层循环和外层循环同时执行了不带 n 的 continue 

**exit**：

exit 是一个 Shell 内置命令，用来退出当前 Shell 进程，并返回一个退出状态；使用$?可以接收这个退出状态；

exit 命令可以接受一个整数值作为参数，代表退出状态。如果不指定，默认状态值是 0。

一般情况下，退出状态为 0 表示成功，退出状态为非 0 表示执行失败（出错）了。

exit 退出状态只能是一个介于 0~255 之间的整数，其中只有 0 表示成功，其它值都表示失败。

**return**：表示函数返回值，只能用在函数里，使得shell函数退出并返回数值，返回值为你指定的参数n的值，如果没有指定 n 的值，则默认为函数最后一条命令执行的返回状态。 

[跳出循环](https://blog.csdn.net/focus_lyh/article/details/112319193)

```sh
# 判断一个用户是否存在
USERNAME=tsit
if id -u ${USERNAME} >/dev/null 2>&1 ; then
    echo "User ${USERNAME} exists."
else
    echo "User ${USERNAME} does not exist!"
fi
```

### temp

```sh
if [ -n ${PAAS_TYPE} -a "${PAAS_TYPE}" = "FusionStage" ];then
	...
fi

SCRIPT_DIR=`dirname $SCRIPT`
SCRIPT_DIR=`cd $SCRIPT_DIR && pwd`

typeset PARSE_JSON="sh $SCRIPT_DIR/tools/JSON.sh -b"
typeset global_config="${SCRIPT_DIR}/globalConfigurations.json"

key_size=`${PARSE_JSON} < ${global_config} | grep "key" | uniq | wc -l`
for((k=0;k<${key_size};k++))
do
	...
done



su - pc -c "cd 7897899"
if [ $? -ne 0 ]; then
    ...
    exit 1
fi


if [ $# -ne 4 ] && [ $# -ne 2 ]; then
    ...
    exit 1
fi

if [ $? -ne 0 ] || [ "X" = "X${json_string}" ];then
    ...
    exit 1
else
    ...
fi


if [ "X${base_version:0:8}" = "XV300R001" -o "X${base_version:0:8}" = "XV300R002" -o "X${base_version:0:8}" = "XV300R003" -o "X${base_version:0:11}" = "XV300R005C01" ];then
	...
fi


if [ -f "${SCRIPT_DIR}/install_itpaas_info.ini" ];then
	...
elif [ -f "..." ];then
	...
else
	...
fi



while [ -h "$SCRIPT" ] ; do
	...
done





if [ -e /home/uap -a -e /home/paas ]; then
    echo "123"
else
    echo "fail"
fi
if [[ -e /home/uap && -e /home/paas ]]; then
    echo "456"
fi







if [[ -e /home/uap/dsp_backup && -n "$(cd /home/uap/dsp_backup;ls -l |tac |grep backup_|awk '{print $9}'|head -1)" ]];then
        echo "1"
else
        echo "2"
fi

if [[ -e /home/uap/dsp_backup && $(cd /home/uap/dsp_backup;echo $?) -eq 0 ]];then
        echo "3"
else
        echo "4"
fi

USERNAME=pc
if [[ -e /home/uap/dsp_backup ]];then
        cd /home/uap/dsp_backup
        backup_path=$(ls -l |tac |grep backup_|awk '{print $9}'|head -1)
        echo $backup_path
        if [[ -n $backup_path && -e /home/uap/dsp_backup/$backup_path/$USERNAME ]];then
                currentarray[$index]=${USERNAME};
                index=$(($index+1));
        fi
echo ${currentarray[@]}
fi


function log_temp(){
	echo "$(date "+%Y-%m-%d %H:%M:%S") "$1 >>/opt/varlib/kubelet/pods/uninstall.log 2>&1
}








SCRIPT_DIR=$(dirname $SCRIPT)
SCRIPT_DIR=$(cd $SCRIPT_DIR && pwd)

# 遍历备份文件列表中的所有行，文件格式必须是unix
while read filePath
do
# 将每一行文件路径拼接在空格之后存放在一个变量中
    backup_content="${backup_content} ${filePath}"
done < ${SCRIPT_DIR}/backuplist.properties
```



## JS

### 动态添加

#### 案例一

```html
<div id="OuterDiv_C" style="position:absolute;top:9%;left:47%;width:15%;height:15%;">
    <div id="InterDiv_C">
        <p id="FontStyle1"><span id="sp0_C" style="float:left;margin-top:8px;margin-left:15px;line-height: 11px;color:#41beff;"></span></p>
        <img id="img1" src="images/iopImages/showMore.png" class="img" style="float:right;margin-top:12px;margin-right:8px;" />
    </div>
    <div id="ContentDiv_C" style="width:150px;margin-left: 0px;margin-top: 2px; display: none;">
    </div>
</div>
```

```javascript
$scope.initContentData = function ($Model, type) {
    $Fire({
        'service' : "queryIndexService/getContentInfo",
        'target' : '$Model.contentInfo'
    }, this).onafter(function(){
        $("#sp0_C").text($Model.contentInfo.defaultContent);
        if($Model.contentInfo.timeContents){
            for(var i=0;i<$Model.contentInfo.timeContents.length;i++){
                var timeContent = $Model.contentInfo.timeContents[i];
                if(timeContent == "累计12个月"){
                    $("#ContentDiv_C").append('<div id="Content2Div_C">\n' +
                                              '<img src="images/iopImages/top-partingLine.png" style="width:150px"/>\n' +
                                              '<p id="FontStyle1" style="margin-top:7px;margin-left:15px;color:#666666;font-size:16px;">\n' +
                                              '<span id="sp2_C">累计12个月</span>\n' +
                                              '</p>\n' +
                                              '</div>');
                }else {
                    $("#ContentDiv_C").append('<div id="ContentDiv'+timeContent+'">\n' +
                                              '<img src="images/iopImages/top-partingLine.png" style="width:150px"/>\n' +
                                              '<p id="FontStyle1" style="margin-top:8px;margin-left:15px;color:#666666;font-size:16px;"><span id="sp'+timeContent+'" >'+timeContent+'</span>\n' +
                                              '</p>\n' +
                                              '</div>');
                }
            }
            $('#ContentDiv_C').css("height",$Model.contentInfo.timeContents.length*36+10+'px');
            $('#ContentDiv_C').on('mouseover','div',function(){
                $(this).css("font-weight","bold");
            });
            $('#ContentDiv_C').on('mouseout','div',function(){
                $(this).css("font-weight","normal");
            });
            $('#ContentDiv_C').on('click','div',function(){
                $scope.queryByCondition($Model,$(this).children("p").children("span").text())
            });
            $scope.queryByCondition($Model,$Model.contentInfo.defaultContent)
            $('#ContentDiv_C').css('display','none');
        }
    });
}
```

#### 案例二

```html
<div id="bottombox">
    <div style="position:absolute;top:74%;right:15%;width:50%;height:2%;z-index:999" class="font14">
        <div id="click1" class="click1 clickable">
            <img id="clickCricle1" alt="" src="images/iopImages/circle_selected.png" class="circlePosition">
            <span id="clickspan1">title1</span>
            <uee:fire event="click" script="clickActCricle($Model,'click1')"></uee:fire>
        </div>
    </div>
</div>
```

```javascript
$scope.clickByCondition = function($Model,type,content){

    $('#sp0_C').text(content);

    $('#ContentDiv_C').slideToggle(300);
    $('#clickCricle1').remove();

    $("#clickspan1").before('<img id="clickCricle1" alt="" src="images/iopImages/circle_selected.png" class="circlePosition">');
}
```

参考：

[jQuery-为动态添加的元素绑定事件](https://blog.csdn.net/xiaozhi_2016/article/details/52184328)

[js为动态添加的元素增加事件（事件委托）](https://blog.csdn.net/badmoonc/article/details/78259219)

### img

`div`只包含一个`img`元素，但是页面展示上`div`却比`img`高出一点 

```html
<!-- html部分 -->
<div class="header-pic">
    <img class="" :src='headPic' />
    <div class="linear-bg"></div>
</div>
```

```javascript
//less代码
.header-pic {
    position: relative;
    border-radius: 10px 10px 0px 0px;
    width: 100%;

    img {
        width: 100%;
        background-size: cover;
    }
    .linear-bg {
        position: absolute;
        left: 0;
        right: 0;
        top: 0;
        height: 100%;
        background: rgba(51,51,51,0.10);
    }
}
```

**问题原因**

> 后来查了一下资料，发现`img`元素后面会跟一个空白符，会使它的高度多出3px
> 至于为什么img元素后面会出现3px的空白呢～？因为`img`元素是行内元素，行内元素默认会有3px的间距。因此当我们的块级元素`div`包含这个行内元素的时候底部就出现了3px的间距。

**解决方案**

> 设置`img`为`display:block`,空白就消失，因为将img元素设置为块级元素，就不会存在默认间距了。

### JQuery

**获取当前标签下的子标签**

1、查找子元素方式1：>
例如：var aNods = $(“ul > a”);查找ul下的所有a标签

2、查找子元素方式2：children()

3、查找子元素方式3：find()

通过下标获取第n个子标签的ID值
1.var num1=$(“ul > a:eq(0)”).attr(“ID”);

2.var num2=$(“ul”).children(“a:eq(0)”).attr(“ID”);

3.var num3=$(“ul”).find(“a:eq(0)”).attr(“ID”);

## SSO

### 流程说明

#### 登录

合法用户首次进入系统：

用户	浏览器			业务子系统				   SSO Server

用户 -> 浏览器(TGC) -> SSO Client(Session)和业务系统 -> SSO Server

1. 用户向浏览器发送请求
2. 浏览器向SSO Client发送请求，SSO_CLIENT过滤出未认证的用户，也就是无法通过Session识别用户，则SSO Client重定向（携带SSO_Server的登录url和用户访问业务的URL）浏览器请求到SSO Server；
   - 其中Session存在如下几种情况：1）用户请求中无SessionID； 2）用户请求中有SessionID，但无SSO_Client的数据（Assertion）；
   - （**已经登录的用户再次进入业务系统**）-> 如果SSO_Client可以从session的得到Assertion数据，认为用户已经登录了，直接将业务请求提交到业务系统第九步。
3. SSO_Server发现该用户没有携带TGC，向用户响应登录页面；
   - （**已经登录的用户进入新的业务系统**）-> 如果浏览器发起的认证请求中携带了TGC，SSO_Server根据TGC关联到用户，根据TGC找到对应的TGT（ST和业务URL纪录在TGT中），判断TGT没有超期，认为用户合法，重定向浏览器到SSO Client并返回一个ST（serive ticket）给浏览器，直接到第六步。
4. 用户在浏览器上输入登录信息，提交到SSO Server。
5. SSO_Server完成认证，根据用户数据生成本次登录的TGT，向浏览器响应，返回该业务的ST和TGC（TGC的值就是TGT的ID），并重定向浏览器请求到SSO Client
6. 浏览器以**cookies的方式记录TGC**，携带ST重定向到SSO Client
7. SSO_Client发现用户请求中包含ticket信息，向SSO Server发起ST票据验证请求。 
8. SSO_Server验证票据是否为认证时为该业务分配的票据，并返回数据给客户端（将TGT中的保存的Assertion返回给client）。
   - 票据验证成功正确，返回用户数据
   - 票据非法，则本次业务认证失败
9. **SSO_Client将用户数据写入Session**中，供业务使用，并将请求提交到业务中，提交方式根据配置有两种：
   - 直接将本次请求提交给业务。
   - 通过rediect方式提交：该方式可以保证sessionid在进入业务之前写入浏览器



**SSO_Server实现单点登录的原理**

根据浏览器携带的TGC判断用户是否登录，如果登录直接放行。否则，呈现登录界面。

浏览器没有TGC，浏览器填写用户到Server认证生成TGC和ST返回给浏览器，有TGC直接返回ST给浏览器

之后始终浏览器获取ticket发送到client再到server认证

**SSO_Client实现单点登录的原理**

根据session判断用户是否登录，如果登录放行，否则，跳转到sso_server。

#### 登出

1. 用户点击业务界面的登出按钮
2. 浏览器向SSO_Server发出登录请求：浏览器会自动携带TGC信息，发起登出请求
3. SSO_Server处理登出请求
   1. 根据TGC找到对应的TGT，从TGT中得到改用户已经登录的所有业务的信息。
   2. 向业务的URL（实际上是SSO Client）发起请求，携带登出logout参数，该参数的中包含登录时分配的ST信息
4. SSO_Client根据消息中携带的logout标识，判断是一个登出请求，注销用户的session，并返回。
   1. SSO_Client判断请求中携带了“logoutRequest”（协议参数）。则认为是一个登出处理。
   2. 根据消息中携带的ST的值，查找出对应的session，将session注销掉。
5. SSO_Server向用户呈现登出界面，并清除TGC，具体的登出界面，在SSO_Server侧根据配置实现。



**TGC:**和一个具有一定有效期的身份证号码相似。

- 是SSO_Server和浏览器之间使用的一个cookies的值，该只在server侧可以唯一标识一个用户。在格式上是一个散列码，能有效防止伪造和攻击。其值的形式如下：TGT-1-w7uJd4E71MeiycjYZCS0KJgvyOwyNm6A0q05Fk1eUmbMjn0OMY-cas
- 根据cookies的协议，TGC只能在SSO_Server和浏览器之间使用。正规的浏览器不能将该TGC传递给sso_client
- TGC对应的数据(TGT)只在Server侧有效，sso_client无法解析TGC的含义

**TGT(Ticket Granting Ticket)**：再服务器侧管理的用户相关的数据，和公安局中管理的用户的户口及档案信息相似。

- TGT的ID为TGC:可以保证由TGC能快速的检索到对应的TGT
- TGT中保存有：
  - 需要返回给业务侧的用户数据：assertion
  - 用户已经等了的业务URL及ST
  - Cookies有效期的有关数据。
- TGT不会给浏览器呈现，可以保证数据安全
- TGT的有效期到期之后，系统会主动注销TGT，保证安全性
- TGT注销之前，会给sso_client发送登出请求



## http

```java
private String getRealIpAttr(HttpServletRequest request) {
    String ip = request.getHeader("x-forwarded-for");
    if (StringUtils.isNotBlank(ip) && ip.contains(",")) {
        ip = ip.split(",")[0];
    }
    if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
        ip = request.getHeader("Proxy-Client-IP");
    }
    if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
        ip = request.getHeader("WL-Proxy-Client-IP");
    }
    if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
        ip = request.getRemoteAddr();
    }
    return ip.equals("0:0:0:0:0:0:0:1") ? "127.0.0.1" : ip;
}
```

[httpServletRequest获取客户端真实ip](https://blog.csdn.net/u014410695/article/details/50162315)

## Gauss

```sql
> su - gtsgsdba -s /bin/bash
> cd app/bin
> zsql / as sysdba -q 
-- > zsql metadb/ABC_abc1@7.220.29.236:15432 -q 使用其他用户登录
> EXP USERS=METADB FILE="/opt/backup/gdbservice/data/metadb_back_20221024.dmp";
> EXP USERS=SERVICEDB FILETYPE=BIN FILE="/opt/backup/gdbservice/data/servicedb_back_20221024.dmp";
-- 其中，斜体部分可根据实际情况配置。
-- /bin/bash和app/bin以现场实际路径为准。
```

- FILETYPE=BIN时，会导出三类文件：元数据文件（用户指定的文件）、数据文件（.D文件）和LOB文件（.L文件）。 

  逻辑导出数据时，会在指定的导出文件路径下生成一个元数据文件和一个名为data的子目录，如果未指定导出文件路径，则默认在当前路径下生成一个元数据文件和一个名为data的子目录。FILETYPE=BIN时，生成的子文件（数据文件、LOB文件）会放在二级目录data下，如果指定的元数据文件和生成的子文件已经存在，则会报错。

- 导出当前用户的tab1和tab2中的数据。`EXP TABLES=tab1,tab2  FILE="file1.dmp";`

```sql
> IMP USERS=SERVICEDB FILETYPE=BIN FILE="/opt/backup/gdbservice/data/servicedb_back_20221024.dmp";
```



## Vue

clear和readonly并存

```vue
<template>
    <div class="pcm" style="width: 80%;margin: 0 auto;padding-top: 20px;background: #fff;padding-bottom: 20px;">
        <el-form ref="channelProdMain" :model="waivePackage" size="small" label-width="100px" :rules="rules" >
            <el-row>
                <el-col span="8">
                    <el-form-item label="减免包" prop="waiveProdName"  width="80px">
                        <el-input v-model="waivePackage.waiveProdName" :title="waivePackage.waiveProdName" placeholder="请选择减免包" :readonly="true" style="width: calc(100% - 31px);" @mouseenter.native="enter" @mouseleave.native="leave">
                        <span slot="suffix">
                            <i class="el-icon-circle-close" v-show="iconShow" @click="clearDataByIcon" style="margin-right: 5px;cursor: pointer;"/>
                        </span>
                        </el-input>
                        <el-button type="text"  @click="chooseDiscountPackage()" v-if="resultVisable">选择</el-button>
                    </el-form-item>
                </el-col>
            </el-row>
        </el-form>
    </div>
</template>

methods: {
        enter(){
            if(this.waivePackage.waiveProdName){
                this.iconShow=true;
            }
        },
        leave(){
            this.iconShow=false;
        },
        clearDataByIcon(){
            this.waivePackage.waiveProdName='';
            this.waivePackage.waiveProdFee=0
            this.getTotalFee();
        }
}


export default {
    data: function () {
        var _this = this
        return {
            iconShow: false
		}
	}
}
```

### 动态路由

$ router是用来操作路由的，$ route是用来获取路由信息的。

```vue
this.$router.push({path:"/describe/${id}"});

<!-- 路由配置 -->
{
	path:'/describe/:id',
	name:'Describe',
	component:Describe
}

<!-- 获取参数 -->
this.$route.params.id
```

```
this.$router.push({
	path:"/CampaignPage",
	query": {
        menuType: menuType
	}
});



import CampaignPage from "@/pages/campaignPage.vue";
Vue.use(Router);
export default new Router({
  routes: [
  	{
      name: "CampaignPage",
      path: "/CampaignPage",
      meta: {
        requireAuth: true
      },
      component: CampaignPage
    }
  ]
});



this.$route.query.menuType
```

[vue动态路由传参](https://blog.csdn.net/weixin_52339077/article/details/125474967)



### JavaScript 对象与 JSON 对象的相互转换

JSON对象有两个方法：stringify() 和 parse()。 

[转换](https://blog.csdn.net/latency_cheng/article/details/73468205)




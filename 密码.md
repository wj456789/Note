# Note

## 密码安全

### 术语说明

| **名词**                                   | **解释**                                                     |
| ------------------------------------------ | ------------------------------------------------------------ |
| 对称算法（Symmetric key algorithm）        | 对称算法采用相同的密钥执行加密或解密。                       |
| 非对称算法（Asymmetric key algorithm）     | 非对称算法（也叫公开密钥算法）是这样设计的：用作加密的密钥不同于用作解密的密钥，而且解密密钥不能根据加密密钥计算出来。加密密钥能够公开，但解密密钥必须保持私密性。任何获得加密密钥的实体都可以加密信息，但只有持有相应的解密密钥的实体才能解密信息。 |
| 哈希函数（Hash function）                  | 是一种将不同长度的数据映射成固定长度数据的函数。             |
| 消息认证码（Message authentication code）  | 密码学上的一种数据校验和，通过使用对称密钥来检测数据是否发生意外或有意的修改。消息认证码简称MAC。 |
| 分组密码（Block cipher）                   | 分组密码是对称算法的一种，它将明文分成多个等长的组，并用相同的算法对每组进行加密。 |
| 流密码（Stream cipher）                    | 流密码也称为序列密码，是对称算法的一种，它是用算法和密钥一起产生一个随机码流，将其与数据流XOR(异或)产生加密后的数据流。 |
| 工作模式（Block cipher mode of operation） | 工作模式是指使用分组密码算法对数据进行加密转换的方法。常见的工作模式有ECB、CBC、CFB、OFB和CTR五种基本加密模式以及CCM、GCM等认证加密模式。 |
| 初始向量（IV，Initialization   Vector）    | 初始向量是许多工作模式中用于随机化加密的一块数据，因此可以由相同的明文、相同的密钥产生不同的密文。 |
| 填充（Padding）                            | 在对消息进行密码运算前的数据规整性处理，使得待保护数据在长度上满足密码算法运算要求，在安全性上也能抵抗相关的密码分析。 |
| 盐值（Salt）                               | 通常由随机数来充当的一段数据，计算口令单向哈希时用于对口令进行加扰，防止彩虹表攻击，盐值无需保密。 |
| 安全强度（Security strength）              | 安全强度用来衡量密码算法或者密码系统的安全性，它是对破解密码算法或者系统所需要的工作量的一个数值度量。 |
| 口令（Password）                           | 口令是指用于身份认证、鉴权或者派生加密密钥的字符串，可由字母、数字和符号组成。 |
| 密钥（Key）                                | 密钥是一个结合密码算法一起使用的参数，只有持有它的实体才能进行相关密码运算（加密、解密、签名、验证等）。 |
| 种子（Seed）                               | 种子是指真随机数产生器的输出                                 |

### 其他

#### 工作模式

- ECB模式：电子密码本模式（Electronic Codebook），是最简单的加密模式，将明文分块后每个块独立加密。 
- CBC模式：密码块链模式（Cipher Block Chaining），每个明文块与前一个密文块进行异或操作后再加密。 
- CFB模式：密码反馈模式（Cipher Feedback），将前一次加密的密文作为输入来加密下一个明文块。 
- OFB模式：输出反馈模式（Output Feedback），将前一次加密的输出作为输入来加密下一个明文块。 
- CTR模式：计数器模式（Counter），将明文块与计数器进行异或操作后再加密。 
- CCM模式：加密认证模式（Counter with CBC-MAC），同时提供加密和认证功能。 
- GCM模式：Galois/Counter Mode，同时提供加密和认证功能，并可以高效地处理大量数据。

#### HMAC

HMAC（Hash-based Message Authentication Code）是一种基于哈希函数的消息认证码，用于验证数据的完整性和真实性。HMAC通过将密钥与消息进行哈希运算来生成一个固定长度的摘要，然后将该摘要与原始消息一起传输。接收方使用相同的密钥和哈希函数对消息进行哈希运算，然后将生成的摘要与传输过来的摘要进行比较，以确定消息是否被篡改或伪造。HMAC常用于网络通信、数字签名和身份验证等领域。 

#### CryptGenRandom

CryptGenRandom是一个Windows API函数，用于生成随机数。它可以用于生成加密密钥、初始化向量和其他加密相关的数据。该函数使用安全随机数生成器来生成随机数，这意味着生成的随机数是高度随机的，不可预测的，并且不会受到外部攻击的影响。 

#### IV

IV是Initialization Vector（初始化向量）的缩写，是分组密码算法中的一个参数。它是一个固定长度的随机数，用于在加密过程中对明文进行初始化，以增强加密的安全性。IV的长度通常与分组密码算法的块长度相同，例如，对于AES算法，IV的长度为128位（16字节）。在加密过程中，IV与密钥一起作为输入，用于生成密文。由于每次加密时IV都是随机的，因此即使相同的明文使用相同的密钥进行多次加密，生成的密文也会是不同的，这增加了攻击者破解密文的难度。 

#### 加密和签名

 加密和签名是两种不同的安全机制，它们的主要区别在于： 

- 加密是将数据转换为密文，以保护数据的机密性，使未经授权的人无法读取数据。而签名则是对数据进行数字签名，以保护数据的完整性和真实性，使接收者能够验证数据的来源和完整性。 
- 加密通常使用对称加密和非对称加密两种方法，对称加密使用相同的密钥进行加密和解密，而非对称加密则使用公钥加密，私钥解密。而签名则使用非对称加密的方法，使用私钥对数据进行签名，使用公钥进行验证。 
- 加密和签名的目的不同，加密主要是为了保护数据的机密性，而签名则是为了保护数据的完整性和真实性。 

总之，加密和签名是两种不同的安全机制，它们的应用场景和目的也不同。加密主要是为了保护数据的机密性，而签名则是为了保护数据的完整性和真实性。 





## 密码算法的选择

#### 禁止使用私有的、非标准的密码算法

l  未经过专业机构评估的、自行设计的密码算法；

l  自行对标准密码算法进行改造的；

l  自行定义的通过变形/字符移位/替换等方式执行的数据转换算法；

l  用编码的方式（如Base64编码）实现数据加密目的的伪加密实现；

l  用差错控制编码（如奇偶校验、CRC）实现完整性校验。

#### 禁止使用不安全的密码算法，推荐使用强密码算法

不安全密码算法比如MD5、DES

| **用途**   | **用途** | **常见不安全密码算法**                                       | **可遗留使用密码算法**                                       | **推荐使用的**   **强密码算法**                              |
| ---------- | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 对称加密   | 分组加密 | Blowfish, DES, DESX,   RC2, Skipjack, 2TDEA, TEA、3DES       |                                                              | AES-GCM(≥128   bits)                                         |
| 对称加密   | 流加密   | SEAL, CYLINK_MEK, RC4                                        |                                                              | AES-CTR(≥128   bits)   AES-OFB(≥128   bits)    chacha20-poly1305 |
| 哈希算法   |          | SHA0, MD2, MD4, MD5, SHA1(数字签名、Hash-only场景),RIPEMD,  RIPEMD-128 | SHA-1(HMAC/密钥派生/随机数产生场景/MGF)*   ,SHA224, SHA512/224,SHA3-224 | SHA256或以上   SHA3-256或以上                                |
| 非对称加密 |          | RSA (< 2048 bits)   ECIES (< 224bits)                        | RSA* (<3072   bits)   ECIES (<256bits)                       | RSA(≥3072 bits)   ECIES (≥256 bits)                          |
| 数字签名   |          | RSA (< 2048 bits)   DSA (同X9.42标准DH)   ECDSA(<224bits)    | RSA(<3072 bits)   DSA(同X9.42标准DH)   ECDSA(<256 bits)      | RSA(≥3072 bits)   DSA(同X9.42标准DH)   ECDSA(≥256 bits)   EdDSA(≥256 bits) |
| 密钥协商   | DH       | L<2048 bits   N*<224   bits                                  | L<3072 bits   N<256 bits                                     | L≥3072 bits   N≥256 bits                                     |
| 密钥协商   | ECDH     | ECDH(< 224bits)                                              | ECDH(<256bits)                                               | ECDH(≥256 bits)                                              |





| **安全强度** | **对称算法** | **离散对数**   **(DSA, DH)** | **大整数分解**   **(RSA)** | 椭圆曲线   (ECDSA**，** ECDH) |
| ------------ | ------------ | ---------------------------- | -------------------------- | ----------------------------- |
| ≤80          | 2TDEA        | L*=1024, N*=160              | K*=1024                    | F*=160-223                    |
| 112          | 3TDEA*       | L=2048, N=224                | K=2048                     | F=224-255                     |
| 128          | AES-128      | L=3072, N=256                | K=3072                     | F=256-383                     |
| 192          | AES-192      | L=7680, N=384                | K=7680                     | F=384-511                     |
| 256          | AES-256      | L=15360,N=512                | K=15360                    | F=512+                        |

- L为公钥的比特长度（群规模的比特长度），N为私钥的比特长度（子群规模的比特长度）
- K为模的比特长度
- F为椭圆曲线基点阶数的比特长度



对称加密算法除了算法本身安全强度，还需要考虑密钥长度及随机性满足算法自身要求，例如AES-128密钥必须采用128比特安全随机数，AES-192必须192比特安全随机数，AES-256必须256比特安全随机数



| **安全强度** | 数字签名/hash-only           | HMAC/密钥派生/随机数产生/MGF                 |
| ------------ | ---------------------------- | -------------------------------------------- |
| ≤80          | SHA-1                        |                                              |
| 112          | SHA224, SHA512/224, SHA3-224 |                                              |
| 128          | SHA256, SHA512/256, SHA3-256 | SHA-1(按照遗留算法执行)                      |
| 192          | SHA384, SHA3-384             | SHA224, SHA512/224                           |
| 256          | SHA512, SHA3-512             | SHA256, SHA512/256, SHA384, SHA512, SHA3-512 |

**安全强度大于等于128可以使用**

#### 在设计阶段就应考虑密码算法使用的敏捷性

不应将算法标识硬编码在应用代码中，可以使用工厂模式去设计一个加密类，这样可以根据实际加密的内容和加密需求来灵活选择加密算法。

常用的算法库（OpenSSL、IPSI、JDK等）中都提供了类似的接口函数，在使用时要尽量使用此类接口。不要将算法标识等参数写死，应从配置文件中读取。

为防止攻击者对密码参数配置文件进行恶意篡改，还应对该配置文件进行访问控制，只允许可信用户进行访问和修改，或者使用HMAC来校验其完整性。

开发人员在设计密文结构时应让密文中包含足够的密码运算参数的信息（如算法标识，密钥ID,IV,盐值等），确保算法更新后，密码算法接口可以根据密文中的密码参数信息正确的解密历史数据，实现应用系统版本的向下兼容。



## 密码算法的应用

### 随机数

#### 密码算法中使用到的随机数必须是密码学意义上的安全随机数

产品可以直接使用真随机数产生器产生的随机数。无法获取足够的真随机数时，也可以使用真随机数产生器产生的少量随机数做种子，输入密码学安全的伪随机数产生器产生大量密码学安全伪随机数。

**密码学安全的非物理真随机数产生器有：**

l  Linux操作系统的/dev/random设备接口

l  Windows操作系统的CryptGenRandom接口

对Linux操作系统下的/dev/random接口，在系统内核没有搜集到足够的外部随机事件时会阻塞，具体阻塞的时间不确定。因此，在某些产品中，直接使用/dev/random会有性能方面的问题



**密码学安全的伪随机数产生器：**

JDK的java.security.SecureRandom



种子在保证密码学安全伪随机数产生器的安全性方面起着至关重要的作用，如果种子本身由于熵值不够导致可以被猜测，则伪随机数产生器产生的随机数序列可能会被预测，从而引入诸如密钥泄露等较为严重的安全问题。各种伪随机数产生器必须设置安全的种子，种子可以由真随机数产生器（包括物理、非物理真随机数产生器）产生。 

| 加密算法库 | 获取随机数             | 设置种子/周期性补充种子 |
| ---------- | ---------------------- | ----------------------- |
| JDK        | SecureRandom.nextBytes | SecureRandom.setSeed    |



种子长度及补充周期。

| DRBG类别            | 子类别  | 种子补充周期                         | 种子长度      |
| ------------------- | ------- | ------------------------------------ | ------------- |
| HASH-DRBG/HMAC-DRBG | SHA-256 | 不超过2^48请求，每次请求最多2^19比特 | 不少于440比特 |
| HASH-DRBG/HMAC-DRBG | SHA-384 | 不超过2^48请求，每次请求最多2^19比特 | 不少于888比特 |
| HASH-DRBG/HMAC-DRBG | SHA-512 | 不超过2^48请求，每次请求最多2^19比特 | 不少于888比特 |
| CTR-DRBG            | AES-128 | 不超过2^48请求，每次请求最多2^19比特 | 不少于256比特 |
| CTR-DRBG            | AES-192 | 不超过2^48请求，每次请求最多2^19比特 | 不少于320比特 |
| CTR-DRBG            | AES-256 | 不超过2^48请求，每次请求最多2^19比特 | 不少于384比特 |

对于随机数消耗频繁的业务场景，除设置初始种子外，周期性补充种子也是必要的。如何补充种子取决于加密算法库对伪随机数产生器的实现方式。如果补充种子是通过回调机制实现，则维护周期计数器的工作由伪随机数产生器来完成，产品需提供回调函数以便为伪随机数产生器提供种子，伪随机数产生器在每个周期结束时调用产品提供的回调函数获取并设置种子。如果加密算法库支持直接（非回调）设置种子接口，则产品可以周期性（周期最大不能超过补充种子周期）地调用设置种子接口来补充种子，此种情况下，推荐产品以尽量小的周期设置种子从而提升伪随机数的安全性。

各加密算法库的伪随机数产生器实现方式不同，其包含的接口也有所不同，但一般都会提供获取随机数接口和设置种子接口，上表列出了常用加密算法库中的这两类接口。

#### 真随机数产生器必须从熵源获取足够的熵值以保证其满熵输出

### 对称密码算法

对称密码算法使用相同的密钥来加密和解密数据。对称算法通过加密来提供机密性保护，通过认证来提供真实性或完整性保护，它包括分组密码算法和流密码算法。使用分组密码算法时要注意工作模式的选取以及IV的使用，使用流密码算法时也要保证每次加密使用不同的IV。算法的使用不当很有可能给系统带来安全隐患。 

#### 使用分组密码算法时，应优先选择GCM模式

ECB模式对于同样的明文块会生成相同的密文块，不能提供严格的数据保密性，不能抵抗替换攻击，攻击者可以调换加密块的顺序而不被发现。因此，应禁止ECB模式直接用于加密目的，HMAC作为检索关键词要保证HMAC明文不重复（如对主键执行HMAC计算）。 

对于CBC模式，除此前已发现的TLS1.0中使用CBC时导致BEAST攻击、SSH中使用CBC导致明文恢复攻击外，HTTP2中也已经把带CBC的加密套件列为黑名单，该模式正逐渐被业界发现在更多的场景中存在安全问题，本规范不再将其列为优先选择模式。对于本地存储加密或加密后发送给数据库存储的场景使用CBC并且每次加密使用了随机IV场景，目前不违反本规则，建议产品尽快考虑未来针对该模式的切换计划，对于新的分组加密场景，产品应优先选择GCM模式。除此之外，禁止标准协议中或自定义协议使用CBC模式。

GCM模式是目前业界推荐使用的对称加密算法工作模式，产品应该根据具体应用场景，存在GCM加密模式时优先使用GCM加密模式。

对于有并行处理、加密认证等明确的特殊需求的，可以选择具备对应特性的工作模式。如下：

- 需要进行认证加密以保证明文或其它认证内容完整性时，应该使用GCM或CCM模式；
- 需要对数据进行并行处理、预计算或者需支持随机访问时，可使用CTR模式；
- 存储设备加密时，可使用XTS-AES模式；
- 图象、语音等信号流加密时，可使用OFB模式，即使信号数据流在传输过程中部分错误也不影响数据流其他部分。

#### 分组密码算法使用到的IV值，必须满足具体加密模式对IV值的要求

**分组加密算法的IV无机密性要求，存储或传输时无需进行加密保护**。但根据NIST SP800-38A标准，对于**CBC、CFB模式， IV在产生之前都不应该被预测出来，对于OFB，GCM，CCM模式，则只须保证IV的唯一性，对于CTR模式，需保证各COUNTER的唯一性**。这里的唯一性是指，对于相同的密钥，每次加密数据的IV各不相同。 

**推荐使用安全的随机数产生不可预测的IV**

对于CBC、CFB、OFB、CTR模式，IV或COUNTER的长度等于对称加密算法的分组长度，具体到AES对称加密算法，长度为16字节。对于GCM模式IV长度可选，推荐采用96比特的IV。

**违反场景及其安全影响：**

| **场景**                     | **影响** |
| ---------------------------- | -------- |
| 使用硬编码IV                 | 高       |
| 使用固定IV                   | 高       |
| CBC、CFB模式IV能够被预测出   | 中       |
| OFB、GCM、CCM未保证IV唯一性  | 中       |
| CTR未保证每个分组COUNTER不同 | 中       |



#### 流密码算法须结合消息认证码校验消息完整性

#### 使用分组加密算法时，填充方式建议选择CMS-Padding 或ISO-Padding

分组加密算法的某些操作模式（如CBC模式）要求明文被填充以保证其长度满足分组长度的整数倍。除需要遵从标准协议（如IPSec中的ESP填充）的场景外，本规范建议选择的填充方式为：CMS-Padding（RFC5652中定义，有些地方称其为PKCS7-Padding）、ISO-Padding（ISO/IEC 7816-4中定义）。

CMS-Padding填充方法为：缺几补几，直到补齐分组，刚好为整分组时视为缺一个整分组。

ISO-Padding填充方式为：先补0x80，后补若干0x00直到补齐分组。

下表为分组长度为16字节（如AES算法）时，明文最后一部分长度和填充字节之间的对应关系。

**明文最后一个分组长度和填充字节对应关系**

| **最后一部分明文长度** | **CMS-Padding** | **ISO-Padding**         |
| ---------------------- | --------------- | ----------------------- |
| 0字节（刚好为整分组）  | 16字节0x10      | 1字节0x80后跟15字节0x00 |
| 1字节                  | 15字节0x0F      | 1字节0x80后跟14字节0x00 |
| 2字节                  | 14字节0x0E      | 1字节0x80后跟13字节0x00 |
| …                      | …               | …                       |
| 14字节                 | 2字节0x02       | 1字节0x80后跟1字节0x00  |
| 15字节                 | 1字节0x01       | 1字节0x80               |

如果产品可以保证明文长度为分组长度的整数倍，加解密时可以选择不做填充，即选择NO-Padding。

### 非对称密码算法

非对称算法主要用于提供数据完整性、真实性和不可抵赖性服务（如数字签名）。RSA算法是使用最广泛的非对称加密算法，常用的数字签名算法有DSA、RSA以及基于椭圆曲线的ECDSA、EdDSA。

#### 非对称加密

- 使用RSA算法时要选取合适的公共指数e
- 使用RSA算法进行加密操作时，禁止PKCS#1_V1.5填充，应使用OAEP填充方式 T-4a
- 使用非对称算法时，加密和签名要使用不同的密钥对

#### 数字签名

- 使用DSA签名时要保证签名的r、s值均不为0
- 在同时需要对数据进行对称加密和数字签名时，使用先签名后加密的方式
- 使用RSA算法进行签名操作时，应禁止PKCS#1_V1.5填充，采用PSS填充方式

#### 密钥协商算法

密钥协商是指采用特定的协议在不同通信实体间共享密钥或密钥材料的过程。DH/ECDH是常见的密钥协商算法。 

- DH密钥协商过程中，双方需对对方的临时公钥值进行验证，以保证临时公钥值不能为某些特殊值，防止简单替换攻击 
- 非信任环境内使用DH/ECDH算法进行密钥协商时，必须确保双方身份的真实性 
- 自定义协议中或者标准协议允许时必须支持DH自定义域参数
- 在使用DH/ECDH进行密钥协商时支持完全前向保密特性

#### 椭圆曲线

推荐使用业界公认安全的椭圆曲线，避免使用NIST定义的椭圆曲线

### 哈希函数

哈希函数将任意长度的输入转换为固定长度的值，哈希算法也叫摘要算法、单向散列算法、数字指纹算法。许多提供安全服务的算法中都将哈希算法做为其算法的一部分。比如数字签名、基于哈希的消息验证码、密钥派生函数和随机数发生器。口令的单向哈希保存也需要用到哈希函数。

#### 对口令进行单向哈希时，必须使用基于口令的密钥派生算法

口令属于个人敏感数据，即使是系统管理员也不应该知道用户的明文口令。所以应只存储口令的单向哈希值。但单纯的口令哈希值，无法防止彩虹表攻击（彩虹表是一个预计算的查找表，用于从口令哈希值破解口令明文）。增加了盐值计算出来的哈希值，可以防止相同口令生成相同的哈希值，但在hashcat这种调用GPU计算资源的暴力破解工具面前，安全性仍不足。所以口令哈希的计算在增加盐值的基础上还要考虑迭代计算。在这种场景下可以使用基于口令的密钥派生算法，如PBKDF2、scrypt，在此基础上，如果具备硬件安全模块，例如HSM、TPM、TEE等，此时利用硬件安全模块内部密钥进一步对PBKDF2、scrypt密文进行HMAC计算能更有效保护口令，此种场景推荐按此方式增强口令存储安全性，但是否使用此种增强保护不受本条规则约束。 

推荐使用PBKDF2。对于scrypt密钥派生算法，由于需要占用较多（可通过参数调整）的内存资源，使得实施并行计算进行破解的成本大大增加，因此通常认为其安全性高于PBKDF2。对于安全性要求非常高并且硬件资源允许的场景，可以使用scrypt。

**PBKDF2算法使用规则：**

l  迭代次数和安全性成正比例，也与计算时间成正比例，迭代次数越大，意味着计算密钥花费时间越长，同时抗暴力破解能力越强，对于性能不敏感或高安全性要求场景推荐迭代次数至少需要10000000次，其它场景迭代次数默认推荐至少10000次，对于性能有特殊要求的产品最低可以迭代1000次

l  哈希函数推荐选择SHA256或更安全的哈希算法；

l  盐值至少16字节，应使用安全的随机数；

l  用于口令单向哈希时，其输出长度应该不小于256比特

**scrypt算法使用规则：**

l  CPU/内存占用参数推荐至少为2的14次方

l  盐值至少16字节，应使用安全的随机数；

l  块规模参数推荐至少为8

l  并行化参数推荐至少为1

l  用于口令单向哈希时，其输出长度应该不小于256比特

#### 禁止在密码协议中使用截短的消息认证码

禁止在密码协议中使用截短的哈希值，下表列出了常用哈希算法及对应HMAC算法标准输出长度，小于此长度时认为是截短的结果。

**常用哈希算法及对应HMAC标准输出长度列表**

| **哈希算法**       | **输出结果长度** |
| ------------------ | ---------------- |
| SHA1/HMAC-SHA1     | 160比特          |
| SHA256/HMAC-SHA256 | 256比特          |
| SHA384/HMAC-SHA384 | 384比特          |
| SHA512/HMAC-SHA512 | 512比特          |

### 消息认证码

消息认证码（MAC）用于保证数据的真实性和完整性。大多数MAC算法都是双方使用相同密钥对双方间交换的消息进行认证。

#### 禁止将hash(key||message)或者hash(message||key)当作MAC来使用 

这种方式是指直接将密钥与消息进行拼接（符号||为拼接）后再进行哈希运算以达到计算MAC的目的。这种方式存在风险，因为安全的MAC函数必须保证其不可伪造性，即在不知道密钥key的情况下，攻击者很难构造出新的消息和其对应的MAC值，但采用这种方式攻击者可以达到这种目的。 

不要将hash(key||message)或hash(message||key)作为MAC来使用，应使用标准的MAC算法（如HMAC或CMAC）。 

#### 在同时进行加密操作和MAC计算时，要使用不同的密钥 

## 密码安全协议

禁止使用SSL2.0、SSL3.0、TLS1.0、TLS1.1协议  

SSH/TLS协议中禁止使用CBC模式

禁止使用SSHv1协议

禁止使用IKEv1协议 、

SSH协议优先选择ECC密钥交换算法和身份认证公钥算法，优先选择HMAC-SHA2消息认证算法 





## 常用加密方案

做法一般是通过用户ID或者其他一些标识按照指定顺序先转成Base64形式，然后再进行MD5或者HMAC进行“加密”（注意啦，加引号啦！）。
通过这些方法形成的16位或者32位的byte值并不是我们所认为的“密文”，而是哈希值！前端传入的数据也会进行相同的处理，然后跟数据库存储的哈希值进行比较，而不是想象中后端会先解密，再比较！
至于大家所说的，MD5可以使用彩虹表等方式暴力破解，其实也很好解决，最常用的方法就是加盐！

但如果直接MD5那就一定不安全吗？那只是数据层面不安全，如果别人拿到了数据库，那么就可以直接对数据库里面的MD5的HASH值进行暴力破解。
这个的确是的，但别人得拿到你的数据库才行，如果单纯从接口层面，其实应对方案还是挺多的！比如说大家都比较常见的方案就是密码连续输入错误3次就锁定登录，异地登录需要短信验证等等，都可以避免使用MD5对密码进行暴力破解。
因为MD5的暴力破解原理很简单，其实就是碰，只要密码不是那种“123456”这种简单的形式，以上两种限制已经足够能够应对MD5的暴力破解了！



：“如果MD5被用作密码加密，且这种加密是不可逆的，那么你怎么解释有些网站在修改密码时，输入密码时会提示‘新密码和旧密码相似度太高！’”。
我的想法是，在用户注册账号密码时，密码先会被整体HASH，然后，再将密码按照指定规则进行拆分，拆分的部分再进行HASH，然后将拆分出来的HASH值再单独存储，在修改时，再按照拆分规则对新密码的拆分HASH跟旧密码的拆分HASH进行比对，设置一个相似比例，超过相似比例再报相似度太高的提醒就可以了。






























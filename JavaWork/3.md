

## Normalizer.normalize()

normalize方法对外部输入字符串做归一化/标准化处理，如：

```java
//将全角形式的字符转化为半角形式的字符，"＜root＞"-->"<root>"
Normalizer.normalize(str,Normalizer.Form.NFKC);
```

[关于Normalizer.normalize()方法的用途](https://blog.csdn.net/u010512607/article/details/79921353)

## Path



## Java基础

### java -cp命令

jvm搜索类，系统会先在当前包下找，然后会在 jre 中的 rt.jar 文件下找，最后会在 classpath 所指向的路径下找； -cp 即 -classpath，可以指定classpath；java -cp 和 -classpath 一样，是指定类运行所依赖其他类的路径，通常是类库，jar包之类，需要全路径到jar包 。

```sh
#windows
#编译
$ javac -cp 绝对路径1.jar;绝对路径2.jar java文件名.java

#运行
$ java -cp .;../lib/*;../common.jar;../list/*.jar;../conf packname.mainclassname(此类有main方法)
```

```sh
#linux
#编译
$ javac -cp 绝对路径1.jar:绝对路径2.jar java文件名.java

#运行
$ java -cp .:../lib/*:../common.jar:../list/*.jar:../conf packname.mainclassname(此类有main方法)
```



### 引用 jar 包中的 jar 包

 [java命令执行jar包的方式](https://www.cnblogs.com/zpbolgs/p/7267384.html)

### 启动 jar 包

jar 包内目录 META-INF 下的 MANIFEST.MF 文件可以指定入口的方法，

```java
//META-INF\MANIFEST.MF的内容：
Manifest-Version: 1.0 
Main-Class: test.core.Core 
```

```sh
#pom中build指定mainClass && META-INF\MANIFEST.MF文件中增加了Main-Class: test.core.Core
$ java -cp test-jar-with-dependencies.jar  test.core.Core  //执行成功
$ java -jar test-jar-with-dependencies.jar  //执行成功
```

[启动jar包](https://www.cnblogs.com/klb561/p/10850803.html)



## Spring

### @GetMapping和@RequestBody

一般的情况下，GET请求是不可以用@RequestBody来接收参数的。Http请求包含请求头和请求体，如果发出的请求中请求体为空，那么无法使用@RequestBody注解来获取参数。

那么在什么情况下可以配合使用呢？需要两个条件，一是请求方式为GET，二是请求参数写入请求体中。即接口需要被上层的服务调用而非页面直接访问。由于目前微服务的运用越来越多，所以一般像这样的情况在实际的开发中会变得常见。

```sh
# 可以使用curl命令测试
$ curl -XGET -H "Content-Type:application/json" "http://host:port/requestmapping" -d '{"paramId":[1,2,3]}'
```



## 数据结构

### String.join

```java
public static void main(String[] args) {
    Stack<String> path = new Stack<>();
    path.push("1");
    path.push("2");
    path.push("3");
    path.push("4");
    System.out.println(("/" + String.join("/", path)));

    Deque<String> deque=new LinkedList<>();
    deque.push("1");
    deque.push("2");
    deque.push("3");
    deque.push("4");
    deque.offer("5");
    deque.offer("6");
    deque.offer("7");
    deque.offer("8");
    System.out.println(("/" + String.join("/", deque)));
}

输出：
/1/2/3/4
/4/3/2/1/5/6/7/8
```

如果栈和队列都使用数组实现底层，代码插入：

**栈：**

s[0] s[1] s[2] s[3]

1	2	3	4

本质push是在数组尾部插入

**队列：**

d[0] d[1] d[2] d[3] d[4] d[5] d[6] d[7]

4	3	2	1	5	6	7	8

本质push是在数组头部插入，offer在数组尾部插入

**String.join**

是从数组头部链接到尾部

### 队列

```java
public static void main(String[] args) {
    Deque<String> list = new LinkedList<>();
    list.addFirst("1");
    list.addLast("2");
    list.removeFirst();
    list.removeLast();

    list.offerFirst("3");
    list.offerLast("4");
    list.pollFirst();
    list.pollLast();

    //push 和 pop都在头部操作
    list.push("5");
    list.pop();

    list.add("6");//尾部添加
    list.remove();//头部删除

    list.offer("7");//尾部添加
    list.poll();//头部删除
    
    //ArrayDeque使用和LinkedList完全相同，但是常当作栈来使用
    Deque<String> arrayDeque=new ArrayDeque<>();
    arrayDeque.push("1");
    arrayDeque.pop();
}
```

## Scanner

```
nextInt()获取输入的一个int值，以空格隔开，空格可以为多个

nextLine()获取回车之前的一行字符串，包括空格

next()以回车或空格为间隔获取下一个字符串，空格可以为多个，空格和回车放在一起视为一个
```

```java
8 9
qweqw

读取可以使用 nextInt()读8 nextInt()读9 nextLine()换行 nextLine()读qweqw
```



## 进制

数字的二进制使用数字的补码表示，其中正数和 0 的补码就是该数字本身，负数的补码则是将其对应正数按位取反再加1 

### String

```java
System.out.println(String.format("%8s","asd"));
输出：     asd
```



## Leecode

### 设备编号 

> 题目描述
>
> 给定一个设备编号区间[start, end]，包含`4`或`18`的编号都不能使用，如：418、148、718不能使用，108可用。
>
> 请问有多少可用设备编号。
>
> 解答要求时间限制：1000ms, 内存限制：256MB
>
> 输入
>
> 两个整数`start end`(单空格间隔)，用于标识设备编号区间，0 < start < end <= 100000
>
> 输出
>
> 一个整数，代表可用设备编号的数量
>
> 样例
>
> 输入样例 1 复制
>
> ```
> 3 20
> ```
>
> 输出样例 1
>
> ```
> 15
> ```
>
> 提示样例 1
>
> 不能使用的设备编号为4、14、18
>
> 输入样例 2 复制
>
> ```
> 1 1000
> ```
>
> 输出样例 2
>
> ```
> 711
> ```
>
> 提示样例 2

**问题分析**

关键是将不可用的编号过滤掉，可以转换为字符串进行处理
正则，包含都可以；
正则表达式：`\\d*4\\d*|\\d*18\\d*`
包含：`num.contains("4") || num.contains("18")`

**实现**

```java
import java.util.*;
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

/**
 * OJ考题代码：设备编号
 *
 * @author 命题组
 * @since 2020-3-3
 */
public class Main {
    /**
     * main入口由OJ平台调用
     */
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in, StandardCharsets.UTF_8.name());
        int start = cin.nextInt();
        int end = cin.nextInt();
        cin.close();

        System.out.println(getNormalDeviceNum(start, end));
    }

    // 待实现函数，在此函数中填入答题代码
    public int getNormalDeviceNum(int start, int end) {
        int[] intArr = new int[end - start + 1];
        Arrays.setAll(intArr, i -> i + start);
        return Arrays.stream(intArr).map(i -> String.valueOf(i).matches("\\d*4\\d*|\\d*18\\d*") ? 0 : 1).sum();
    }
}
```



### 服务器集群网络延迟 

> 题目描述
>
> 给定一个正整数数组表示某服务器集群内服务器的机位编号，请选择一台服务器作为主服务器，使得集群网络延迟最小，并返回该最小值。
>
> - 每台服务器有唯一的机位编号。
> - 两服务器之间的网络延迟，可以简单用所在机位编号之差的绝对值表示；服务器到自身的延迟为0。
> - 集群网络延迟是指主服务器与所有服务器的网络延迟之和。
>
> 解答要求时间限制：1000ms, 内存限制：256MB
>
> 输入
>
> 第一行整数 n，代表数组元素的个数，取值范围：[1, 500]。
> 第二行是n个数值，表示上述数组的元素（单个空格间隔），取值范围: [1, 10000]。
>
> 输出
>
> 一个整数，表示集群网络延迟的最小值。
>
> 样例
>
> 输入样例 1 复制
>
> ```
> 3
> 2 6 4
> ```
>
> 输出样例 1
>
> ```
> 4
> ```
>
> 提示样例 1
>
> 选择机位编号为4的服务器作为主服务器，集群网络延迟最小：|2-4| + |4-6| = 4。
>
> 输入样例 2 复制
>
> ```
> 4
> 2 4 3 1
> ```
>
> 输出样例 2
>
> ```
> 4
> ```
>
> 提示样例 2
>
> 选择机位编号为2或者3的服务器作为主服务器，集群网络延迟最小，值为4。

**暴力解法思路**

计算每个设备作为主服务器的延迟结果，将最小的返回；

代码

```java
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in, StandardCharsets.UTF_8.name());
        int line = cin.nextInt();
        int[] input = new int[line];
        for (int i = 0; i < line; i++) {
            input[i] = cin.nextInt();
        }
        cin.close();
        int result = clusterLatency(input);
        System.out.println(result);
    }

    private static int clusterLatency(int[] arr) {
        return Arrays.stream(arr)
                .map(item -> Arrays.stream(arr).map(i -> Math.abs(i - item)).sum())
                .min()
                .orElse(Integer.MIN_VALUE);
    }
}
```

**优化**

中位数的值即为最终结果；

> 为什么是中位数？
> 可以使用数学上的三步证明法，在只有1，或2时，跳过；
> 在有三个时，所得结果是中间的那个，因为取值为中间时，结果就是最大值与最小值的差；
> 可以依次证明；

优化后代码

```java
Arrays.sort(arr);
        return Arrays.stream(arr)
                .map(item -> Math.abs(arr[arr.length / 2] - item)).sum();
```

### 给定差值的组合 

> 题目描述
>
> 给定一个数组，每个元素的值是唯一的，找出其中两个元素相减等于给定差值 diff 的所有不同组合的个数。
>
> - 组合是无序的：如：（1, 4)和(4, 1)表示的是同一个组合。
>
> 解答要求时间限制：1000ms, 内存限制：256MB
>
> 输入
>
> 输入三行:
> 第一行为一个整数，表示给定差值diff；范围[-50000, 50000]
> 第二行也为一个数字，表示数组的长度；范围[2, 102400]
> 第三行为该数组，由单个空格分割的一组数字组成；其中元素的值范围[-20, 102400]
>
> 用例保证第三行数字和空格组成的字符串长度不超过 649999
>
> 输出
>
> 1个整数，表示满足要求的不同组合的个数
>
> 样例
>
> 输入样例 1 复制
>
> ```
> 3
> 5
> 1 3 2 5 4
> ```
>
> 输出样例 1
>
> ```
> 2
> ```
>
> 提示样例 1
>
> 数组为[1 3 2 5 4]， 差值 diff 为 3，其中 4 - 1 = 3，5 - 2 = 3，共 2 个组合满足条件，因此输出 2
>
> 输入样例 2 复制
>
> ```
> -1
> 3
> 1 2 3
> ```
>
> 输出样例 2
>
> ```
> 2
> ```
>
> 提示样例 2
>
> 其中 1 - 2 = -1，2 - 3 = -1，共 2 个组合满足条件，因此输出 2。

**两种解法：HashSet和双指针**

解题思路：暴力循环的话会超时，无法全部通过，因此需要借助其他方式解答。
方法一：数据结构 HashSet
将数组中所有的值添加到set中，然后遍历一遍数组，通过set判断是否存在差值。

```java
import java.nio.charset.StandardCharsets;
import java.util.Scanner;

/**
 * OJ考题代码：满足差为s的组合
 *
 * @author 命题组
 * @since 2020-03-20
 */
public class Main {
    /**
     * main入口由OJ平台调用
     */
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in, StandardCharsets.UTF_8.name());
        int diff = cin.nextInt();
        int line = cin.nextInt();
        int[] arr = new int[line];
        for (int i = 0; i < line; i++) {
            arr[i] = cin.nextInt();
        }
        cin.close();
        int result = proc(arr, diff);
        System.out.println(result);
    }

    // 待实现函数，在此函数中填入答题代码
    private static int proc(int[] arr, int diff) {
        int res = 0;
        HashSet<Integer> set = new HashSet<>();
        for(int num : arr){
            set.add(num);
        }
        for(int num : arr){
            if(diff > 0 && set.contains(num - diff)){
                res++;
            }
            if(diff < 0 && set.contains(num + diff)){
                res++;
            }
        }
        return res;
    }
}
```

方法2：常规解法，双指针

```java
private static int proc(int[] arr, int diff) {
    Arrays.sort(arr);
    int diffN = Math.abs(diff);
    int total = 0;
    int left = 0;
    int right = 1;
    while (right < arr.length) {
        int compare = arr[right] - arr[left];
        if (compare == diffN) {
            // 排除diff为0
            if (left != right) {
                total++;
            }
            left++;
            right++;
        } else if (compare < diffN) {
            right++;
        } else {
            left++;
        }
    }
    return total;
}
```

### 简易Linux路径解析 （中等）

> 题目描述
>
> 某简易的linux目录系统 cd 命令（change directory）功能如下：
>
> - `cd` ：进入home目录`/home/user`；
> - `cd -`：进入上一次停留的目录（连续两个以上 cd - 会在两个目录之间来回跳转，而不是回到更早之前的目录）；
> - `cd <绝对路径>`：以 `/` 开头的为绝对路径；
> - `cd <相对路径>`：不以`/`开头的为相对路径；
>
> 现给定一批 cd 命令，命令格式及相关假设如下：
>
> - 单独的`/`表示根目录，且为系统默认的初始目录；
> - `////a`表示目录`/a`，即这种格式中的多个 / 等价于一个 / ；
> - 特殊目录`.` ，表示当前层次目录，例如`/a/.` 表示目录`/a`；
> - 特殊目录`..`，表示当前层次目录的父目录（根目录的父目录仍为根），例如`/a/..`表示目录`/`；
> - 假设不会出现第一个命令为`cd -`的情况；
>
> 请计算所有命令执行结束后的最终目录，并格式化输出其绝对路径：
>
> - 必须以`/`开头，不以`/`结尾（除根目录外）；
> - 不允许特殊目录`.`、`..`，不允许连续的`/`，需转化为所表示的目录；
>
> 解答要求时间限制：1000ms, 内存限制：128MB
>
> 输入
>
> 首行一个整数 n，表示 cd 命令的个数，取值范围：[1,100]
> 接下来 n 行，每行一条 cd 命令，长度范围 [1, 100]，其中目录名仅由小写英文字母 [a-z] 组成
>
> > 假设：
> >
> > - 设目录总长度 < 10000
> > - 命令中的目录都是存在的
> > - 命令格式都符合规则
>
> 输出
>
> 一个字符串，表示最终目录的绝对路径。
>
> 样例
>
> 输入样例 1 复制
>
> ```
> 3
> cd /aa/bb/cc/dd/
> cd ./ee/ff
> cd gg/../hh
> ```
>
> 输出样例 1
>
> ```
> /aa/bb/cc/dd/ee/ff/hh
> ```
>
> 提示样例 1
>
> 默认目录在 / ，各条命令执行情况如下：
>
> - 第一条：路径名以 / 开头表示绝对路径，执行后当前目录为 /aa/bb/cc/dd/
> - 第二条：路径名不以 / 开头表示相对路径，进入当前目录的下层目录，执行后当前目录为 /aa/bb/cc/dd/ee/ff
> - 第三条：路径名不以 / 开头表示相对路径，gg/../hh 表示先进入下层目录 gg，接着返回 gg 的上层目录即当前目录，然后进入下层目录 hh， 因此最终目录为 /aa/bb/cc/dd/ee/ff/hh
>
> 输入样例 2 复制
>
> ```
> 2
> cd
> cd ..
> ```
>
> 输出样例 2
>
> ```
> /home
> ```
>
> 提示样例 2
>
> 第一条：进入home目录 /home/user
> 第二条：进入当前目录的父目录即 /home
>
> 输入样例 3 复制
>
> ```
> 3
> cd /aa////bb//
> cd ..
> cd -
> ```
>
> 输出样例 3
>
> ```
> /aa/bb
> ```
>
> 提示样例 3
>
> 第一条：多个 / 等价于一个，当前目录为 /aa/bb
> 第二条：进入父目录后当前目录为 /aa，上一次停留的目录为 /aa/bb
> 第三条：进入上一次停留的目录，最终目录为 /aa/bb

```java
// 待实现函数，在此函数中填入答题代码
private static String getCurrentDirectory(String[] cmds) {
    Stack<String> stack = new Stack<>();
    stack.push("/");
    for (int i = 0; i < cmds.length; i++) {
        String curCmd = cmds[i].equals("cd") ? "/home/user" : cmds[i].substring(3);
        String curPath = stack.peek();
        if (curCmd.startsWith("/")) {
            curPath = curCmd;
        } else if (curCmd.startsWith("-")) {
            if (stack.size() == 1) { // 坑！！用例中有第一个为cd -的情况，但题目中说没有
                curPath = "/";
            } else { // 把栈顶和次定位置交换，保证多次cd -能循环起来
                String tmp = stack.pop(); // 当前目录弹出
                curPath = stack.peek(); // 取的是上一次目录
                stack.push(tmp); // 再把当前目录放进去（下面再push curPath之后就变成了倒数第二个）
            }
        } else {
            curPath = curPath + "/" + curCmd;
        }
        curPath = processString(curPath);
        stack.push(curPath);
    }
    return stack.peek();
}
private static String processString(String cmd) {
    if (cmd.equals("/")) {
        return cmd;
    }
    Stack<String> path = new Stack<>(); // 用队列也可以
    String[] cur = cmd.split("/");
    for (int i = 0; i < cur.length; i++) {
        if (cur[i].equals("") || cur[i].equals(".") 
            || (cur[i].equals("..") && path.isEmpty())) {
            continue;
        }
        if (cur[i].equals("..") && !path.isEmpty()) {
            path.pop();
            continue;
        }
        path.push(cur[i]);
    }
    return "/" + String.join("/", path); // 注意前缀
}


// main入口由OJ平台调用
public static void main(String[] args) {
    Scanner cin = new Scanner(System.in, StandardCharsets.UTF_8.name());
    int row = cin.nextInt();
    cin.nextLine();
    String[] cmds = new String[row];
    for (int i = 0; i < row; i++) {
        cmds[i] = cin.nextLine();
    }
    cin.close();
    String result = getCurrentDirectory(cmds);
    System.out.println(result);
}
```

### 关键字标识 （中等）

> 给定一个关键词集合 words 和一个字符串 inputStr，要求将 inputStr 中出现的所有关键词用标签标记： 
>
> - 关键词标签的起始为<b>,结束为</b>。
> - 把可以合并的标签进行合并，即使用最少的标签。合并规则如下： 
>   - 关键词相邻则进行合并，如 ab、cd为关键词，且在字符串中相邻，则合并为 <b>abcd</b>
>   - 关键词相交则进行合并，如 zhi、hid为关键词，且在字符串中相交，则合并为 <b>zhid</b>
>
> 解答要求时间限制：1000ms, 内存限制：256MB
>
> 输入
>
> 第1行一个整数 count，表示 words 中的关键词的个数，取值范围：[1, 64]
> 第2行 count 个字符串，表示关键字词列表 words，每个关键词仅含英文小写字母，长度范围：[1,16]
> 第3行一个字符串 inputStr，仅含英文小写字母（无空格），长度范围：[1,512]
>
> 输出
>
> 一个用最少关键词标签标记的字符串
>
> 样例
>
> 输入样例 1 复制
>
> ```
> 4
> cd df op qr
> opqracdfg
> ```
>
> 输出样例 1
>
> ```
> <b>opqr</b>a<b>cdf</b>g
> ```
>
> 提示样例 1
>
> - 关键词 op qr 出现在字符串中，且在字符串中相邻，因此可合并为 opqr；
> - cd df 出现在字符串中，且在字符串中相交，因此可合并为 cdf ；
> - 其它字符保持不变。
>
> 处理后为 `<b>opqr</b>a<b>cdf</b>g`，使用了 2 个标签 。
> `<b>op</b><b>qr</b>a<b>cd</b><b>df</b>g`也是一种标记方式，但关键词未作合并，需要用到 4 个标签，标签个数不是最少的。
>
> 输入样例 2 复制
>
> ```
> 3
> abbb def bbg
> aabbbgz
> ```
>
> 输出样例 2
>
> ```
> a<b>abbbg</b>z
> ```
>
> 提示样例 2
>
> 关键字abbb和bbg合并为abbbg

```java
public class main {
    // 待实现函数，在此函数中填入答题代码
    private static String getTaggedString(String[] words, String inputStr) {
        ArrayList indexList = new ArrayList<>();  
        for (String word : words) {
            // String regEx = ".*" + word + ".*";
            Pattern p = Pattern.compile(word);
            Matcher m = p.matcher(inputStr);
            while (m.find()) {
                int start = m.start();
                int end = m.end();
                indexList.add(new Integer[] {start, end});
            }
        }
        indexList.sort((o1, o2) -> (o1[0] - o2[0]));
        int i = 0;
        int size = indexList.size();
        while (i < size - 1) {
            int oneStart = indexList.get(i)[0];
            int oneEnd = indexList.get(i)[1];
            int secondStart = indexList.get(i + 1)[0];
            int secondEnd = indexList.get(i + 1)[1];
            if (secondStart <= oneEnd) {
                indexList.remove(i);
                indexList.remove(i);
                indexList.add(i, new Integer[] {oneStart, secondEnd >= oneEnd ? secondEnd : oneEnd});
                size = indexList.size();
                i = 0;
                continue;
            }
            i++;
        }
        StringBuilder result = new StringBuilder();
        int index = 0;
        for (Integer[] integers : indexList) {
            int start = integers[0];
            int end = integers[1];
            result.append(inputStr.substring(index, start))
                .append("<b>")
                .append(inputStr.substring(start, end))
                .append("</b>");
            index = end;
        }
        result.append(inputStr.substring(index));
        return result.toString();
    }
    // main入口由OJ平台调用
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in, StandardCharsets.UTF_8.name());
        cin.nextLine();
        String[] words = cin.nextLine().split(" ");
        String inputStr = cin.nextLine();
        cin.close();
        String result = getTaggedString(words, inputStr);
        System.out.println(result);
    }
}
```

### 简单负载均衡 （中等）

> 题目描述
>
> 某工程师为了解决服务器负载过高的问题，决定使用多个服务器来分担请求消息。
>
> 现给定 k 台服务器（编号从 1 到 k），以及一批请求消息的信息，格式为`到达时刻 负载大小`，消息说明：
>
> - 每个时刻最多只有一条消息到达；
> - 负载大小表示服务器处理该消息所需时长。
>
> 请计算在负载分担规则下，哪些服务器处理的负载最高（服务器处理的负载为所处理的所有消息的负载累加和），并以升序返回这些服务器的编号。
>
> > 负载分担规则：
> >
> > - 按顺序循环分配服务器，如：有3台服务器且都空闲，分配的方式为 1->2->3->1… ；
> > - 如果某台服务器繁忙，则跳过该服务器；
> > - 如果一条消息到达时所有服务器繁忙，则丢弃这条消息。
>
> 解答要求时间限制：1000ms, 内存限制：512MB
>
> 输入
>
> 第一行为服务器的个数 k，k 的范围 [1, 50000]
> 第二行为请求消息个数 n，n 的范围 [1, 50000]
> 随后的 n 行为各条消息的到达时刻和负载大小（注意并非按到达时刻升序给出）。
> 消息到达时刻的范围 [1, 10^9]，负载大小的范围 [1, 10^9]
>
> 输出
>
> 处理负载最多的服务器编号，注意按升序输出。
>
> 样例
>
> 输入样例 1 复制
>
> ```
> 3
> 7
> 1 15
> 2 10
> 12 10
> 5 10
> 6 10
> 30 15
> 32 10
> ```
>
> 输出样例 1
>
> ```
> 1 3
> ```
>
> 提示样例 1
>
> 根据输入信息，经过分析可得以下表：
>
> | 到达时刻 | 消息负载 | 完成时刻（不包含） | 分配服务器号 |
> | -------- | -------- | ------------------ | ------------ |
> | 1        | 15       | 16                 | 1            |
> | 2        | 10       | 12                 | 2            |
> | 5        | 10       | 15                 | 3            |
> | 6        | 10       | 16                 | 丢弃         |
> | 12       | 10       | 22                 | 2            |
> | 30       | 15       | 45                 | 3            |
> | 32       | 10       | 42                 | 1            |
>
> 根据上表分析，1和3号服务器处理的负载都为25，按照升序排列，输出的结果为:
> 1 3

```java
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Scanner;

/**
 * OJ考题代码：简单负载均衡
 *
 * @author 命题组
 * @since 2020-01-07
 */
public class Main {
    // 待实现函数，在此函数中填入答题代码
    static int[] findHighestLoadServers(int serverNum, Message[] messages) {
        Arrays.sort(messages, Comparator.comparingInt(o -> o.time));

        int[] messageLoadTotal = new int[serverNum];
        int[] overTime = new int[serverNum];
        int serverN = 0;
        for (Message message : messages) {
            for (int i = 0; i < serverNum; i++) {
                if (message.time >= overTime[serverN]) {
                    messageLoadTotal[serverN] += message.load;
                    overTime[serverN] = message.time + message.load;
                    serverN = (serverN + 1) % serverNum;
                    break;
                }
                serverN = (serverN + 1) % serverNum;
            }
        }

        List<Integer> list = new ArrayList<>();
        int maxLoad = 0;
        for (int i = 0; i < messageLoadTotal.length; i++) {
            if (messageLoadTotal[i] > maxLoad) {
                list.clear();
                maxLoad = messageLoadTotal[i];
                list.add(i + 1);
            } else if (messageLoadTotal[i] == maxLoad) {
                list.add(i + 1);
            }
        }
        return list.stream().sorted().mapToInt(Integer::new).toArray();
    }

    static class Message {
        int time;
        int load;
    }

    // main入口由OJ平台调用
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in, StandardCharsets.UTF_8.name());
        int serverNum = cin.nextInt();
        int messageNum = cin.nextInt();
        Message[] messages = new Message[messageNum];
        for (int i = 0; i < messages.length; i++) {
            Message message = new Message();
            message.time = cin.nextInt();
            message.load = cin.nextInt();
            messages[i] = message;
        }

        cin.close();

        int[] highestLoadServers = findHighestLoadServers(serverNum, messages);
        String[] strResult = Arrays.stream(highestLoadServers).mapToObj(String::valueOf).toArray(String[]::new);
        System.out.println(String.join(" ", strResult));
    }
}
```

### 单板告警统计（简单）

> 题目描述
>
> 假设某系统中有两块单板，这两块单板上产生的告警ID（以十六进制字符串表示）分别存储在列表 arrayA 和列表arrayB 中。
> 请统计并输出系统中的所有告警ID（即arrayA和arrayB的并集）：
>
> - 如果告警ID存在重复，先需去重。
> - 然后以告警ID所表示值的升序排序输出
>
> 解答要求时间限制：1000ms, 内存限制：256MB
>
> 输入
>
> 第一行1个整数，表示告警列表arrayA的长度，取值范围为：[0,1000]
> 第二行表示告警列表arrayA的数据，告警ID以单空格分隔
> 第三行1个整数，表示告警列表arrayB的长度，取值范围为：[0,1000]
> 第四行表示告警列表arrayB的数据，告警ID以单空格分隔
>
> > 告警ID为无符号整数，以十六进制字符串表示，由数字字符、大写字母A~F组成，固定为 8 个字符。
>
> 输出
>
> 按升序排序的告警ID，以单空格分隔
>
> 样例
>
> 输入样例 1 复制
>
> ```
> 2
> 00001001 00ABCD00
> 3
> FFFFFAAB FFFFFAAB 00ABCD00
> ```
>
> 输出样例 1
>
> ```
> [00001001 00ABCD00 FFFFFAAB]
> ```
>
> 提示样例 1
>
> 系统中共有三个告警ID：
> 00ABCD00，去重后保留一个；
> FFFFFAAB，去重后保留一个；
> 00001001，只有一个。
> 按所表示值的大小升序排列，输出这三个告警ID为 [00001001 00ABCD00 FFFFFAAB] 。
>
>  
>
>  
>
> 输入样例 2 复制
>
> ```
> 0
> 
> 1
> FFFFFAAB
> ```
>
> 输出样例 2
>
> ```
> [FFFFFAAB]
> ```
>
> 提示样例 2

```java
public class Main {
    // 待实现函数，在此函数中填入答题代码   
    private static String[] getAllFault(String[] arrayA, String[] arrayB) {
        Set<String> setA = new HashSet<>(Arrays.asList(arrayA));
        Set<String> setB = new HashSet<>(Arrays.asList(arrayB));
        setA.addAll(setB);
        String[] res = setA.toArray(new String[setA.size()]);
        Arrays.sort(res);
        return res;
    }

    // main入口由OJ平台调用
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in, StandardCharsets.UTF_8.name());
        int arrayALen = Integer.parseInt(cin.nextLine().trim());
        String[] arrayA = new String[0];
        if (arrayALen > 0) {
            arrayA = cin.nextLine().trim().split(" ");
        } else {
            cin.nextLine();
        }
        int arrayBLen = Integer.parseInt(cin.nextLine().trim());
        String[] arrayB = new String[0];
        if (arrayBLen > 0) {
            arrayB = cin.nextLine().trim().split(" ");
        }
        cin.close();

        String[] result = getAllFault(arrayA, arrayB);
        System.out.print("[" + String.join(" ", result) + "]");
    }
}
```

### 大小端整数（简单）

> 题目描述
>
> 计算机中对整型数据的表示有两种方式：大端序和小端序，大端序的高位字节在低地址，小端序的高位字节在高地址。例如：对数字 65538，其4字节表示的大端序内容为`00 01 00 02`，小端序内容为`02 00 01 00`。
>
> 现输入一个字符串表示的十进制整数（含负数），请分别输出以4字节表示的大端序和小端序：
>
> - 负数以补码形式表示。
> - 如果输入的整数的值超出 [-2^31, 2^32) 范围，则输出字符串`overflow`。
>
> 解答要求时间限制：1000ms, 内存限制：64MB
>
> 输入
>
> 十进制整数，以负号`-`开头表示负数，其它为正整数；数字长度范围：[1,32]。
>
> > 输入数字不含前导零。
>
> 输出
>
> 大端序 + `\n` + 小端序；或字符串`overflow`。
>
> > 大端序和小端序的输出格式：每个字节以两位16进制数字表示（16进制数中A-F要大写），字节之间以单空格分隔。
>
> 样例
>
> 输入样例 1 复制
>
> ```
> -10
> ```
>
> 输出样例 1
>
> ```
> FF FF FF F6
> F6 FF FF FF
> ```
>
> 提示样例 1
>
> 含负号表示为负整数。
> 该负整数的补码表示为 FF FF FF F6，其对应大端序和小端序内容分别为`FF FF FF F6` 和 `F6 FF FF FF`。
> 按输出格式要求输出其大端序和小端序内容，中间加换行符。
>
>  
>
>  
>
> 输入样例 2 复制
>
> ```
> 4027691818
> ```
>
> 输出样例 2
>
> ```
> F0 11 B3 2A
> 2A B3 11 F0
> ```
>
> 提示样例 2
>
> 输入 4027691818 为正整数，按输出格式要求输出其大端序和小端序内容，中间加换行符。
>
>  
>
>  
>
> 输入样例 3 复制
>
> ```
> 1234567890123456789012345678900
> ```
>
> 输出样例 3
>
> ```
> overflow
> ```
>
> 提示样例 3
>
> 输入数字超过[-2^31, 2^32) 范围，因此输出 overflow 。
>
> 提示
>
> 补码是一种用二进制表示有号数的方法，正数和 0 的补码就是该数字本身，负数的补码则是将其对应正数按位取反再加1。

```java
private static String getHexString(String num) {
    Long result;
    try {
        result = Long.parseLong(num);
    } catch (NumberFormatException e) {
        return "overflow";
    }
    if (result < Integer.MIN_VALUE || result / 2 > Integer.MAX_VALUE) {
        return "overflow";
    }
    String HexStr;
    if (result >= Integer.MIN_VALUE && result <= Integer.MAX_VALUE) {
        HexStr = String.format("%8s", Integer.toHexString(result.intValue()).toUpperCase(Locale.ROOT)).replace(" ", "0");
    } else {
        HexStr = String.format("%8s", Long.toHexString(result).toUpperCase(Locale.ROOT)).replace(" ", "0");
    }
    StringBuilder sb = new StringBuilder();
    sb.append(HexStr.substring(0, 2))
        .append(" ")
        .append(HexStr.substring(2, 4))
        .append(" ")
        .append(HexStr.substring(4, 6))
        .append(" ")
        .append(HexStr.substring(6, 8))
        .append("\r\n")
        .append(HexStr.substring(6, 8))
        .append(" ")
        .append(HexStr.substring(4, 6))
        .append(" ")
        .append(HexStr.substring(2, 4))
        .append(" ")
        .append(HexStr.substring(0, 2));
    return sb.toString();
}
// main入口由OJ平台调用
public static void main(String[] args) {
    Scanner cin = new Scanner(System.in, StandardCharsets.UTF_8.name());
    String num = cin.nextLine();
    cin.close();
    String result = getHexString(num);
    System.out.println(result);
}
```

[-2^31, 2^32)范围数字:

其中Integer范围数字[-2^31, 2^31)，在（2^31, 2^32）之间的数字大于Integer范围，但是依然可以用4字节32位显示

```java
System.out.println(Long.toHexString((long)(Math.pow(2, 32)-1)));	//ff ff ff ff
System.out.println(Integer.toHexString(10));	//a
```

### 二进制转十进制（简单）

> 题目描述
>
> 输入一个二进制字符串，请处理转换成十进制整数。
>
> 解答要求时间限制：1000ms, 内存限制：64MB
>
> 输入
>
> 二进制字符串（仅含 0 和 1 ），用例保证转换结果范围在 32 位有符号整型范围以内。
>
> 输出
>
> 十进制整数
>
> 样例
>
> 输入样例 1 复制
>
> ```
> 00011
> ```
>
> 输出样例 1
>
> ```
> 3
> ```
>
> 提示样例 1
>
> 输入样例 2 复制
>
> ```
> 11111111111111111111111111111111
> ```
>
> 输出样例 2
>
> ```
> -1
> ```
>
> 提示样例 2
>
> 注：二进制字符串表示的是整数的补码形式，从右向左第32位1表示此数为负数。

```java
public class Main {
    private static int binaryToDecimal(String binaryString) {
        return (int) Long.parseLong(binaryString, 2);
    }

    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in, StandardCharsets.UTF_8.name());
        String binaryString = cin.nextLine();
        cin.close();

        int result = binaryToDecimal(binaryString);
        System.out.println(result);
    }
}
```



### 快速排序（简单）（个人感觉有难度） 

> 题目描述
>
> 著名的快速排序算法里有一个经典的划分过程：通常采用某种方法取一个元素作为**主元**，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。
>
> 给定一个**划分后**的正整数序列，请问有多少个元素可能是划分过程中选取的**主元**？ 并按升序输出这些主元。
>
> 解答要求时间限制：1000ms, 内存限制：256MB
>
> 输入
>
> 第 1 行一个正整数 N，表示正整数序列的长度，取值范围 [1, 10^5]
> 第 2 行 N 个互不不同的正整数，每个数的取值范围[1, 10^9]
>
> 输出
>
> 按升序排列的可能主元的列表，以单个空格分隔；或者空列表。
>
> 样例
>
> 输入样例 1 复制
>
> ```
> 5
> 1 3 2 4 5
> ```
>
> 输出样例 1
>
> ```
> [1 4 5]
> ```
>
> 提示样例 1
>
> - 1 的左边没有元素，右边的元素都比它大，所以它可能是主元。
> - 尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元； 尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元。
> - 同理，4 和 5 都可能是主元。
>
> 因此，1、4、5 是可能的主元，按升序输出为 [1 4 5] 。

```java
public class Main {
    // 待实现函数，在此函数中填入答题代码
    private static int[] quickSort(int[] numbers) {
        Stack<Integer> stack = new Stack<>();
        //之前所有值中的最大值
        int max = Integer.MIN_VALUE;
        for (int i = 0; i < numbers.length; i++) {
            //之前的值大于当前值，丢弃之前的值
            while (!stack.isEmpty() && stack.peek() >= numbers[i]) {
                stack.pop();
            }
            //当前值大于最大值，放入当前值，所以栈中的值是从小到大依次放入
            if (numbers[i] > max) {
                stack.push(numbers[i]);
                max = Math.max(numbers[i], max);
            }
        }
        return stack.stream().mapToInt(Integer::intValue).toArray();
    }

    // main入口由OJ平台调用
    public static void main(String[] args) {
        Scanner cin = new Scanner(System.in, StandardCharsets.UTF_8.name());
        int row = cin.nextInt();
        int[] numbers = new int[row];
        for (int i = 0; i < row; i++) {
            numbers[i] = cin.nextInt();
        }
        cin.close();

        int[] results = quickSort(numbers);
        String[] strResult = Arrays.stream(results).mapToObj(String::valueOf).toArray(String[]::new);
        System.out.print("[" + String.join(" ", strResult) + "]");
    }
}
```



## 多线程

```
blockThread.interrupt();发出一个中断信号，调用线程处于阻塞状态时会抛出一个InterruptedException异常，不处于阻塞状态可以在调用线程中用isInterrupted()或interrupted()检测中断信号手动结束代码
```

```java
@Slf4j
public class Main {
    public static void main(String[] args) throws InterruptedException {
        /*MyThread myThread=new MyThread();
        myThread.start();
        Thread.currentThread().sleep(10);
        myThread.interrupt();
        //sleep等待一秒，等myThread运行完
        Thread.currentThread().sleep(5000);
        log.info("myThread线程是否存活："+myThread.isAlive());*/

        BlockThread blockThread=new BlockThread();
        blockThread.start();
        log.info("主线程开始阻塞");
        Thread.currentThread().sleep(2000);
        log.info("主线程结束阻塞");
        blockThread.interrupt();
        //sleep等待一秒，等blockThread运行完
        Thread.currentThread().sleep(10000);
        log.info("blockThread线程是否存活："+blockThread.isAlive());
    }
}

@Slf4j
class MyThread extends Thread {
    @Override
    public  void run() {
        for (int i = 0; i < 1000; i++) {
            log.info("i="+(i+1));
            if(this.isInterrupted()){
                log.info("通过this.isInterrupted()检测到中断");
                log.info("第一个interrupted()"+this.interrupted());//true
                log.info("第二个interrupted()"+this.interrupted());//false
                break;
            }
        }
        log.info("因为检测到中断，所以跳出循环，线程到这里结束，因为后面没有内容了");
    }
}
@Slf4j
class BlockThread extends Thread {
    @Override
    public  void run() {
        try {
            log.info("线程开始阻塞");
            Thread.sleep(5000);
            log.info("线程结束阻塞");
        } catch (InterruptedException e) {
            log.error("中断",e);
        }
        log.info("BlockThread over");
    }
}
```








## Gauss

```sql
> su - gtsgsdba -s /bin/bash
> cd app/bin
> zsql / as sysdba -q
> EXP USERS=METADB FILE="/opt/backup/gdbservice/data/metadb_back_20221024.dmp";
> EXP USERS=SERVICEDB FILETYPE=BIN FILE="/opt/backup/gdbservice/data/servicedb_back_20221024.dmp";
-- 其中，斜体部分可根据实际情况配置。
-- /bin/bash和app/bin以现场实际路径为准。
```

- FILETYPE=BIN时，会导出三类文件：元数据文件（用户指定的文件）、数据文件（.D文件）和LOB文件（.L文件）。 

  逻辑导出数据时，会在指定的导出文件路径下生成一个元数据文件和一个名为data的子目录，如果未指定导出文件路径，则默认在当前路径下生成一个元数据文件和一个名为data的子目录。FILETYPE=BIN时，生成的子文件（数据文件、LOB文件）会放在二级目录data下，如果指定的元数据文件和生成的子文件已经存在，则会报错。

- 导出当前用户的tab1和tab2中的数据。`EXP TABLES=tab1,tab2  FILE="file1.dmp";`

```sql
> IMP USERS=SERVICEDB FILETYPE=BIN FILE="/opt/backup/gdbservice/data/servicedb_back_20221024.dmp";
```



## Vue

clear和readonly并存

```vue
<template>
    <div class="pcm" style="width: 80%;margin: 0 auto;padding-top: 20px;background: #fff;padding-bottom: 20px;">
        <el-form ref="channelProdMain" :model="waivePackage" size="small" label-width="100px" :rules="rules" >
            <el-row>
                <el-col span="8">
                    <el-form-item label="减免包" prop="waiveProdName"  width="80px">
                        <el-input v-model="waivePackage.waiveProdName" :title="waivePackage.waiveProdName" placeholder="请选择减免包" :readonly="true" style="width: calc(100% - 31px);" @mouseenter.native="enter" @mouseleave.native="leave">
                        <span slot="suffix">
                            <i class="el-icon-circle-close" v-show="iconShow" @click="clearDataByIcon" style="margin-right: 5px;cursor: pointer;"/>
                        </span>
                        </el-input>
                        <el-button type="text"  @click="chooseDiscountPackage()" v-if="resultVisable">选择</el-button>
                    </el-form-item>
                </el-col>
            </el-row>
        </el-form>
    </div>
</template>

methods: {
        enter(){
            if(this.waivePackage.waiveProdName){
                this.iconShow=true;
            }
        },
        leave(){
            this.iconShow=false;
        },
        clearDataByIcon(){
            this.waivePackage.waiveProdName='';
            this.waivePackage.waiveProdFee=0
            this.getTotalFee();
        }
}


export default {
    data: function () {
        var _this = this
        return {
            iconShow: false
		}
	}
}
```

### 动态路由

$ router是用来操作路由的，$ route是用来获取路由信息的。

```vue
this.$router.push({path:"/describe/${id}"});

<!-- 路由配置 -->
{
	path:'/describe/:id',
	name:'Describe',
	component:Describe
}

<!-- 获取参数 -->
this.$route.params.id
```

[vue动态路由传参](https://blog.csdn.net/weixin_52339077/article/details/125474967)



### JavaScript 对象与 JSON 对象的相互转换

JSON对象有两个方法：stringify() 和 parse()。 

[转换](https://blog.csdn.net/latency_cheng/article/details/73468205)























## 日志

slf4j是外观模式的典型应用。slf4j只是一个日志标准，并不是日志系统的具体实现。slf4j能够提供日志接口，提供获取具体日志对象的方法。 

slf4j-simple、logback都是slf4j的具体实现，log4j虽然不直接实现slf4j，但是有专门的一层桥接slf4j-log412来实现slf4j。 

slf4j依赖包slf4j-api

slf4j-simple依赖包slf4j-simple

logback依赖包logback-classic

slf4j中才有占位符





使用注解@Slf4j需要添加lombok依赖包





## Git

### 代码回退

**情况1：** 已提交到暂存区，未提交到本地版本库（即已进行git add 的操作，未进行 git commit 操作）

git reset ：撤回暂存区的所有提交

git reset HEAD 文件名 ：撤回暂存区的某个文件

**情况2：** 已提交到暂存区，已提交到本地版本库 （即已进行git add 和 git commit 操作）

**若需要回退到上次版本的代码：**

git reset --soft HEAD~1 ：回退到git add后的状态

git reset ： 撤回所有暂存区的文件

**若需要回退到某个版本的提交：**

git log ： 查看之前提交的版本号

git reset --soft 版本号：回退到某个版本的git add的状态

git reset ：撤回所有暂存区的提交

**情况3：** 已提交到暂存区，已提交到本地版本库，已推送远程分支 （即已进行git add ，git commit 和git push操作）

首先关闭远程分支的MR

**若需要回退到上次版本的代码：**

git reset --soft HEAD~1 ：回退到git add后的状态

git reset ： 撤回所有暂存区的文件

进行再次提交时，会产生版本错误，即提交失败，因为当前分支的版本低于远程分支的版本，所以要覆盖掉它

git push origin 分支 --force ：覆盖远程分支的版本

git push ：提交修改即可

**若需要回退到某个版本的提交：**

git log ： 查看之前提交的版本号

git reset --soft 版本号：回退到某个版本的git add的状态

git reset ：撤回所有暂存区的提交

进行再次提交时，会产生版本错误，即提交失败，因为当前分支的版本低于远程分支的版本，所以要覆盖掉它

git push origin 分支 --force ：覆盖远程分支的版本

git push ：提交修改即可

**情况4：** 如需要将本地工作区代码也进行同步回退

将上述几种情况的git reset --soft 的命令改为git reset --hard 即可实现本地工作区代码的同步回退

```sh
# push回退举例
# 1.查看提交的记录，找到想回到XXX版本的commitId
$ git log 
commit c1cc2ada80edc303b0135b318790c3b23b602e60
Merge: 061805b 8e4b1ad
Author: wangjin 30021900 <wangjin167@huawei.com>
Date:   Fri Oct 14 16:27:36 2022 +0800
    Merge branch 'master' of ssh://codehub-dg-y.huawei.com:2222/bd_as/udm/tianjin-mobile-iop/IOPTianjinMobile_V3R5C76
    * 'master' of ssh://codehub-dg-y.huawei.com:2222/bd_as/udm/tianjin-mobile-iop/IOPTianjinMobile_V3R5C76:
......
commit 061805b288513a0b508adf56ce328147fed48a1f
Author: wangjin 30021900 <wangjin167@huawei.com>
Date:   Fri Oct 14 16:27:11 2022 +0800
    【修改内容/原因】 sql脚本和打包升级脚本
    【DTS|IR|SR|US号】 #issue 3
    【修改人】 汪津 30021900
    【审核人】 NA
    ......

# 2.执行git reset命令,且保留本地修改记录
$ git reset --soft 061805b288513a0b508adf56ce328147fed48a1f
$ git push --force #将本地的版本号强制覆盖远端个人仓的版本号，删除已push的提交

# 3. 本地修改完成后重新执行commit 、 push 操作。
```



## Shell

对文件名中包含空格的处理方法

Linux命令行工具和Shell带来了困扰，因为大多数命令中，都是默认以空格做为值与值之间的分隔符，而不是做为文件名的一部分。即环境变量IFS（the Internal Field Separator）为值为 空格、Tab、回车。

 修改Linux命令行工具和Shell的默认分隔符来解决

```sh
MY_SAVESIFS=$IFS
IFS=$'\n'

# 脚本内容

IFS=$MY_SAVESIFS
```







## File

[Java –将文件转换为字符串](https://blog.csdn.net/cyan20115/article/details/106548417)



## 软件工程

[Java中的委托和继承](https://blog.csdn.net/Seriousplus/article/details/80462722)

委托有依赖、关联、聚合、组合，委派和继承都是为了代码复用，只是方式不同。委托可以被看作是对象级别的重用机制，而继承是类级别的重用机制。

依赖称为“use-a”关系 ，关联属于“has-a”关系，组合属于“a part of”关系，聚合属于“has-a”关系，聚合直接传入对象，组合是在内部初始化。

继承属于“is-a”关系



## Redis

```sh
$ ./redis-cli -h 172.18.0.3 -cipherdir /opt/redis/cipher -a sysmgrrdb@admin@hJ.uya88nr@I?f84 -p 16379
```



## Docker

```sh
$ docker exec -it a42d7bf373b9 bash

$ docker cp a42d7bf373b9:/opt/redis/cipher /home/temp/

$ docker port a42d7bf373b9

$ docker inspect a42d7bf373b9
```

```
docker container inspect重点字段介绍
State.OOMKilled：是否触发OOM(out of memory)
LogPath: 日志路径
RestartCount: 容器重启次数
Mounts.Source： 容器内挂载目录对应的宿主机路径
Mounts.Destination：容器内挂载路径
Config.ExposedPosrts：暴露的端口
Config.Env：容器内环境变量
Config.Cmd：指定字符串或字符串数组的运行命令。
Config.Entrypoint：entrypoint.sh脚本路径及参数
NetworkSettings.Networks.IPAddress：容器ip
NetworkSettings.Networks.Gateway：该网络的网关
HostConfig.Binds：该容器的卷绑定列表
HostConfig.NetworkMode：该容器的网络模型
HostConfig.PortBindings：容器与主机的端口映射关系
HostConfig.Privileged：特权模式
HostConfig.Sysctls：给容器设置内核参数

docker image inspect 字段说明
Cmd：容器启动时执行的命令
Config.ExposedPorts：镜像配置的暴露端口信息
Config.Env：镜像配置的环境变量
Architecture：镜像运行的CPU架构

docker volume inspect 字段说明
MountPoint：容器内挂载目录对应的宿主机路径
UsageData：卷使用详情
UsageData.Size：挂载卷已使用
UsageData.RefCount：该卷关联的容器数

docker network inspect 字段说明
IPAM.Config.Subnet：子网网段
IPAM.Config.Gateway：子网网关
Containers：关联的容器信息
```





## Java基础

```java
// double保留两位小数的四种方法，都是四舍五入
public static void main(String[] args) {
    // NumberFormat设置最大小数位数
    NumberFormat numberFormat = NumberFormat.getInstance();
    numberFormat.setMaximumFractionDigits(2);
    System.out.println((Double.parseDouble(numberFormat.format(89.5998))));
    // Sting自带的format方法
    System.out.println((Double.parseDouble(String.format("%.2f",89.5656))));
    // DecimalFormat
    DecimalFormat decimalFormat = new DecimalFormat("#.00");
    System.out.println(Double.parseDouble(decimalFormat.format(56.5656)));
    // BigDecimal的setScale方法
    BigDecimal bigDecimal = new BigDecimal(56.5656);
    System.out.println(bigDecimal.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue());
}
```

[ForkJoinPool](https://segmentfault.com/a/1190000039267451)

## docker

```sh
# 将主机/www/runoob目录拷贝到容器96f7f14e99ab的/www目录下。
$ docker cp /www/runoob 96f7f14e99ab:/www/

# 将主机/www/runoob目录拷贝到容器96f7f14e99ab中，目录重命名为www。
$ docker cp /www/runoob 96f7f14e99ab:/www

# 将容器96f7f14e99ab的/www目录拷贝到主机的/tmp目录中。
$ docker cp  96f7f14e99ab:/www /tmp/
```



## Normalizer.normalize()

normalize方法对外部输入字符串做归一化/标准化处理，如：

```java
//将全角形式的字符转化为半角形式的字符，"＜root＞"-->"<root>"
Normalizer.normalize(str,Normalizer.Form.NFKC);
```

[关于Normalizer.normalize()方法的用途](https://blog.csdn.net/u010512607/article/details/79921353)




## 正则表达式

```java
System.out.println("as/asdas/as".replaceAll("(?<=/).*?(?=/)","*"));		// as/*/as
System.out.println("as/asdas/as".replaceAll("(?=/).*?(?<=/)","*"));		// as*asdas*as
```

## Java8

```
String nowTime= DateTimeFormatter.ofPattern("yyyyMMdd").format(LocalDate.now());
```



### 远程调试

[IDEA 进行远程 Debug ](https://www.cnblogs.com/javastack/p/15484248.html)

[idea远程Remote使用](https://blog.csdn.net/weixin_42582494/article/details/115312211)

## 流

[BIO、NIO、AIO](https://www.cnblogs.com/williamjie/p/11194561.html)





## SQL

### gaussDB

```mysql
# 修改 where 查询条件字段值
UPDATE DAMSDB.DATA_ASSETS_INFO_CONFIG SET ENTITY_TYPE=13 WHERE DATA_CONFIG_ID IN 
(SELECT DISTINCT DATA_CONFIG_ID FROM DAMSDB.DATA_ASSETS_INFO_CONFIG WHERE ENTITY_TYPE=10);

# 批量插入
INSERT INTO DAMSDB.DATA_ASSETS_INFO_CONFIG 
(DATA_CONFIG_ID,ENTITY_COLUMN,ENTITY_COLUMN_NAME,ENTITY_COLUMN_NAME_EN,ENTITY_COLUMN_ORDER,IS_HIDE,IS_TEMPLATE,ENTITY_TYPE,
TENEMENT,IS_FIELD,TEMPLATE_ORDER,FIELD_LENGTH) 
VALUES 
('1000','DATAPRODUCT_CODE','数据产品编码','DATA_DATAPRODUCT_INFO.DATAPRODUCT_CODE',1000,0,0,10,'GX',1,1000,'100'),
('1001','DATAPRODUCT_NAME_EN','数据产品英文名称','DATA_DATAPRODUCT_INFO.DATAPRODUCT_NAME_EN',1001,0,0,10,'GX',1,1001,'200'),
('1002','DATAPRODUCT_NAME_CN','数据产品中文名称','DATA_DATAPRODUCT_INFO.DATAPRODUCT_NAME_CN',1002,0,0,10,'GX',1,1002,'200');

# 单个添加表字段
ALTER TABLE DATA_API_INFO ADD COLUMN SHARING_SYSTEM_INFORMATION VARCHAR(2000) COMMENT '服务API共享系统信息';

# 批量添加表字段(表中旧字段已有记录，新加字段非空，默认空格，空包括空字符串)
ALTER TABLE DATA_DATAPRODUCT_INFO ADD  (
	DATAPRODUCT_UPDATE_TIME VARCHAR(20) COMMENT '数据产品更新时间',
	DATAPRODUCT_BUSINESS_DEPARTMENT VARCHAR(100) NOT NULL DEFAULT ' ' COMMENT '数据产品局方业务部门',
	DATAPRODUCT_BUSINESS_PIC VARCHAR(100) NOT NULL DEFAULT ' ' COMMENT '数据产品局方业务责任人'
);

# 修改表字段注释
COMMENT ON COLUMN DAMSDB.DATA_DATAPRODUCT_INFO.DATAPRODUCT_RELEASE_TYPE IS '发布类型';

# 修改表字段名称
ALTER TABLE DAMSDB.DATA_DATAPRODUCT_INFO RENAME COLUMN DATAPRODUCT_RELEASE_TYPE TO DATAPRODUCT_RELEASE_MODE;

# 删除表字段
ALTER TABLE DAMSDB.DATA_DATAPRODUCT_INFO DROP COLUMN DATAPRODUCT_BUSINESS_DEPARTMENT;
```



[java 将下划线方式命名的字符串转换为驼峰式](https://blog.csdn.net/qq_34626094/article/details/122578870)

[java将驼峰式命名的字符串转换为下划线大写方式](https://blog.csdn.net/sdgames/article/details/106471352)

 

IntelliJ IDEA中可以在主菜单中选择Navigate | Call Hierarchy命令查看一个Java方法调用树 

IntelliJ IDEA中可以在主菜单中选择Analyze | Data flow from/to Here两个命令查看表达式、变量和方法参数的传递关系树。 

IntelliJ IDEA的"Find Usage"可以查看一个Java类、方法或变量的直接使用情况。 

类关系图 在包或类上右键点击Diagram或者用快捷键Ctrl+Alt+U。

```sql
-- MINUS 集合前减后
select id,employee_name from employees 
minus 
select id,employee_name from dependents
order by id;
```

```sql
-- 查询多个字段并链接在一起
MySQL: CONCAT()
Oracle: CONCAT(), ||
SQL Server: +

CONCAT(字串1, 字串2, 字串3, ...): 将字串1、字串2、字串3，等字串连在一起。请注意，Oracle的CONCAT()只允许两个参数；
```

```sql
-- merge into 将源数据(来源于实际的表,视图,子查询)根据条件判断更新或插入到指定的表中(必须实际存在)
-- 这个语法仅需要一次全表扫描就完成了全部工作，执行效率要高于insert＋update，尤其是在大数据量面前，效率越明显。
```

```sql
-- 如果满足连接条件，则更新字段；如果连接条件不满足，则停止更新进行插入。
MERGE INTO table_name 
USING 数据来源表/视图/子查询结果集
ON 连接条件
WHEN MATCHED THEN 
UPDATE ...
WHEN NOT MATCHED THEN
INSERT ...
```

[SQL语句merge into的用法](https://blog.csdn.net/peterwanghao/article/details/107559583)

## mybatis

sql中有一些特殊的字符的话，在解析xml文件的时候会被转义，但我们不希望他被转义，所以我们要使用<![CDATA[ ]]> 

<![CDATA[   ]]> 是XML语法。在CDATA内部的所有内容都会被解析器忽略。 

如果文本包含了很多的"<"字符 <=和"&"字符，那么最好把他们都放到CDATA部件中。 

**mybatis动态SQL  if 和 trim 标签**



**xml 中调用存储过程**



```xml
<select id="synchronousDataQualityFromBdi" databaseId="gauss" resultType="String">
    CALL p_synch_data_quality_d (#{statDate,mode=IN,jdbcType=VARCHAR})
</select>
```



```sql
/*sql中存储过程*/
CREATE OR REPLACE PROCEDURE P_SYNCH_DATA_QUALITY_D (
                             iv_stat_date in varchar2   --同步日期
                             ) 
as
/** head
  * @name                    p_synch_data_quality_d
  * @caption                 将数据质量数据同步到资产可视通用数据质量
  * @type                    iv_stat_date varchar2,format yyyymmdd
  * @parameter               oi_result integer 0 成功
  * @version                 2.0.0
  * @author                  w00212040
  * @create_date             2020-04-28
  * @copyright               Huawei
  * @modify1                 修改时请标注修改内容
  */
begin

  --同步到t_dataquality_rule_details
  delete from t_dataquality_rule_details a
   where a.stat_date = to_number(iv_stat_date) and a.data_source_id='1';

  insert into t_dataquality_rule_details
              (stat_date,
               ruleid,
               rulecode,
               rulename,
               objecttype,
               typeid,
               objecttypestr,
               createtime,
               createtimeformat,
               data_cycle,
               data_source_id
              )
     select to_number(iv_stat_date) as stat_date,
              a.rule_id,
              a.rule_id as rule_code,
              a.rule_name,
              '' as objecttype,
              case when a.type_description='唯一性' then 'Unique'
                when a.type_description='准确性' then 'Accuracy'
                when a.type_description='一致性' then 'Consistency'
                when a.type_description='完整性' then 'Integrity'
                when a.type_description='及时性' then 'Timeliness'
                else 'Validity'
              end typeid,
              case
                when a.column_name is not null then 'Field'
                else 'Table'
              end object_type_str,
              to_char(SYSDATE,'yyyymmdd hh24:mi:ss') as createtime,
              to_char(SYSDATE,'yyyymmdd hh24:mi:ss') as createtimeformat,
              a.data_cycle,
              '1' as data_source_id
         from t_dq_rule_def a;
  commit;

end;/
```





**databaseIdProvider多数据库支持**

MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 databaseId 属性。如果配置了 databaseIdProvider，MyBatis 会加载所有的不带 databaseId 或匹配当前数据库 databaseId 属性的所有语句；如果带或者不带的语句都有，则不带的会被忽略。新增，修改和删除都有这个属性。 



[MyBatis之databaseIdProvider多数据库支持](https://blog.csdn.net/likewindy/article/details/51396576)

```java
// springboot中
@Configuration
public class DatabaseSwitchConfig {
    /**
     * 自动识别使用的数据库类型
     * 在mapper.xml中databaseId的值就是跟这里对应，
     * 如果没有databaseId选择则说明该sql适用所有数据库
     *
     * @return DatabaseIdProvider
     */
    @Bean
    public DatabaseIdProvider getDatabaseIdProvider() {
        Properties properties = new Properties();
        properties.setProperty("Oracle", "oracle");
        properties.setProperty("MySQL", "mysql");
        properties.setProperty("DB2", "db2");
        properties.setProperty("Derby", "derby");
        properties.setProperty("H2", "h2");
        properties.setProperty("HSQL", "hsql");
        properties.setProperty("Informix", "informix");
        properties.setProperty("MS-SQL", "ms-sql");
        properties.setProperty("PostgreSQL", "postgresql");
        properties.setProperty("Sybase", "sybase");
        properties.setProperty("Hana", "hana");
        properties.setProperty("Zenith", "gauss");
        DatabaseIdProvider databaseIdProvider = new VendorDatabaseIdProvider();
        databaseIdProvider.setProperties(properties);
        return databaseIdProvider;
    }
}
```

```sql
<select id="getAssetsSquareSource" resultMap="AssetsSquare" databaseId="gauss">
        select NVL(COUNT(*),0) NUM
        FROM LOGICAL_ENTITY_INFO LOGICAL
        LEFT JOIN PHYSICAL_ENTITY_INFO PHYSICAL ON LOGICAL.LOGICALENTITY_ID = PHYSICAL.LOGICALENTITY_ID
        LEFT JOIN DATA_ASSETS_INFO LOGICALASSETS ON LOGICAL.DATA_CODE = LOGICALASSETS.DATA_CODE
        WHERE PHYSICAL.DATA_LEVEL = '1'
        AND LOGICALASSETS.STATE = '2'
        AND (LOGICALASSETS.ISPRIVATE = '0' OR LOGICALASSETS.DAMS_BEID =  #{damsBeId, jdbcType=VARCHAR})
        GROUP BY LOGICALASSETS.DATA_TYPE
</select>
    
    
<select id="getAssetsSquareSource" resultMap="AssetsSquare" databaseId="mysql">
        select IFNULL(COUNT(*),0) NUM
        FROM LOGICAL_ENTITY_INFO LOGICAL
        LEFT JOIN PHYSICAL_ENTITY_INFO PHYSICAL ON LOGICAL.LOGICALENTITY_ID = PHYSICAL.LOGICALENTITY_ID
        LEFT JOIN DATA_ASSETS_INFO LOGICALASSETS ON LOGICAL.DATA_CODE = LOGICALASSETS.DATA_CODE
        WHERE PHYSICAL.DATA_LEVEL = '1'
        AND LOGICALASSETS.STATE = '2'
        AND (LOGICALASSETS.ISPRIVATE = '0' OR LOGICALASSETS.DAMS_BEID =  #{damsBeId, jdbcType=VARCHAR})
        GROUP BY LOGICALASSETS.DATA_TYPE
</select>
```









[使用＜where＞标签替换where 1=1](https://blog.csdn.net/AttleeTao/article/details/114319763)

where标签只会在它包含的标签中有返回值的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，where标签也会将它们去除。 





## Java 8 

[字符串和时间相互转换](https://blog.csdn.net/WLFIGHTER/article/details/113752001)




## BUG

#### springboot升级版本2.6.7报错

```java
1、Failed to instantiate [org.springframework.boot.autoconfigure.quartz.QuartzDataSourceScriptDatabaseInitializer]: Factory method 'quartzDataSourceScriptDatabaseInitializer' threw exception; nested exception is java.lang.IllegalStateException: Unable to detect database type


// 解决方式
Platform used for Quartz, Session, Integration, and Batch schema initialization cannot be configured 
// 配置文件添加
spring.quartz.jdbc.initialize-schema=never

2、循环依赖
// 解决方式:配置文件添加
spring.main.allow-circular-references=true
```

## Java基础

```java
List<RedisInstancesInfo> resultList =
                    JSONObject.parseObject(
                            str, new TempTypeReference());

private static class TempTypeReference extends TypeReference<List<RedisInstancesInfo>> {
    public TempTypeReference() {}
}
```

```java
Map<String, Object> stringObjectMap = 
    JSONObject.parseObject(str, new TypeReference<Map<String, Object>>(){});

Map<?,?> tempMap = JacksonConvertHelper.getJavaBeanByString(str, Map.class);
Map<String, Object> envMap = castHashMap(tempMap, String.class, Object.class);
```

[Java Math 数学方法](https://www.cainiaojc.com/java/java-library-math.html)

## IDEA

**jar包存在但是报错找不到：**

1. 找到对应编译不了的类。右键 - Build Module ‘xxxx’，recompile ‘xxxxx’
2. 运行maven命令 mvn idea:idea 或 mvn -U idea:idea

生成idea项目工程所有文件: mvn idea:idea

清除idea项目工程文件:mvn idea:clean

常见问题:
如果项目环境有错误,怀疑是这些idea本地文件有错误可以先使用 mvn idea:clean清空所有本地文件,然后使用mvn idea:idea重新生成所有idea本地文件

[误删.idea目录和.iml文件](https://www.cnblogs.com/zhangxl1016/articles/14990497.html)







项目或者jar包标注library root，说明这个项目被其他项目引入，作为外部依赖库的存在 



## WebService

> WebService就是一种跨编程语言和跨操作系统平台的远程调用技术。

XML,SOAP和WSDL就是构成WebService平台的三大技术 。

- WebService采用Http协议来在客户端和服务端之间传输数据。 
- WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议规定的。
- WebService服务器端首先要通过一个WSDL文件来说明自己有什么服务可以对外调用。WSDL用于描述WebService及其方法、参数和返回值。 WSDL文件保存在Web服务器上，通过一个url地址就可以访问到它。 

### WSDL

WSDL(Web Services Description Language), web服务描述语言，说明webservice服务端接口、方法、参数和返回值，WSDL是随服务发布成功，自动生成，无需编写。

- Service：提供的服务
- Binding：服务的具体协议和数据格式规范，通过Service指向Binding
- portType: 服务端点，描述操作方法名称和参数，通过binding指向portType
- message: 定义一个操作（方法）的数据参数名称，通过portType指向message
- types: 定义 web service 使用的全部的具体数据参数，通过message指向types

```xml
<?xml version="1.0" encoding="UTF-8"?>
<wsdl:definitions xmlns:wsdl="http://schemas.xmlsoap.org/wsdl/" xmlns:ns1="http://org.apache.axis2/xsd" xmlns:ns="http://service.prp.campaign.huawei.com" xmlns:wsaw="http://www.w3.org/2006/05/addressing/wsdl" xmlns:http="http://schemas.xmlsoap.org/wsdl/http/" xmlns:ax21="http://domain.prp.campaign.huawei.com/xsd" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:mime="http://schemas.xmlsoap.org/wsdl/mime/" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:soap12="http://schemas.xmlsoap.org/wsdl/soap/" targetNamespace="http://service.prp.campaign.huawei.com">
    <!-- 5 -->
    <wsdl:types>
        <xs:schema attributeFormDefault="qualified" elementFormDefault="qualified" targetNamespace="http://domain.prp.campaign.huawei.com/xsd">
            <!-- 5.2查找对应name -->
            <xs:complexType name="RequestHeader">
                <xs:sequence>
                    <xs:element minOccurs="0" name="accessChannel" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="beId" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="language" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="operator" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="password" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="transactionId" nillable="true" type="xs:string"/>
                </xs:sequence>
            </xs:complexType>
            <xs:complexType name="EventBody">
                <xs:sequence>
                    <xs:element maxOccurs="unbounded" minOccurs="0" name="eventAttrMap" nillable="true" type="ax21:AttrMap"/>
                    <xs:element minOccurs="0" name="eventCode" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="msisdn" nillable="true" type="xs:string"/>
					<xs:element minOccurs="0" name="subsId" nillable="true" type="xs:string"/>
                </xs:sequence>
            </xs:complexType>
            <xs:complexType name="AttrMap">
                <xs:sequence>
                    <xs:element minOccurs="0" name="key" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="value" nillable="true" type="xs:string"/>
                </xs:sequence>
            </xs:complexType>
            <xs:complexType name="RecommednationResult">
                <xs:sequence>
                    <xs:element maxOccurs="unbounded" minOccurs="0" name="offerList" nillable="true" type="ax21:Offer"/>
                    <xs:element minOccurs="0" name="resultCode" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="resultMessage" nillable="true" type="xs:string"/>
                </xs:sequence>
            </xs:complexType>
            <xs:complexType name="Offer">
                <xs:sequence>
                    <xs:element minOccurs="0" name="clickUrl" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="urlType" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="desc" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="displayMode" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="businessPositionCode" nillable="true" type="xs:string"/>
                    <xs:element maxOccurs="unbounded" minOccurs="0" name="offerAttrMap" nillable="true" type="ax21:AttrMap"/>
                    <xs:element minOccurs="0" name="offerId" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="offerName" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="offerType" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="priority" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="url" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="bpOfferContentType" nillable="true" type="xs:string"/>
                    <xs:element minOccurs="0" name="bpOfferContent" nillable="true" type="xs:string"/>
                </xs:sequence>
            </xs:complexType>
        </xs:schema>
        <!-- 5.1查看type:RequestHeader和EventBody、RecommednationResult -->
        <xs:schema xmlns:ax22="http://domain.prp.campaign.huawei.com/xsd" attributeFormDefault="qualified" elementFormDefault="qualified" targetNamespace="http://service.prp.campaign.huawei.com">
            <xs:import namespace="http://domain.prp.campaign.huawei.com/xsd"/>
            <xs:element name="getRecommendedOffer">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element minOccurs="0" name="requestHeader" nillable="true" type="ax22:RequestHeader"/>
                        <xs:element minOccurs="0" name="eventBody" nillable="true" type="ax22:EventBody"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
            <xs:element name="getRecommendedOfferResponse">
                <xs:complexType>
                    <xs:sequence>
                        <xs:element minOccurs="0" name="return" nillable="true" type="ax22:RecommednationResult"/>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:schema>
    </wsdl:types>
    <!-- 4.查看element，参数分别为：getRecommendedOffer和getRecommendedOfferResponse -->
    <wsdl:message name="getRecommendedOfferRequest">
        <wsdl:part name="parameters" element="ns:getRecommendedOffer"/>
    </wsdl:message>
    <wsdl:message name="getRecommendedOfferResponse">
        <wsdl:part name="parameters" element="ns:getRecommendedOfferResponse"/>
    </wsdl:message>
    <!-- 3.查看message分别为:getRecommendedOfferRequest和getRecommendedOfferResponse -->
    <wsdl:portType name="EventAccessServicePortType">
        <wsdl:operation name="getRecommendedOffer">
            <wsdl:input message="ns:getRecommendedOfferRequest" wsaw:Action="urn:getRecommendedOffer"/>
            <wsdl:output message="ns:getRecommendedOfferResponse" wsaw:Action="urn:getRecommendedOfferResponse"/>
        </wsdl:operation>
    </wsdl:portType>
    <!-- 2.查看type:EventAccessServicePortType -->
    <wsdl:binding name="EventAccessServiceSoap11Binding" type="ns:EventAccessServicePortType">
        <soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/>
        <wsdl:operation name="getRecommendedOffer">
            <soap:operation soapAction="urn:getRecommendedOffer" style="document"/>
            <wsdl:input>
                <soap:body use="literal"/>
            </wsdl:input>
            <wsdl:output>
                <soap:body use="literal"/>
            </wsdl:output>
        </wsdl:operation>
    </wsdl:binding>
    <wsdl:binding name="EventAccessServiceSoap12Binding" type="ns:EventAccessServicePortType">
        <soap12:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/>
        <wsdl:operation name="getRecommendedOffer">
            <soap12:operation soapAction="urn:getRecommendedOffer" style="document"/>
            <wsdl:input>
                <soap12:body use="literal"/>
            </wsdl:input>
            <wsdl:output>
                <soap12:body use="literal"/>
            </wsdl:output>
        </wsdl:operation>
    </wsdl:binding>
    <wsdl:binding name="EventAccessServiceHttpBinding" type="ns:EventAccessServicePortType">
        <http:binding verb="POST"/>
        <wsdl:operation name="getRecommendedOffer">
            <http:operation location="EventAccessService/getRecommendedOffer"/>
            <wsdl:input>
                <mime:content type="text/xml" part="getRecommendedOffer"/>
            </wsdl:input>
            <wsdl:output>
                <mime:content type="text/xml" part="getRecommendedOffer"/>
            </wsdl:output>
        </wsdl:operation>
    </wsdl:binding>
    <!-- 1.查看binding指向 -->
    <wsdl:service name="EventAccessService">
        <wsdl:port name="EventAccessServiceHttpSoap11Endpoint" binding="ns:EventAccessServiceSoap11Binding">
            <soap:address location="http://localhost:8080/axis2/services/EventAccessService"/>
        </wsdl:port>
        <wsdl:port name="EventAccessServiceHttpSoap12Endpoint" binding="ns:EventAccessServiceSoap12Binding">
            <soap12:address location="http://localhost:8080/axis2/services/EventAccessService"/>
        </wsdl:port>
        <wsdl:port name="EventAccessServiceHttpEndpoint" binding="ns:EventAccessServiceHttpBinding">
            <http:address location="http://localhost:8080/axis2/services/EventAccessService"/>
        </wsdl:port>
    </wsdl:service>
</wsdl:definitions>
```

```java
public RecommendationOutput getRecommendedOffer(RecommendationInput in) {
    ...
}

public class RecommendationInput {
    private String msisdn;
    private String subsId;
    private String eventCode;
    private EventAttrMap[] eventAttrInfoList;
    private RequestHeader accessSessionRequest;
}

public class EventAttrMap {
    private String key;
    private String value;
}

public class RequestHeader {
    private String accessChannel;
    private String version;
    private String beId;
    private String operator;
    private String language;
    private String password;
    private String transactionId;
}

// 返回值
public class RecommendationOutput {
    private String resultCode;
    private String resultMessage;
    private List<Offer> offerList;
}

public class Offer {
    private String clickUrl;
    private String desc;
    private String displayMode;
    private List<EventAttrMap> offerAttrMap;
    private String offerId;
    private String offerName;
    private String offerType;
    private String priority;
    private String offerUrl;
    private String url;
    private String bpOfferContentType;
    private String bpOfferContent;
    private String urlType;
    private String businessPositionCode;
}
```





## Linux

### zip命令

基本用法：

`zip [参数][压缩包名][压缩的目录或者文件的路径]`

常用参数：
zip命令的常用参数
-m	将文件压缩后，删除原文件
-o	将压缩文件内的所有文件的最新变动时间设为压缩的时间
-q	安静模式，在压缩的时候不显示指令执行的过程
-r	递归压缩，将自定目录下的所有子文件以及文件一起处理
-x	”文件列表“，压缩时排除文件列表中的文件

### unzip命令

`unzip [参数][压缩文件]  （-d [目录]）`  //如果不是用括号里面的内容，则解压文件在当前工作目录 

unzip命令的常用参数
-c	将解压缩的结果显示到屏幕上（显示每一个目录下的每一个文件的内容），同时对字符做适当的转换，但是并没有解压压缩包
-l	显示压缩文件内所包含的文件
-t	检查压缩文件是否正确
-v	执行时显示压缩文件的详细信息
-q	安静模式，执行时不显示任何信息
-d	指定文件解压后存储的目录
-x	指定不要处理压缩文件中的那些文件



nl 可以将输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。   

```sh
# 返回file中，与str匹配的行数（一共有几行）
$ grep -c str file
$ nl file |grep str |wc -l
```

### 删除文件排除

```sh
$ rm -rf `ls WEB-INF/lib/* | grep -v WEB-INF/lib/c_pcm_smsUtils.jar`
```



### 删除文件后没有释放空间

1. [/dev/sda2占用100%、磁盘占用100%的怎么解决？](/dev/sda2占用100%、磁盘占用100%的怎么解决？ ) 

   ```sh
   $ df -h
   $ du -sh /* | sort -nr # 命令查找 / 目录下所有文件和目录的大小的排序结果
   ```

1. 在Linux或者Unix系统中，通过rm或者文件管理器删除文件将会从文件系统的目录结构上解除链接(unlink).然而如果文件是被 打开的（有一个进程正在使用），那么进程将仍然可以读取该文件，磁盘空间也一直被占用。 

   ```sh
   # 获得一个已经被删除但是仍然被应用程序占用的文件列表
   $ lsof |grep deleted
   pulseaudi 16848                  gdm    6u      REG                0,4  67108864      96183 /memfd:pulseaudio (deleted)
   null-sink 16848 17030            gdm    6u      REG                0,4  67108864      96183 /memfd:pulseaudio (deleted)
   
   # 可以看出两个文件分别占用67108864 B空间，一共大概134M
   
   $ ps -ef|grep 16848
   gdm      16848     1  0 Mar09 ?        00:00:00 /usr/bin/pulseaudio --start --log-target=syslog
   
   # 停掉使用这个文件的应用或者kill掉相应的进程，让os自动回收磁盘空间
   ```

   [linux删除文件后没有释放空间](https://blog.csdn.net/wyzxg/article/details/4971843)

2. ```sh
   # 查看inode使用率，inode不够用也会导致此问题
   $ df -i
   文件系统					Inodes	已用(I)	可用(I) 已用(I)%% 挂载点
   Filesystem                    Inodes  IUsed    IFree IUse% Mounted on
   /dev/vda3                     917504 133559   783945   15% /
   devtmpfs                     4047378    443  4046935    1% /dev
   tmpfs                        4050638      1  4050637    1% /dev/shm
   tmpfs                        4050638   1710  4048928    1% /run
   tmpfs                        4050638     17  4050621    1% /sys/fs/cgroup
   /dev/vda1                      65536    341    65195    1% /boot
   /dev/mapper/vg1-lv2          3276800     10  3276790    1% /home/test
   /dev/mapper/euleros-var       524288   1932   522356    1% /var
   /dev/mapper/euleros-var_tmp   262144     35   262109    1% /tmp
   /dev/mapper/euleros-var_log   262144    194   261950    1% /var/log
   /dev/mapper/vg1-lv1         13107200  78027 13029173    1% /home/dataasset
   tmpfs                        4050638      9  4050629    1% /run/user/42
   tmpfs                        4050638      1  4050637    1% /run/user/1007
   tmpfs                        4050638      1  4050637    1% /run/user/0
   ```

   [Linux磁盘空间满，但实际占用却没有那么大](https://blog.csdn.net/lqy461929569/article/details/77895704)

3. ```sh
   # 查看隐藏文件
   $ ls -lha
   ```

4. 新磁盘还没挂载就开始写数据了 ，挂载后这部分数据看不到

   [Linux 离奇磁盘爆满，如何解决？](https://cloud.tencent.com/developer/news/590360)

### grep

```sh
# grep 命令用于查找文件里符合条件的字符串。

# 查找指定目录/etc/acpi 及其子目录下所有文件中包含字符串"update"的文件，打印出该字符串所在行的内容，并标示出该行的行数编号
$ grep -nr update /etc/acpi

# 在当前目录及其子目录下所有文件中查找"update"并输出
$ grep -nr update
```

### 脚本执行

像 ls 、cd 、pwd 这样的命令，它们的程序是位于 /bin 目录下，但是我们却可以在系统的任意位置都可以执行这些程序。 

那是因为这些命令对应的程序所在路径被加到了 Path 环境变量里。所以我们如果把自己的脚本路径加到了这个变量里，我们也可以实现在任意地方执行自己脚本的效果。 



```sh
# 脚本路径为/home/alvin/scripts/hello.sh

Bash 在运行起来之后，会先加载 .bashrc 文件。所以，我们可以把脚本路径添加到 .bashrc 文件，然后就能达到目标。
export PATH="/home/alvin/scripts:$PATH" 加到 .bashrc 最后

.profile 文件是一个环境变量配置文件，用户在登录系统的时候加载此文件来配置环境变量。
export PATH="$PATH:$HOME/scripts" 添加到 .profile 文件末尾

直接改环境变量文件，方法2一样，需要将用户登出再重新登录即可
PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin"  -> PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/home/alvin/scripts" 
修改/etc/environment 
```

 /etc/profile 是所有用户的环境变量 /etc/enviroment是系统的环境变量 

如果同一个变量在用户环境(/etc/profile)和系统环境(/etc/environment)有不同的值那应该是以用户环境为准了。 



执行顺序为：/etc/profile -> (~/.bash_profile | ~/.bash_login | ~/.profile) -> ~/.bashrc -> /etc/bashrc -> ~/.bash_logout 



/etc/profile： 此文件为系统的每个用户设置环境信息，每一个用户第一次登录时,该文件被执行 

/etc/bashrc: 每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取。 

~/.bash_profile 是交互式、login 方式进入 bash 运行的，~/.bashrc 是交互式 non-login 方式进入 bash 运行的 

## 数据结构

二叉排序树，又称为二叉查找树。二叉排序树或者是一棵空树，或者是具有以下性质的二叉树：若其左子树不为空，则左子树上的所有节点的值均小于它的根结点的值；若其右子树不为空，则右子树上的所有节点的值均大于它的根结点的值；左右子树又分别是二叉排序树。 

平衡二叉树又称AVL树。它是具有以下性质的二叉排序树：它的左子树和右子树的高度之差(平衡因子)的绝对值不超过1且它的左子树和右子树都是一颗平衡二叉树。 





## MySQL

### 表空间

　　从 InnoDB存储引擎的逻辑存储结构看，所有数据都被逻辑地存放在一个空间中，称之为表空间( tablespace)。表空间又由段(segment)、区( extent)、页(page)组成，页在一些文档中有时也称为块( block) 。每个表空间由一个或多个数据文件组成，一个数据文件只能与一个表空间相联系。 

在innodb存储引擎中数据是按照表空间来组织存储的。其实有个潜台词是：表空间文件是实际存在的物理文件。 

#### 系统表空间

```mysql
mysql> show variables like '%inndb_data_file_path%';

Variable_name			Value
innodb_data_file_path	ibdata1:12M:autoextend
```

Value部分的的组成是：name:size:attributes

默认情况下，MySQL会初始化一个大小为12MB，名为ibdata1文件，并且随着数据的增多，它会自动扩容。

这个ibdata1文件是系统表空间，也是默认的表空间，也是默认的表空间物理文件，也是传说中的共享表空间。



系统表空间的数量和大小可以通过启动参数：innodb_data_file_path 

```sh
# my.cnf
[mysqld]
innodb_data_file_path=/dir1/ibdata1:2000M;/dir2/ibdata2:2000M:autoextend
```

#### 独占表空间

```sh
让每一个数据库表都有一个单独的表空间文件的话，可以通过参数innodb_file_per_table设置。这个参数只有在MySQL5.6或者是更高的版本中才可以使用。

配置文件：
[mysqld]
innodb_file_per_table=ON

命令：
mysql> SET GLOBAL innodb_file_per_table=ON; 
```

之后InnoDB存储引擎产生的表都会自己独立的表空间文件。

独立的表空间文件命名规则：表名.ibd，独立表空间文件中仅存放该表对应数据、索引、insert buffer bitmap。

其余的诸如：undo信息、insert buffer 索引页、double write buffer 等信息依然放在默认表空间，也就是共享表空间中。



```sh
# oa是数据库名称
$ ll /usr/local/mysql/data/oa
......
flowtemplate.ibd	# 以.ibd文件结尾的是表flowtemplate对应的独立表空间文件
t3.frm			#以frm结尾的是该表的表结构定义文件
......
```



#### 临时表空间

临时表空间用于存放用户创建的临时表和磁盘内部临时表。

```mysql
-- 参数innodb_temp_data_file_path定义了临时表空间的一些名称、大小、规格属性。
mysql> show variables like '%innodb_temp_data_file_path%';
Variable_name				Value
innodb_temp_data_file_path	ibtmp1:12M:autoextend

-- 查看临时表空间文件存放的目录
mysql> show variables like '%innodb_data_home_dir%';
Variable_name				Value
innodb_data_home_dir		/home/mysql/mysql/var
```

#### 撤销表空间

### 表碎片清理和表空间收缩

OPTIMIZE TABLE ipvacloud.report_site_day;

对myisam表有用  对innodb也有用，系统会自动把它转成 ALTER TABLE  report_site_day ENGINE = Innodb; 这是因为optimize table的本质，就是alter table

所以不管myisam引擎还是innodb引擎都可以使用OPTIMIZE TABLE回收表空间。

#### 存储模式

**MySQL5.5默认是共享表空间 ，5.6中默认是独立表空间(表空间管理类型就这2种)** 

独立表空间 就是采用和MyISAM 相同的方式, 每个表拥有一个独立的数据文件( .idb )

1.每个表都有自已独立的表空间。
2.每个表的数据和索引都会存在自已的表空间中。
3.可以实现单表在不同的数据库中移动(将一个库的表移动到另一个库里,可以正常使用)。
4.drop table自动回收表空间 ，删除大量数据后可以通过alter table XX engine = innodb;回收空间。

**InnoDB引擎 frm ibd文件说明：**
   1.frm ：描述表结构文件，字段长度等
   2.ibd文件 
         **a如果采用独立表存储模式(5.6)，data\a中还会产生report_site_day.ibd文件（存储数据信息和索引信息）**

​         D:\java\mysql5.6\data\ipvacloudreport_site_day.frm 和

​         D:\java\mysql5.6\data\ipvacloud\report_site_day.ibd

​         **b如果采用共享存储模式(5.5)，数据信息和索引信息都存储在ibdata1中**
​          (其D:\java\mysql5.6\data\目录下没有.ibd文件,只有frm文件)

### 表空间操作

#### 创建

```mysql
【语法】

CREATE TABLESPACE 表空间名
DATAFILE '数据文件路径' SIZE 大小
[AUTOEXTEND ON] [NEXT 大小]
[MAXSIZE 大小];

 
【说明】[]里面内容可选项；数据文件路径中若包含目录需要先创建
SIZE为初始表空间大小，单位为K或者M
AUTOEXTEND ON 是否自动扩展
NEXT为文件满了后扩展大小
MAXSIZE为文件最大大小，值为数值或UNLIMITED（表示不限大小）
```



```mysql
> create tablespace DAMSDB_DATA datafile '/opt/gdbservice/data/data/DAMSDB_DATA.dbf' size 1024M autoextend on next 1024M MAXSIZE 102400M;
```





[MySQL的表空间](https://www.cnblogs.com/better-farther-world2099/articles/14713523.html)

[表空间使用方法 （Oracle）](https://blog.csdn.net/qq_41548307/article/details/84029864)









































### Profiles

> 根据环境参数来调整构建配置的列表 

### Repositories

> 远程仓库列表，它是maven用来填充构建系统本地仓库所使用的一组远程仓库 

```xml
<repositories>
    <!--包含需要连接到远程仓库的信息 -->
    <repository>
        <!--远程仓库唯一标识 -->
        <id>codehausSnapshots</id>
        <!--远程仓库名称 -->
        <name>Codehaus Snapshots</name>
        <!--如何处理远程仓库里发布版本的下载 -->
        <releases>
            <!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 -->
            <enabled>false</enabled>
            <!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 -->
            <updatePolicy>always</updatePolicy>
            <!--当Maven验证构件校验文件失败时该怎么做-ignore（忽略），fail（失败），或者warn（警告）。 -->
            <checksumPolicy>warn</checksumPolicy>
        </releases>
        <!--如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 -->
        <snapshots>
            <enabled />
            <updatePolicy />
            <checksumPolicy />
        </snapshots>
        <!--远程仓库URL，按protocol://hostname/path形式 -->
        <url>http://snapshots.maven.codehaus.org/maven2</url>
        <!--用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 -->
        <layout>default</layout>
    </repository>
</repositories>
```

#### 仓库类型

maven中的仓库分为两种，**snapshot快照仓库**和**release发布仓库**。snapshot快照仓库用于保存开发过程中的不稳定版本，release正式仓库则是用来保存稳定的发行版本。定义一个组件/模块为快照版本，只需要在pom文件中在该模块的版本号后加上-SNAPSHOT即可(注意这里必须是大写)，如下： 

```xml
<groupId>cc.mzone</groupId>  
<artifactId>m1</artifactId>  
<version>0.1-SNAPSHOT</version>
<packaging>jar</packaging> 
```

maven的依赖管理是基于版本管理的，对于发布状态的artifact，如果版本号相同，即使我们内部的镜像服务器上的组件比本地新，maven也不会主动下载的。 

maven会根据模块的版本号(pom文件中的version)中是否带有-SNAPSHOT来判断是快照版本还是正式版本。如果是快照版本，那么在mvn deploy时会自动发布到快照版本库中，而使用快照版本的模块，在不更改版本号的情况下，直接编译打包时，maven会自动从镜像服务器上下载最新的快照版本。如果是正式发布版本，那么在mvn deploy时会自动发布到正式版本库中，而使用正式版本的模块，在不更改版本号的情况下，编译打包时如果本地已经存在该版本的模块则不会主动去镜像服务器上下载。 

所以，我们在开发阶段，可以将公用库的版本设置为快照版本，而被依赖组件则引用快照版本进行开发，在公用库的快照版本更新后，我们也不需要修改pom文件提示版本号来下载新的版本，直接mvn执行相关编译、打包命令即可重新下载最新的快照库了，从而也方便了我们进行开发。 

### distributionManagement 

> 定义了发布仓库的地址，应用snapshot和release库达到不同环境下发布不同的版本的目的 

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"  
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">  
    <modelVersion>4.0.0</modelVersion>  
    <groupId>net.aty.mybatis</groupId>  
    <artifactId>mybatis-demo</artifactId>  
    <packaging>jar</packaging>  
    <version>${project.release.version}</version>  
    <name>mybatis-demo</name>  
    <url>http://maven.apache.org</url>  

    <properties>  
        <project.release.version>0.1-SNAPSHOT</project.release.version>  
    </properties>  

    <profiles>  
        <profile>  
            <id>release</id>  
            <properties>  
                <project.release.version>0.1</project.release.version>  
            </properties>  
        </profile>  
    </profiles>  

    <!--定义snapshots库和releases库的nexus地址-->  
    <distributionManagement>  
        <repository>  
            <id>nexus-releases</id>  
            <url>  
                http://172.17.103.59:8081/nexus/content/repositories/releases/  
            </url>  
        </repository>  
        <snapshotRepository>  
            <id>nexus-snapshots</id>  
            <url>  
                http://172.17.103.59:8081/nexus/content/repositories/snapshots/  
            </url>  
        </snapshotRepository>  
    </distributionManagement>  
</project>  
```

首先我们看到pom文件中version的定义是采用占位符的形式，这样的好处是可以根据不同的profile来替换版本信息，比如maven默认是使用0.1-SNAPSHOT作为该模块的版本。

1、如果在发布时使用mvn deploy -P release 的命令，那么会自动使用0.1作为发布版本，那么根据maven处理snapshot和release的规则，由于版本号后不带-SNAPSHOT故当成是正式发布版本，会被发布到release仓库；
2、如果发布时使用mvn deploy命令，那么就会使用默认的版本号0.1-SNAPSHOT，此时maven会认为是快照版本，会自动发布到快照版本库。

[<distributionManagement > ](https://www.cnblogs.com/liu2-/p/9035181.html)

### pluginRepositories

> 发现插件的远程仓库列表 

和`repository`类似，只是`repository`是管理jar包依赖的仓库，`pluginRepositories`则是管理插件的仓库。 maven插件是一种特殊类型的构件。由于这个原因，插件仓库独立于其它仓库。

```xml
<pluginRepositories>
    <!-- 包含需要连接到远程插件仓库的信息.参见profiles/profile/repositories/repository元素的说明 -->
    <pluginRepository>
        <releases>
            <enabled />
            <updatePolicy />
            <checksumPolicy />
        </releases>
        <snapshots>
            <enabled />
            <updatePolicy />
            <checksumPolicy />
        </snapshots>
        <id />
        <name />
        <url />
        <layout />
    </pluginRepository>
</pluginRepositories>
```

[maven全局配置文件settings.xml详解](https://www.cnblogs.com/jingmoxukong/p/6050172.html)

## Profiles

> 每个profile对应不同的激活条件和配置信息 ，多个profile可以实现不同环境使用不同配置信息。

### 定义信息

`settings.xml`中的`profile`元素是`pom.xml`中`profile`元素的**裁剪版本**。 

#### 定义在settings.xml中

当profile定义在settings.xml中时意味着该profile是全局的，它会对所有项目或者某一用户的所有项目都产生作用

能够定义在settings.xml中的profile信息有

`<repositories>`

`<pluginRepositories>`

`<properties>`

`activation  `

`id`

定义在`<properties>`里面的键值对可以在pom.xml中使用

#### 定义在pom.xml中

定义在pom.xml中的profile可以定义更多的信息。主要有以下这些：

`<repositories>`

`<pluginRepositories>`

`<dependencies>`

`<plugins>`

`<properties>`

`<dependencyManagement>`

`<distributionManagement>`

还有build元素下面的子元素，主要包括：

`<defaultGoal>`

`<resources>`

`<testResources>`

`<finalName>`

### 激活方式

```sh
#查看处于激活状态的profile
$ mvn help:active-profiles
```

#### -P命令参数

```sh
#激活profileTest
$ mvn package –P profileTest
```

```sh
#当我们使用activeByDefault或settings.xml中定义了处于激活的profile，但是当我们在进行某些操作的时候又不想它处于激活状态，这个时候我们可以这样做： 
$ mvn package –P !profileTest1
#假设profileTest1是在settings.xml中使用activeProfile标记的处于激活状态的profile，那么当我们使用“-P !profile”的时候就表示在当前操作中该profile将不处于激活状态。 
```

#### activation

```xml
<profiles>  
    <profile> 
        <activation>
            <!--profile默认是否激活的标识，当没有指定条件，然后指定activeByDefault为true的时候就表示当没有指定其他profile为激活状态时，该profile就默认会被激活。  -->
            <activeByDefault>false</activeByDefault>
            <!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK，[1.4,1.7)在jdk为1.4、1.5和1.6的时候激活   -->
            <jdk>1.5</jdk>
            <!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 -->
            <os>
                <!--激活profile的操作系统的名字 -->
                <name>Windows XP</name>
                <!--激活profile的操作系统所属家族(如 'windows') -->
                <family>Windows</family>
                <!--激活profile的操作系统体系结构 -->
                <arch>x86</arch>
                <!--激活profile的操作系统版本 -->
                <version>5.1.2600</version>
            </os>
            <!--如果Maven检测到某一个属性（其值可以在POM中通过${name}引用），其拥有对应的name = value，Profile就会被激活。如果value字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段。当提供了系统属性mavenVersion，并且其值为2.0.3的时候激活,或者直接使用命令激活"mvn package –DmavenVersion=2.0.3" -->
            <property>
                <!--激活profile的属性的名称 -->
                <name>mavenVersion</name>
                <!--激活profile的属性的值 -->
                <value>2.0.3</value>
            </property>
            <!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 -->
            <file>
                <!--如果指定的文件存在，则激活profile。 -->
                <exists>${basedir}/file2.properties</exists>
                <!--如果指定的文件不存在，则激活profile。 -->
                <missing>${basedir}/file1.properties</missing>
            </file>
        </activation>
    </profile>  
</profiles> 
```

#### activeProfiles

> 可以在settings.xml中使用activeProfiles来指定需要激活的profile，这种方式激活的profile将所有情况下都处于激活状态。 

```xml
<profiles>  
    <profile>  
        <id>profileTest1</id>  
        <properties>  
            <hello>world</hello>  
        </properties>  
    </profile>  

    <profile>  
        <id>profileTest2</id>  
        <properties>  
            <hello>andy</hello>  
        </properties>  
    </profile>  
</profiles>

<activeProfiles>  
     <activeProfile>profileTest1</activeProfile>  
</activeProfiles>  
```

```xml
<!-- 在activeProfiles下同时定义了多个需要激活的profile -->
<activeProfiles>  
    <activeProfile>profileTest1</activeProfile>  
    <activeProfile>profileTest2</activeProfile>  
</activeProfiles>
<!-- 不是根据activeProfile定义的顺序，后面的覆盖前面的。而是根据profile定义的先后顺序来进行覆盖取值的，然后后面定义的会覆盖前面定义的 -->
```

[Maven简介（三）——profile介绍](https://www.iteye.com/blog/elim-1900568)

## try-with-resource

- 传统的`try-finally`方式存在复杂易出错和异常抑制(Suppressed)等问题。 使用`try-with-resource`，可以更安全、简洁地申请和关闭资源，同时解决了异常抑制问题。 
- `try-with-resource`是语法糖，其最终仍然会被编译成`try-finally`方式并调用close方法关闭资源。 
- 为了支持`try-with-resource`，资源类必须要实现`AutoClosable接口`，否则无法使用。在使用`try-with-resource`之前，请务必确认下资源类是否已经实现了`AutoClosable接口`。
- `try-with-resource`使用方式
  - `try-with-resource`使用很简单，申请资源的代码写在try后面的()中即可，无需显式调用`close方法`来关闭资源。 
  - 为了使程序更加健壮，在`try-with-resouce`中使用装饰器时，建议显式声明被装饰/包裹对象的引用。 

### 使用

能够借助`try-with-resource`关闭资源的类必须实现`AutoClosable接口`，重写`close方法`。如果是自定义资源类， 为了支持`try-with-resource`，请务必实现`AutoClosable接口`。 

```java
//申请资源的代码写在try后面的()中即可，资源关闭无需显式close
public void twrClose2NotCatch(String src, String dst) throws IOException {
    try (FileInputStream ins = new FileInputStream(src);
         OutputStream outs = new FileOutputStream(dst)) {
        byte[] buf = new byte[BUF_SIZE];
        int n;
        while ((n = ins.read(buf)) >= 0) {
            outs.write(buf, 0, n);
        }
    }
}
```

`try-with-resource`主要做了两件事：

- 添加调用close方法的代码，关闭资源。
- 使用addSuppressed方法附加异常，消除异常抑制的问题。

#### try-finally举例

##### 异常抑制

异常抑制（Suppressed）也有叫异常覆盖和异常屏蔽

```java
public class ConnectionNormal {
    public void send() throws Exception {
        throw new SendException("send fail.");
    }

    public void close() throws Exception {
        throw new CloseException("close fail");
    }
}

//按照程序逻辑，应该先抛出SendException，再抛出CloseException：
public static void main(String[] args) {
    try {
        test();
    } catch (Exception e) {
        e.printStackTrace();
    }
}


private static void test() throws Exception {
    ConnectionNormal conn = null;
    try {
        conn = new ConnectionNormal();
        conn.send();
    } finally {
        if (conn != null) {
            conn.close();
        }
    }
}

//运行后我们发现：
com.CloseException: close fail
at com.ConnectionNormal.close(ConnectionNormal.java:10)
    at com.TryWithResource.test(TryWithResource.java:20)
    at com.TryWithResource.main(TryWithResource.java:6)
```

SendException明明先被抛出了，但是没有丝毫痕迹，被后抛的CloseException给抑制了，这就是异常抑制，SendException被称为Suppressed Exception。关键的异常信息丢失，这会导致某些bug变得极其隐蔽而难以发现！

#### try-with-resource举例

`try-with-resource`为`Throwable类`新增了`addSuppressed方法`，支持将一个异常附加到另一个之上，从而解决异常抑制。

```java
public class ConnectionAutoClose implements AutoCloseable{
    public void send() throws Exception {
        throw new SendException("send fail.");
    }
    @Override
    public void close() throws Exception {
        throw new CloseException("close fail");
    }
}

private static void test2() {
    try (ConnectionAutoClose conn = new ConnectionAutoClose()) {
        conn.send();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

运行结果：
com.SendException: send fail.
    at com.ConnectionAutoClose.send(ConnectionAutoClose.java:5)
    at com.TryWithResource.test2(TryWithResource.java:27)
    at com.TryWithResource.main(TryWithResource.java:6)
    Suppressed: com.CloseException: close fail
at com.ConnectionAutoClose.close(ConnectionAutoClose.java:10)
        at com.TryWithResource.test2(TryWithResource.java:28)
        ... 1 more
```

### 原理

```java
//try-with-resource反编译.class
private static void test2() {
    try {
        ConnectionAutoClose conn = new ConnectionAutoClose();
        Throwable var1 = null;
        try {
            conn.send();
        } catch (Throwable var11) {
            var1 = var11;
            throw var11;
        } finally {
            if (conn != null) {
                if (var1 != null) {
                    try {
                        conn.close();
                    } catch (Throwable var10) {
                        var1.addSuppressed(var10);
                    }
                } else {
                    conn.close();
                }
            }
        }
    } catch (Exception var13) {
        var13.printStackTrace();
    }
}
```

### 显式声明

为了使程序更加健壮，在try-with-resouce中使用装饰器时，建议显式声明被装饰 / 包裹对象的引用。

```java
//在finally中仅调用了out.close()，在GZIPOutputStream.close内部，会关闭被包裹的FileOutputStream，但是这个关闭可能会失败
public void gzipWrapper(File file) throws IOException {
   try (GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(file))) {
      ...
  }
}
```

```java
//fout.close一定会被调用
public void gzipWrapperRobust(File file) throws IOException {
   try (FileOutputStream fout = new FileOutputStream(file); // 显式声明
        GZIPOutputStream out = new GZIPOutputStream(fout)) {
      ...
  }
}
```



## 正则表达式

```java
//IPv4的地址格式，总长度 32位=4段*8位，每段之间用.分割， 每段都是0-255之间的十进制数值
System.out.println("10.45.168.74".matches("^((25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d)))\\.){3}(25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d)))$"));
//端口号0-65535
System.out.println("8080".matches("^([0-9]|[1-9]\\d|[1-9]\\d{2}|[1-9]\\d{3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5])$"));
```



## Java基础

### 类型强转

```java
Object obj;
List<Integer> list = castList(obj,Integer.class);
//list强转
private static <T> List<T> castList(Object obj, Class<T> clazz) {
    List<T> result = new ArrayList<T>();
    if (obj instanceof List<?>) {
        for (Object o : (List<?>) obj) {
            result.add(clazz.cast(o));
        }
        return result;
    }
    return null;
}
```

```java
Object obj;
Map<String,Object> map = castHashMap(obj,String.class,Object.class);

/**
 * 防止出现强转警告
 *
 * @param obj 强转对象
 * @param clazz1 HashMap的key
 * @param clazz2 HashMap的value
 * @param <K> Key泛型
 * @param <V> Value泛型
 * @return 强转后对象
 */
private <K, V> HashMap<K, V> castHashMap(Object obj, Class<K> clazz1, Class<V> clazz2) {
    HashMap<K, V> result = new HashMap<K, V>();
    if (obj instanceof HashMap<?, ?>) {
        for (Object o : ((HashMap<?, ?>) obj).keySet()) {
            result.put(clazz1.cast(o), clazz2.cast(((HashMap<?, ?>) obj).get(o)));
        }
        return result;
    }
    return null;
}
```



## 解压tar包

```java
private static final int BUFFER = 512;
private static final int TOOBIG = 0x6400000; // max size of unzipped data, 100MB
private static final int TOOMANY = 1024; // max number of files

public static void main(String[] args) {
    String sourcePath = "";
    String destDir = "";
    TarEntry entry;
    //接收byte[]数据  TarInputStream tis = new TarInputStream(new ByteArrayInputStream(sourceData))
    try (FileInputStream fis = new FileInputStream(sourcePath);
         TarInputStream tis = new TarInputStream(fis)) {
        while ((entry = tis.getNextEntry()) != null) {
            int total = 0;
            int entries = 0;
            byte[] data = new byte[BUFFER];
            String destPath = FileUtil.sanitzeFileName(entry.getName(), destDir);
            int count;
            try (FileOutputStream fos = new FileOutputStream(destPath)) {
                while ((count = tis.read(data, 0, BUFFER)) != -1) {
                    total += count;
                    if (total > TOOBIG) {
                        log.error("fileSize in package is too big");
                    }
                    fos.write(data, 0, count);
                }
                if (++entries > TOOMANY) {
                    log.error("fileNum in package is too many");
                }
            }
        }
    } catch (IOException e) {
        log.error("decompressTar error", e);
    }
}

/**
 * 文件路径检查
 *
 * @param entryName 文件名称
 * @param intendedDir 文件路径
 * @return 文件全路径
 * @throws IOException
 */
public static String sanitzeFileName(String entryName, String intendedDir) throws IOException {
    String canonicalPath = new File(intendedDir, entryName).getCanonicalPath();
    String canonicalID = new File(intendedDir).getCanonicalPath();
    if (canonicalPath.startsWith(canonicalID)) {
        return canonicalPath;
    } else {
        throw new IllegalStateException("File is outside extraction target directory.");
    }
}
```

## 数据运算越界检查

> oldAcc + (newVal * scale)

### 先决条件检查 

```java
public int safeAdd(int left, int right) {
    if (right > 0 ? left > Integer.MAX_VALUE - right
        : left < Integer.MIN_VALUE - right) {
        throw new ArithmeticException("Integer overflow");
    }
    return left + right;
}

//Java数据类型的合法取值范围是不对称的（最小值的绝对值比最大值大1），所以对最小值取负时，会导致溢出。
public int safeMultiply(int left, int right) {
    if (right > 0 ? left > Integer.MAX_VALUE / right
        || left < Integer.MIN_VALUE / right
        : (right < -1 ? left > Integer.MIN_VALUE / right 
           || left < Integer.MAX_VALUE / right
           : right == -1 && left == Integer.MIN_VALUE)) {
        throw new ArithmeticException("Integer overflow");
    }
    return left * right;
}
```

### 向上类型转换 

该方式对long类型不适用。 

```java
public static long intRangeCheck(long value) {
    // 向上类型转换
    if ((value < Integer.MIN_VALUE) || (value > Integer.MAX_VALUE)) {
        throw new ArithmeticException("Integer overflow");
    }
    return value;
}

public static int multAccum(int oldAcc, int newVal, int scale) {
    final long res = intRangeCheck(((long) oldAcc) +
                                   intRangeCheck((long) newVal * (long) scale));
    return (int) res; // Safe downcast
}
```

### BigInteger 

```java
private static final BigInteger bigMaxInt = BigInteger.valueOf(Integer.MAX_VALUE);
private static final BigInteger bigMinInt = BigInteger.valueOf(Integer.MIN_VALUE);
// BigInteger检查是否存在溢出
public static BigInteger intRangeCheck(BigInteger val) {
    if (val.compareTo(bigMaxInt) == 1 || val.compareTo(bigMinInt) == -1) {
        throw new ArithmeticException("Integer overflow");
    }
    return val;
}

public static int multAccum(int oldAcc, int newVal, int scale) {
    BigInteger product = BigInteger.valueOf(newVal).multiply(BigInteger.valueOf(scale));
    BigInteger res = intRangeCheck(BigInteger.valueOf(oldAcc).add(product));
    return res.intValue(); // Safe conversion
}
```

## Normalizer.normalize()

normalize方法对外部输入字符串做归一化/标准化处理，如：

```java
//将全角形式的字符转化为半角形式的字符，"＜root＞"-->"<root>"
Normalizer.normalize(str,Normalizer.Form.NFKC);
```

[关于Normalizer.normalize()方法的用途](https://blog.csdn.net/u010512607/article/details/79921353)

## @PostConstruct和@PreDestory执行顺序

构造函数==》postConstruct==>init==destory==>predestory==卸载servlet;;  



## Git

### 首次提交代码到远程仓库

1. 首先，登录GitLab，创建一个新项目的私人仓库； 

2. 然后，在本地仓库（就是你写代码文件夹），右键，Git Bash Here，打开Git命令窗口； 

3. 按照如下步骤，添加远程仓库地址，并提交代码；  

   ```sh
   git init                           #初始化仓库
   git add .						 #把所有文件和文件夹添加到；
   git commit -m "first commit"       #把代码提交到本地仓库，并备注信息；
   git remote add origin 仓库地址      #设置远程仓库地址，创建远程主分支；
   git pull origin master 		       #把本地仓库的变化连接到远程仓库主分支
   git push -u origin master          #提交代码到远程仓库，master分支；
   ```

   **问题：**

   1) 添加远程仓库可能报错：`fatal: remote origin already exists.` 

   ```sh
   git remote -v：             #查看远程仓库详细信息，可以看到仓库名称
   git remote rm origin        #先删除远程 Git 仓库
   git remote add origin 仓库地址      #再添加远程 Git 仓库
   
   #也可以手动修改gitconfig文件的内容，把 [remote “origin”] 那一行删掉就好了
   vi .git/config              
   ```

   2) 不使用pull直接push可能报如下错误：`Updates were rejected because the remote contains work that you do`

   3)直接使用pull可能报如下错误：`fatal: refusing to merge unrelated histories` 

   ```sh
   git pull origin master --allow-unrelated-histories
   ```

   

### 将文件取消版本控制

以idea为例：

如果在.gitignore文件中没有指定忽略.idea文件夹（这个文件夹包含的是本地对项目的配置，如maven，字符编码等，不需要共享，所以无需提交），那么提交时就会将其提交到远程代码库中。如果已经.idea已经在远程仓库，那么再修改.gitignore文件就已经没用了，所以需要通过命令将远程的.idea文件夹取消版本控制

```sh
git rm -r --cached "要取消版本控制的文件或文件夹"		#将文件或文件夹取消版本控制
git commit -m "提交的信息"						  #提交到本地仓库 
git push origin master				#提交到远程分支，远程仓库的文件或文件夹将会被删除
```

最后在.gitignore文件中添加忽略.idea文件夹，并提交到远程仓库，如果需要将.idea文件夹添加版本控制，只需要将.gitignore文件中的.idea/删除即可

## Path

### jar包加载文件路径

a.txt 和 Application.java 在同一个目录下，b.txt 在类路径下

```java
public class Application {
    public static void main(String[] args) throws IOException {
        System.out.println(Application.class.getResource(""));
        System.out.println(Application.class.getResource("a.txt"));

        System.out.println(Application.class.getResource("/"));
        System.out.println(Application.class.getResource("/b.txt"));
        getFileContent(Application.class.getResource("/b.txt").getPath());

        System.out.println(Application.class.getClassLoader().getResource(""));
        System.out.println(Application.class.getClassLoader().getResource("b.txt"));
        getFileContent(Application.class.getClassLoader().getResource("b.txt").getPath());

        //报错空指针异常
        /*InputStream is = Application.class.getResourceAsStream("a.txt");
        byte[] bytes = new byte[100];
        is.read(bytes);
        System.out.println(new String(bytes));*/
        InputStream is2 = Application.class.getClassLoader().getResourceAsStream("b.txt");
        byte[] bytes2 = new byte[5];
        is2.read(bytes2);
        System.out.println(new String(bytes2));

    }

    private static void getFileContent(String path) throws IOException {
        FileInputStream fi=new FileInputStream(path);
        byte[] bytes = new byte[5];
        fi.read(bytes);
        System.out.println(new String(bytes));
    }
}

//本地输出
file:/E:/IdeaProjects/redis-master/redis-test/target/classes/com/huawei/fusioninsight/test/
null
    
file:/E:/IdeaProjects/redis-master/redis-test/target/classes/
file:/E:/IdeaProjects/redis-master/redis-test/target/classes/b.txt
bbbbb

file:/E:/IdeaProjects/redis-master/redis-test/target/classes/
file:/E:/IdeaProjects/redis-master/redis-test/target/classes/b.txt
bbbbb

bbbbb

//打成jar包输出
PS E:\IdeaProjects\redis-master\redis-test\target\jars> java -jar redis-test.jar

jar:file:/E:/IdeaProjects/redis-master/redis-test/target/jars/redis-test.jar!/com/huawei/fusioninsight/test/
null
    
null
jar:file:/E:/IdeaProjects/redis-master/redis-test/target/jars/redis-test.jar!/b.txt
java.io.FileNotFoundException: file:\E:\IdeaProjects\redis-master\redis-test\target\jars\redis-test.jar!\b.txt (文件名、目录名或卷标语法不正确。)

null
jar:file:/E:/IdeaProjects/redis-master/redis-test/target/jars/redis-test.jar!/b.txt
java.io.FileNotFoundException: file:\E:\IdeaProjects\redis-master\redis-test\target\jars\redis-test.jar!\b.txt (文件名、目录名或卷标语法不正确。)

bbbbb
```

- 编译时只会加载在类路径下的文件
- 打成 jar 包后无法获取类路径目录，但是可以获取类路径下具体文件路径
- 读取文件无法识别 redis-test.jar! 目录，只能使用 getResourceAsStream 方法读取文件

[Java代码打成jar后 classgetClassLoadergetResource("")返回为null](https://blog.csdn.net/wqc19920906/article/details/79263269)

[读取Jar包中的资源问题探究](https://blog.csdn.net/withiter/article/details/11924095)





## Java基础

### java -cp命令

jvm搜索类，系统会先在当前包下找，然后会在 jre 中的 rt.jar 文件下找，最后会在 classpath 所指向的路径下找； -cp 即 -classpath，可以指定classpath；java -cp 和 -classpath 一样，是指定类运行所依赖其他类的路径，通常是类库，jar包之类，需要全路径到jar包 。

```sh
#windows
#编译
$ javac -cp 绝对路径1.jar;绝对路径2.jar java文件名.java

#运行
$ java -cp .;../lib/*;../common.jar;../list/*.jar;../conf packname.mainclassname(此类有main方法)
```

```sh
#linux
#编译
$ javac -cp 绝对路径1.jar:绝对路径2.jar java文件名.java

#运行
$ java -cp .:../lib/*:../common.jar:../list/*.jar:../conf packname.mainclassname(此类有main方法)
```



### 引用 jar 包中的 jar 包

 [java命令执行jar包的方式](https://www.cnblogs.com/zpbolgs/p/7267384.html)

### 启动 jar 包

jar 包内目录 META-INF 下的 MANIFEST.MF 文件可以指定入口的方法，

```java
//META-INF\MANIFEST.MF的内容：
Manifest-Version: 1.0 
Main-Class: test.core.Core 
```

```sh
#pom中build指定mainClass && META-INF\MANIFEST.MF文件中增加了Main-Class: test.core.Core
$ java -cp test-jar-with-dependencies.jar  test.core.Core  //执行成功
$ java -jar test-jar-with-dependencies.jar  //执行成功
```

[启动jar包](https://www.cnblogs.com/klb561/p/10850803.html)






































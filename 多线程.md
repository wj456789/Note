多线程

## 线程概念

### 进程

进程是操作系统中进行资源分配的基本单位，多个进程可以在单个处理器上并发执行。

**进程是状态：**

![img](img_%E5%A4%9A%E7%BA%BF%E7%A8%8B/clipboard-1628380619040.png)

**并发性与并行性的区别**

**并行性：**指在同一时刻，有多条指令在多个处理器上同时执行；

**并发性：**指在同一时刻只能有一条指令执行。但多个进程指令被快速轮换执行，使得宏观上具有多个进程同时执行的效果。

### 线程

线程是进程的执行单元，是进程的组成部分，一个进程可以拥有多个线程，每个线程是独立运行的。

### 进程和线程关系

1. 操作系统可以执行多个任务，每个任务就是进程。一个进程又可以执行多个任务，其中每个任务就是线程。

2. 进程从操作系统获得基本的内存空间，每个进程的地址空间都是独立的，所有的线程共享着进程的内存地址空间。当然，每个线程也会拥有自己私有的内存地址范围，其他线程不能访问。

3. 系统创建进程时需要为该进程重新分配系统资源，但创建线程则代价小很多，同时每一次的进程上下文切换都会消耗系统资源，因此使用多线程来实现多个任务并发比多进程的效率高。

## 创建线程

### 继承Thread类创建线程类

```java
public class Demo {
    private static void main(String[] args) {
        // 通过Thread类的currentThread方法可以得到当前的线程名
        System.out.println(Thread.currentThread().getName());
        new FirstThread().start();
    }
}

// 通过继承Thread类来创建线程类
class FirstThread extends Thread {
    // 重写run（）方法，run（）方法的方法体是线程的执行体
    @Override
    public void run() {
        super.run();
        // 当线程类继承Thread时，直接使用this通过getName()即可获取到当前的线程名
        System.out.println(this.getName());
    }
}
```

### 实现Runnable接口创建线程类

```java
public class Demo {
    private static void main(String[] args) {
        // 通过Thread类的currentThread方法可以得到当前的线程名
        System.out.println(Thread.currentThread().getName());
        //通过new Thread(target,name)方式创建新线程
        SecondRunnable secondRunnable = new  SecondRunnable();
        new Thread(secondRunnable, "线程").start();
    }
}

// 通过实现Runnable接口创建线程类
class SecondRunnable implements Runnable{
    // 重写run（）方法，run（）方法的方法体是线程的执行体
    @Override
    public void run() {
        //当使用Runnable接口实现线程类时，若要得到当前的线程名称，只能用Thread.currendThread（）方法
        System.out.println(Thread.currentThread().getName());
    }
}
```

### 使用Callable和Future创建线程

```java
public class Demo {
    private static void main(String[] args) {
        //创建Callable对象
        ThirdCallable callable = new  ThirdCallable();
        //创建FutureTask对象，并把callable以形参的方式传入FutureTask的构造方法内
        FutureTask<String> futureTask = new FutureTask<>(callable);
        // 通过Thread类的currentThread方法可以得到当前的线程名
        System.out.println(Thread.currentThread().getName());
        //创建线程并启动
        new Thread(futureTask, "有返回值的线程").start();
        
        //获取子线程的返回值
        try {
            System.out.println("子线程的返回值： "+futureTask.get());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
    }
}

class ThirdCallable implements Callable<String> {
    //call()方法称之为线程方法执行体，且该方法有返回值，可通过FutureTask实例对象调用get()方法得到子线程的返回值
    @Override
    public String call() throws Exception {
        return Thread.currentThread().getName();
    }

}
```

使用实现Runnable 、Callable接口的方式创建多线程，线程类只是实现了Runnable接口或Callable接口，同时还可以继承其他类。多个线程可以共享一个target对象(Runnable或Callable)，非常适合多个相同线程来处理同一份资源的情况。

## 生命周期

线程状态的5个状态具体分别是：

**新建状态（New）、就绪状态（Runnable）、运行状态（Running）、阻塞状态（Blocked）、死亡状态（Dead）**





![img](img_%E5%A4%9A%E7%BA%BF%E7%A8%8B/clipboard.png)



**阻塞状态（Blocked）**

这是线程仍处于活动状态但暂时放弃对CPU的使用权，停止执行时的状态。

线程进入阻塞的三种状态：

**1、等待阻塞：**

线程调用wait()方法，使本线程进入到等待状态；

**2、同步阻塞**

线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；

**3、其他阻塞**

通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待别的线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。



注意：Thread.interrupt()方法不会中断一个正在运行的线程。这一方法实际上完成的是，在线程受到阻塞时抛出一个中断信号，这样线程就得以退出阻塞的状态。更确切的说，如果线程被Object.wait, Thread.join和Thread.sleep三种方法之一阻塞，那么，它将接收到一个中断异常（InterruptedException），从而提早地终结被阻塞状态。

[注意Thread.interrupt()方法的真正作用并不是用来中断线程](https://www.cnblogs.com/yepei/p/4856622.html)



## 控制线程

### 后台线程

后台线程，它是在后台运行的，如果**所有的前台线程都死亡**了，后台线程也会自动死亡，这种线程被称为“后台线程（Daemon Thread）”,又称为“守护线程”或“精灵线程”。JVM的垃圾回收线程就是典型的后台线程。

```java
public class DaemonThreadTest {
    public static void main(String[] args) {
        DaemonThread daemonThread= new DaemonThread("后台线程");
        daemonThread.setDaemon(true);//设置为后台线程，注意必须在start前调用，否则会报错！
        daemonThread.start();
        try {
            Thread.sleep(5000);//睡眠5秒
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("执行完毕");
    }
}

class DaemonThread extends Thread{
    public DaemonThread(String name){
        super(name);
    }
    @Override
    public void run(){
        for(int i=0;i<100;i++){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(getName()+"->"+i);
        }
    }
}
```

### Join等待线程

Thread类中的join方法的主要作用就是同步，它可以使得线程之间的并发执行变为串行执行。即放弃当前线程的执行，等待调用join的线程结束，当前线程才能继续执行。

```java
public class JoinTest {
    public static void main(String [] args) throws InterruptedException {
        ThreadJoinTest t1 = new ThreadJoinTest();
        ThreadJoinTest t2 = new ThreadJoinTest();
        t1.start();
        //在main线程中调用了t1线程的join()方法时，表示只有当t1线程执行完毕时，main线程才能继续执行。
         
        /*
        1、join方法可以也传递参数，join(10)表示main线程会等待t1线程10毫秒，10毫秒过去后，main线程和t1线程之间执行顺序由串行执行变为普通的并发执行
        2、join(0)等价于join()，等待t1线程无限时间
        3、join方法必须在线程start方法调用之后调用，否则不能起到同步的作用
        */
        t1.join();
        t2.start();
    }
}
```

### sleep

#### 方法

```java
//线程睡眠 millis 毫秒
public static native void sleep(long millis) throws InterruptedException;
//线程睡眠 millis 毫秒 + nanos 纳秒
public static void sleep(long millis, int nanos) throws InterruptedException
```

静态方法可以直接调用Thread.sleep()

#### 实例

```java
public class Thread1 {
    public static void main(String[] args) {
        public static void main(String[] args) {
        Thread t = new SleepThread();
        t.start();
        System.out.println("启动SleepThread线程");
        try {
            //sleep方法只能让当前线程睡眠。调用某一个线程类的对象t.sleep()或SleepThread.sleep()，睡眠的不是t，而是当前线程main
            SleepThread.sleep(5000); //此处是类名.sleep()，也可以是t.sleep()
            System.out.println("当前运行的线程名称： "+ SleepThread.currentThread().getName());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    }
}

class SleepThread implements Thread{
    @Override
    public void run() {
        for(int i=0;i<100;i++){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            System.out.println(getName()+"->"+i);
        }
        
    }
}

输出：
启动SleepThread线程
Thread-0->0
Thread-0->1
Thread-0->2
Thread-0->3
当前运行的线程名称： main
Thread-0->4
Thread-0->5
Thread-0->6
```

控制线程睡眠的方法还有一种：

- TimeUnit.SECONDS.sleep(1);
- TimeUnit.MINUTES.sleep(1);
- TimeUnit.HOURS.sleep(1);
- TimeUnit.DAYS.sleep(1);



### 线程优先级

- 每个线程在执行时都具有一定的优先级，优先级高的线程获得较多的执行机会，而优先级低的线程则获得较少的执行机会。
- 在多线程中线程的执行顺序是依靠哪个线程先获得到CPU的执行权谁就先执行，但是获取CPU执行权的概率高点，但是也不一定必须先执行
- 每个线程默认的优先级都与创建它的父线程的优先级相同，在默认情况下，main线程具有普通优先级，由main线程创建的子线程也具有普通优先级。

-  java 中的线程优先级的范围是1～10，1的优先级最低，10的优先级最高。

通过setPriority()方法，可以改变线程的优先级。

```java
public static void main(String[] args){
	// 改变主线程的优先级
    Thread.currentThread().setPriority(6);
    for (int i = 0 ; i < 30 ; i++ ){
        if (i == 10){
            PriorityThreadTest low  = new PriorityThreadTest("低级");
            low.start();
            // 设置该线程为最低优先级
            low.setPriority(Thread.MIN_PRIORITY);
        }
        if (i == 20){
            PriorityThreadTest high = new PriorityThreadTest("高级");
            high.start();
            // 设置该线程为最高优先级
            high.setPriority(Thread.MAX_PRIORITY);
        }
    }
}

public class PriorityThreadTest extends Thread{
    // 定义一个有参数的构造器，用于创建线程时指定name
    public PriorityThreadTest(String name){
        super(name);
    }
    public void run(){
        for (int i = 0 ; i < 50 ; i++ ){
            System.out.println(getName() +  ",其优先级是：" + getPriority() + ",循环变量的值为:" + i);
        }
    }
}
```

### 线程让步

- 让步方法yield()能让当前线程由“运行状态”进入到“就绪状态”，从而让其它具有相同优先级的等待线程获取执行权
- 但是，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权，也有可能是当前线程又进入到“运行状态”继续运行

```java
class YieldThreadTest extends Thread{
    public YieldThreadTest(String name){
        super(name);
    }
    public synchronized void run(){
        for(int i=0; i <100; i++){
            System.out.printf("%s [%d]:%d\n", this.getName(), this.getPriority(), i);
            // i整除10时，调用yield
            if (i%10 == 0)
                Thread.yield();
        }
    }
}

public class YieldTest{
    public static void main(String[] args){
        YieldThreadTest t1 = new YieldThreadTest("t1");
        YieldThreadTest t2 = new YieldThreadTest("t2");
        t1.start();
        t2.start();
    }
}

输出：可以看到t1和t2都是在被10整除的整数时切换
...    
t2 [5]:8
t2 [5]:9
t2 [5]:10
t1 [5]:51
t1 [5]:52
t1 [5]:53    
...    
t1 [5]:78
t1 [5]:79
t1 [5]:80
t2 [5]:41
t2 [5]:42  
...    
```

### 线程中断标志

通过Thread类中`interrupt()、interrupted()和isInterrupted()`方法来设置和取消线程中断标志

**interrupt()方法：设置中断标志，作用于调用者线程**

其作用是中断调用该方法的Thread实例所代表的线程，但实际上只是给线程设置中断标志，线程仍会继续运行。

**isInterrupted()方法：只检测中断，作用于调用者线程**

作用是只检测调用者代表的线程是否被中断 ，不清除中断状态。

**interrupted()方法：检测中断并清除中断状态，作用于当前线程**

作用是测试当前线程是否被中断（检查中断标志），有标记的话，返回一个true清除中断状态，第二次再调用时中断状态已经被清除，将返回一个false。



**PS：**interrupt()只是打标记，若果想要是实现调用interrupt()方法真正的终止线程，则可以在线程的run方法中做处理即可，比如直接跳出run()方法使线程结束

```java
public class MyThread extends Thread {
    @Override
    public  void run() {
        for (int i = 0; i < 1000; i++) {
            System.out.println("i="+(i+1));
            if(this.isInterrupted()){
                System.out.println("通过this.isInterrupted()检测到中断");
                System.out.println("第一个interrupted()"+this.interrupted());//true
                System.out.println("第二个interrupted()"+this.interrupted());//false
                break;
            }
        }
        System.out.println("因为检测到中断，所以跳出循环，线程到这里结束，因为后面没有内容了");
    }
}

public class Test {
    public static void main(String[] args ) throws InterruptedException {
        MyThread myThread=new MyThread();
        myThread.start();
        myThread.interrupt();
        //sleep等待一秒，等myThread运行完
        Thread.currentThread().sleep(1000);
        System.out.println("myThread线程是否存活："+myThread.isAlive());
    }
}
```



## 线程同步

### 概念

线程安全问题的产生

1，多个线程在操作共享的数据。

2，操作共享数据的线程代码不满足原子性

```java
//四个线程卖100张票,可能会有多个线程卖同一张票的情况发生
public class TicketRunnable implements Runnable {
    private int tickets = 100;
    public void run() {
        while (true) {
            if (tickets > 0) {
                try {
                    Thread.sleep(10);
                } catch (InterruptedException e) {
                }
                System.out.println(Thread.currentThread().getName() + "....sale:...." + tickets);
    			tickets--；
             }else {
                break;
             }
        }
    }
    public static void main(String[] args) {
        TicketRunnable ticketRunnable = new TicketRunnable();
        Thread t1 = new Thread(ticketRunnable);
        Thread t2 = new Thread(ticketRunnable);
        Thread t3 = new Thread(ticketRunnable);
        Thread t4 = new Thread(ticketRunnable);
        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}
```

解决这样的问题就是线程同步的方式来实现，**线程同步**不是同时进行，而是协同步调，按预定的先后次序进行运行



### synchronized

#### 同步代码块

```java
//synchronized关键字修饰的语句块
synchronized(object){ 
    ...
}
```

括号里的这个对象可以是任意对象，这个对象一般称为**同步锁**。

被该关键字修饰的语句块会自动被加上内置锁，被保护的语句代码所在的线程要执行，需要获得内置锁，否则就处于阻塞状态。

#### 同步方法

```java
//synchronized关键字修饰的方法
public synchronized void save(){
    ...
}
```

由于java的每个对象都有一个内置锁，当用此关键字修饰方法时，在调用该方法前，需要获得内置锁，否则就处于阻塞状态。

#### 锁对象

- 对于普通同步方法，锁是当前实例对象。
- 对于静态同步方法，锁是当前类的Class对象。
- 对于同步方法块，锁是Synchonized括号里配置的对象。

其中被synchronized和static修饰的方法，锁的对象是类的Class对象。仅仅被synchronized修饰的方法，锁的对象是方法的调用者。因为两个方法锁的对象不是同一个，所以两个方法用的不是同一个锁，所以两者间并非同步。



**锁是对象，锁住的是该对象里面的所有同步方法/方法块**



问题：当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?

前提条件：多个线程所持有的对象锁共享且唯一，如果每个线程所持有的对象锁不一样，那么该对象是锁不住的！

- 一个线程在访问一个对象的同步方法时，另一个线程不能同时访问这个对象的这个同步方法。
- 一个线程在访问一个对象的同步方法时，另一个线程不能同时访问这个对象的其他同步方法。
- 一个线程在访问一个对象的同步方法时，另一个线程可以同时访问这个对象的非同步方法。



#### 同步锁的释放

在Java中，程序无法显式的释放对同步监测器的锁定，释放权在底层的JVM上，JVM会从释放机制中自动的释放，

同步监测器锁定的释放，如下所示：

1. 当前线程的同步方法、同步代码块执行结束，当前线程即释放随同步监测器的锁定；

2. 当前线程的同步方法、同步代码块中遇到break、return终止了该代码块、方法的继续执行，当前线程会释放同步监测器的锁定；

3. 当前线程在同步方法、同步代码块中出现了未处理的error或者exception，导致了该代码块、该方法异常结束时，当前线程会释放同步监测器的锁定；

4. 当前线程执行同步代码块或同步方法时，程序调用了同步监测器的wait()方法，当前线程暂停，则当前线程会释放同步监测器的锁定。

但是在如下情况下，当前线程不会释放对同步监测器的锁定：

1. 线程执行同步代码块或者同步方法时，程序调用了Thread.sleep()、Thread.yield()方法来暂停当前线程执行，当前线程不会释放对同步监测器的锁定；

2. 线程执行同步代码块时，其他线程调用了该线程的suspend()方法*（suspend会阻塞线程直到另一个线程调用resume，这个方法容易死锁，已经不推荐使用了，了解一下就ok）*将该线程挂起，也不会释放同步监测器的锁定。





### 重入锁Lock

在JDK1.5中新增了一个java.util.concurrent包，可以使用JUC里的Lock来实现同步。 

Lock是一个接口，我们真正用的是它的实现类ReentrantLock，`ReenreantLock`类的常用方法有：

- ReentrantLock() : 创建一个ReentrantLock实例 
- lock() : 获得锁 
- unlock() : 释放锁 

ReentrantLock()还有一个可以创建公平锁的构造方法，但由于能大幅度降低程序运行效率，不推荐使用 

```java
public class SellTicket implements Runnable {
    private int tickets = 100;
    private  Lock lock = new ReentrantLock();
    @Override
    public void run() {
        while(true) {
            // 在对共享数据tickets操作之前加锁
            lock.lock();
            try {
                if(tickets > 0) {
                    System.out.println(Thread.currentThread().getName() + "正在出票...   " + tickets--);
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }else {
                    break;
                }
            }finally {
                // 在finally确保锁得到了释放。
                lock.unlock();
            }
        }
    }
}
```

当存在大量线程时，Lock的性能要远远优于synchronized



## ThreadLocal

ThreadLocal会让每一个使用该变量的线程从主存中拿到该变量的副本，保存在工作内存中，对副本的修改不会刷新到主存。每一个线程都可以随意修改自己的变量副本，而不会对其他线程产生影响，从而隔离了多个线程的数据共享。

`ThreadLocal` 类的常用方法:

-   ThreadLocal() : 创建一个线程本地变量 
-   get() : 返回此线程局部变量的当前线程副本中的值 
-   initialValue() : 返回此线程局部变量的当前线程的"初始值" 
-   set(T value) : 将此线程局部变量的当前线程副本中的值设置为value

```java
class TicketRunnable implements Runnable {
    //定义在这里的属性是所有线程共享的变量数据
    private static ThreadLocal<Integer>  ticketNumber = new ThreadLocal<Integer>(){
        @Override
        protected Integer initialValue() {
            return 10;
        }
    };

    @Override
    public void run() {
        //子线程做的任务的卖票
        while (true) {
            if (ticketNumber.get() > 0) {
                try {
                    Thread.sleep(100); //起到放大线程安全问题的作用
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("线程" + Thread.currentThread().getName() + "卖掉第" + ticketNumber.get() + "号票");
                ticketNumber.set(ticketNumber.get()-1);
            } else {
                break;
            }
        }
    }
}
```

ThreadLocal适用的场景是，多个线程都需要使用一个变量，但这个变量的值不需要在各个线程间共享，各个线程都只使用自己的这个变量的值。



## 死锁

造成死锁的原因可概括成三句话：

- 当前线程拥有其他线程需要的资源
- 当前线程等待其他线程已拥有的资源
- 都不放弃自己拥有的资源

### 锁顺序死锁

```java
//多个线程分别获得left锁和right锁，线程继续执行却都没释放锁，会导致永久等待
class Demo implements Runnable{
    private final Object left = new Object();
    private final Object right = new Object();

    @Override
    public void run() {
        leftRight();
        rightLeft();
    }

    public void leftRight() {
        // 得到left锁
        synchronized (left) {
            System.out.println("线程" + Thread.currentThread().getName() + "拿到left锁要right锁");
            // 得到right锁
            synchronized (right) {
                System.out.println("线程" + Thread.currentThread().getName() + "拿到left和right锁");
            }
        }
    }

    public void rightLeft() {
        // 得到right锁
        synchronized (right) {
            System.out.println("线程" + Thread.currentThread().getName() + "拿到right锁要left锁");
            // 得到left锁
            synchronized (left) {
                System.out.println("线程" + Thread.currentThread().getName() + "拿到left和right锁");
            }
        }
    }
}
```

### 动态锁顺序死锁

```java
//多个线程可能出现a账户向b账户转账的同时b账户向a账户转账
public class ThreadTest6 {
    public static void main(String[] args) {
        Demo demo = new Demo();
        new Thread(demo,"1").start();
        new Thread(demo,"2").start();
        new Thread(demo,"3").start();
        new Thread(demo,"4").start();
    }

}

class Demo implements Runnable{
    Account a = new Account("A",1000);
    Account b = new Account("B",1000);

    @Override
    public void run() {
        transferMoney(a,b,100);
        transferMoney(b,a,100);
    }

     //有两个账户，所以需要两把锁
    public void  transferMoney(Account fromAccount, Account toAccount,double money) {
        synchronized (fromAccount) {
            System.out.println("线程" + Thread.currentThread().getName() + "得到锁" + fromAccount.getName());  
            synchronized (toAccount) {
                System.out.println("线程" + Thread.currentThread().getName() + "得到锁" + toAccount.getName());
                if(fromAccount.getMoney() < money) {
                    System.out.println("余额不足");
                } else {
                    fromAccount.setMoney(fromAccount.getMoney()-money);
                    toAccount.setMoney(toAccount.getMoney() + money);
                    System.out.println("转账后：" + fromAccount.getName() + "有：" + fromAccount.getMoney());
                    System.out.println("转账后：" + toAccount.getName() + "有：" + toAccount.getMoney());
                }
            }
        }
    }
}

@Data
class Account{
    private String name;
    private double money;
}
```

### 协作对象之间发生死锁

```java
public class CooperatingDeadlock {
    class Taxi {
        public synchronized Point getLocation() {
            return location;
        }

        // setLocation 需要Taxi内置锁
        public synchronized void setLocation(Point location) {
            // 调用notifyAvailable()需要Dispatcher内置锁
            dispatcher.notifyAvailable(this);
            ...
        }
        ...
    }

    class Dispatcher {
        public synchronized void notifyAvailable(Taxi taxi) {
            availableTaxis.add(taxi);
        }

        // 调用getImage()需要Dispatcher内置锁
        public synchronized Image getImage() {
            // 调用getLocation()需要Taxi内置锁
            image.drawMarker(t.getLocation());
            ...
        }
    }
    ...
}
```



### 避免死锁的方法

避免死锁可以概括成三种方法：

- **固定加锁的顺序**(针对锁顺序死锁)
- **开放调用**(针对对象之间协作造成的死锁)
- **使用定时锁**-->tryLock()

  如果等待获取锁时间超时，则**抛出异常而不是一直等待**


### 固定锁顺序避免死锁

```java
public class InduceLockOrder {

    // 额外的锁、避免两个对象hash值相等的情况(即使很少)
    private static final Object tieLock = new Object();

    public void transferMoney(final Account fromAcct,  final Account toAcct, final DollarAmount amount)  throws InsufficientFundsException {
        class Helper {
            public void transfer() {
                if (fromAcct.getManey() < amount)
                    System.out.println("输出账号的余额不足");
                else {
                    fromAcct.setMoney(fromAcct.getMoney()-amount)
                    toAcct.setMoney(toAcct.getMoney()+amount);
                }
            }
        }
        // 得到锁的hash值，每个对象都有对应的hash值，哪个hash值更大/更小就会先加那把锁，从而保证锁对象的顺序 
        int fromHash = System.identityHashCode(fromAcct);
        int toHash = System.identityHashCode(toAcct);

        // 根据hash值来上锁
        if (fromHash < toHash) {
            synchronized (fromAcct) {
                synchronized (toAcct) {
                    new Helper().transfer();
                }
            }

        } else if (fromHash > toHash) {// 根据hash值来上锁
            synchronized (toAcct) {
                synchronized (fromAcct) {
                    new Helper().transfer();
                }
            }
        } else {// 额外的锁、避免两个对象hash值相等的情况(即使很少)
            synchronized (tieLock) {
                synchronized (fromAcct) {
                    synchronized (toAcct) {
                        new Helper().transfer();
                    }
                }
            }
        }
    }
}
```



### 开放调用避免死锁

如果在调用某个方法时不需要持有锁，那么这种调用被称为开放调用

```java
class CooperatingNoDeadlock {
    class Taxi {
        public synchronized Point getLocation() {
            return location;
        }

        public void setLocation(Point location) {
            // 加Taxi内置锁
            synchronized (this) {
                this.location = location;
                reachedDestination = location.equals(destination);
            }
            // 执行同步代码块后完毕，释放锁
            
			// 加Dispatcher内置锁
            dispatcher.notifyAvailable(this);
            ...
        }
        ...
    }

    class Dispatcher {
        public synchronized void notifyAvailable(Taxi taxi) {
            availableTaxis.add(taxi);
        }

        public Image getImage() {
            // Dispatcher内置锁
            synchronized (this) {
                copy = new HashSet<Taxi>(availableTaxis );
            }
            // 执行同步代码块后完毕，释放锁

            // 加Taix内置锁
            image.drawMarker(t.getLocation());
        }
    }

    class Image {
        public void drawMarker(Point p) {
        }
    }

}
```

### 使用定时锁

通过`tryLock()`方法尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。

```java
public class tryLock {
    public static void main(String[] args) {

        System.out.println("开始");
        final Lock lock = new ReentrantLock();
        new Thread() {
            @Override
            public void run() {
                String tName = Thread.currentThread().getName();
                if (lock.tryLock()) {
                    System.out.println(tName + "获取到锁！");
                } else {
                    System.out.println(tName + "获取不到锁！");
                    return;
                }
                try {
                    System.out.println(tName);
                    Thread.sleep(5000);
                } catch (Exception e) {
                    System.out.println(tName + "出错了！！！");
                } finally {
                    System.out.println(tName + "释放锁！！");
                    lock.unlock();
                }

            }
        }.start();

        new Thread() {
            @Override
            public void run() {
                String tName = Thread.currentThread().getName();

                if (lock.tryLock()) {
                    System.out.println(tName + "获取到锁！");
                } else {
                    System.out.println(tName + "获取不到锁！");
                    return;
                }

                try {
                    System.out.println(tName);
                } catch (Exception e) {
                    System.out.println(tName + "出错了！！！");
                } finally {
                    System.out.println(tName + "释放锁！！");
                    lock.unlock();
                }
            }
        }.start();
        System.out.println("结束");
    }
}
```



### 总结

发生死锁的原因主要由于：

- 线程之间交错执行

  解决：**以固定的顺序加锁**

- 执行某方法时就需要持有锁，且不释放

  解决：**缩减同步代码块范围，最好仅操作共享变量时才加锁**

- 永久等待

  解决：使用tryLock()定时锁，超过时限则返回错误信息

## 多线程性质

实现线程同步需要实现内存可见性、操作原子性和程序有序性。

### Java内存模型

 JMM 即为 JAVA 内存模型（Java Memory Model），是在 JVM 中定义的一个抽象内存模型。

- 所有的变量都存储在主内存中（操作系统给进程分配的内存空间）
- 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本
- 每个线程的工作副本之间不可见，线程对共享变量的所有操作都必须在自己的工作内存当中，当前线程无法直接访问其他线程的工作内存中的变量，线程间变量值得传递需要通过主内存来完成。

![img](img_%E5%A4%9A%E7%BA%BF%E7%A8%8B/clipboard-1629241413361.png)

### 内存可见性

**内存可见性其实就是共享变量在线程间的可见性**

- 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量
- 可见性：一个线程对共享变量值的修改，能够及时的被其他线程看到，也就是说把工作内存1中更新过的共享变量刷新到主内存中，将主内存中最新的共享变量的值更新到工作内存2中

```java
//运行发现程序不会停止,即使我们在子线程中将线程的共享变量flag的值修改成了true，但是主线程在while条件判断的时候读到的flag一直是false
public class TestVolatile {
    public static void main(String[] args) {
        ThreadDemo td = new ThreadDemo();
        new Thread(td).start();
        while(true){
            if(td.isFlag()){
                System.out.println("--------主线中的程序读到flag为true了----------");
                break;
            }
//这里不能有语句，有语句循环之间就有间隙
        }
    }
}

class ThreadDemo implements Runnable {
    private boolean flag = false;
    @Override
    public void run() {
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
        }
        flag = true;
        System.out.println("flag=" + isFlag());
    }
    public boolean isFlag() {
        return flag;
    }
    public void setFlag(boolean flag) {
        this.flag = flag;
    }
}
```

#### synchronized实现可见性

```java
//线程解锁前，自动把线程中工作内存共享变量的最新值刷新到主内存中
//线程加锁时，自动把线程中工作内存共享变量的值清空，从而使用共享变量时需要从主内存中重新读取最新的值
synchronized (td){
    if(td.isFlag()){
        System.out.println("------------------");
        break;
    }
}
```

缺点：程序效率低，对计算机硬件资源是高开销动作。

#### volatile实现可见性

```java
class ThreadDemo implements Runnable {
    private volatile boolean flag = false;
    ...
}
```

### 操作原子性

要么一起成功，要么一起失败的操作叫原子性操作。比如(A账户向B账户转账1000，要么A帐户成功减少1000，同时B帐户成功增加1000，要么A帐户回到原来状态，B帐户也回到原来状态)

```java
/*
运行结果会发现可能会在不同的线程中，看到相同的数值。原因在于volatile保证了serialNumber变量内存可见，但是volatile没办法保证对变量操作的原子性。serialNumber自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。

假如某个时刻变量serialNumber的值为10，线程1对变量进行自增操作，线程1先读取了变量serialNumber的原始值，然后线程1被阻塞了；然后线程2对变量进行自增操作，线程2也去读取变量serialNumber的原始值，线程2会直接去主存读取serialNumber的值(volatile就是要直接从内存读取)，发现serialNumber的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。回到线程1接着进行加1操作，由于已经读取了serialNumber的值，注意此时在线程1的工作内存中serialNumber的值仍然为10，所以线程1对serialNumber进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。那么两个线程分别进行了一次自增操作后，serialNumber只增加了1。
*/


public class TestAtomicDemo {
    public static void main(String[] args) {
        AtomicDemo ad = new AtomicDemo();
        for (int i = 0; i < 10; i++) {
            new Thread(ad).start();
        }
    }
}

class AtomicDemo implements Runnable{
   private volatile int serialNumber = 0; //线程共享变量
    @Override
    public void run() {
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
        }
        System.out.println(getSerialNumber());
    }
    public int getSerialNumber(){
        return serialNumber++;
    }
}
```

- **自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的**
- **内存可见可以保证更新数据之后其他线程立即可见，操作原子可以防止读取数据和更新数据之间有其他线程过来更新同一条数据，造成的数据冲突和信息遗失。**

#### 乐观锁和悲观锁

- **乐观锁**：总是假设最好的情况，每次操作数据时认为不会有多线程冲突（所以不加锁），但是当进行更新操作时，会进行 “冲突检测” 来判断是否有其他的线程干扰，若是有其他线程干扰则视本次更新操作失败，一般会进行重试。Compare and Swap 就是典型的乐观锁技术，乐观锁性能更好。
- **悲观锁**：总是假设最坏的情况，每次操作数据时认为会有多线程冲突（所以必须加锁），比如使用synchronized保证了某一时刻仅有一个线程能访问同步代码/方法。

##### 使用场景

　　乐观锁一般用于读比较多的场合，尽量减少加锁的开销。
　　悲观锁一般用于写比较多的场合，尽量减少类似乐观锁重试更新引起的性能开销。

##### 乐观锁实现方式

方式一：通过版本号机制实现。
可参考笔记mybatis-plus 实现乐观锁

方式二：通过 CAS 算法实现，如JUC中的原子类。

##### CAS算法

- CAS 为 Compare And Swap 的缩写，即比较交换，是一种无锁算法（即在不加锁的情况实现多线程之间的变量同步）。CAS算法通过申明一个volatile类型的变量，再加上compareAndSwapInt的方法，来实现线程同步。
- CAS也包含了读取、比较和写入这三个操作，但CAS通过硬件命令**保证了原子性**。
- CAS 操作包含三个操作数 —— 内存值（V）、预期原值（A）和新值(B)。如果内存地址里面的值 V 和 A 的值是一样的，那么就将内存里面的值更新成B。若 V 与 A 不一致，则不执行任何操作，更新失败，并可以再次发起尝试（可以通过自旋操作，不断尝试修改数据直至成功修改）。即 V == A ？ V = B ： V = V。
- CAS 可能导致 ABA 问题（两次读取数据时值相同，但不确定值是否被修改过），比如两个线程操作同一个变量，线程 A、线程B 初始读取数据均为 A，后来 线程B 将数据修改为 B，然后又修改为 A，此时线程 A 再次读取到的数据依旧是 A，虽然值相同但是中间被修改过，这就是 ABA 问题。可以加一个额外的标志位 C，用于表示数据是否被修改。当标志位 C 与预期标志位相同、且 V == A 时，则更新值 B。

### 程序有序性

**有序性**：是指程序在执行过程中的先后顺序。由于Java在编译器以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码时的顺序。

**指令重排序**：处理器为了提高程序的运行效率，可能会对输入的代码指令做一定的优化，它不会百分之百的保证代码的执行顺序严格按照编写代码中的顺序来进行，但是它会保证程序的最终运算结果是编码时所期望的那样。指令重排序是机器级的优化操作，不是是Java源代码层面进行的。

 **指令重排序原则**：保证不影响代码执行语义的前提下，实现重排序，从而提升运行效率。当然对指令的重排序要严格遵守指令之间的数据依赖关系，并不是可以任意进行重排序的。

```java
//在JVM真正运行时,y=20语句有可能会在x++语句的前面得到执行，但是执行完上面的四行代码之后得到的结果肯定都是x=11，y=20
int x = 10;
int y = 0;
x++;
y = 20;
```

#### 实现有序性

Java 提供了三种保证有序性的方式，具体如下：

- 使用 volatile 关键字保证有序性；

  使用volatile修饰变量，会在变量处添加一个内存屏障，重排序时不能将后面的指令排序到内存屏障之前，内存屏障其通过一系列的屏障策略来实现有序。

- 使用 synchronized 关键字来保证有序性；

  使用synchronized 锁住的代码是单线程执行，根据as-if-serial语义(as-if-serial语义：不管怎么重排序，单线程程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义)，所以synchronized无法禁止指令重排，却能保证有序性。

- 使用显示锁 Lock 来保证有序性。

可参考笔记设计模式，单例双重锁使用volatile实现有序性

### volatile和synchronized区别

- volatile不需要加锁，比synchronized更轻量级，不会阻塞线程，效率更高

- volatile不具备“互斥性”，synchronized就具备“互斥性”，何为互斥性？比方说当我们用synchronize修饰方法，当一个线程抢到锁执行该方法后另一个线程无法再抢到锁执行该方法
- synchronized既能保证可见性和有序性，又能保证原子性，而volatile只能保证可见性和有序性，不能保证原子性。

## 同步集合

### 线程安全(Thread-safe)的集合对象

- Vector
- HashTable
- StringBuffer 

### 非线程安全的集合对象

- ArrayList 
- LinkedList
- HashSet
- TreeSet
- HashMap
- TreeMap
- StringBulider

```java
//可以使用的Collections.synchronizedXXX()方法来转换成线程安全的集合
List<String> list = Collections.synchronizedList(new ArrayList<>());
Map<String,String> map = Collections.synchronizedMap(new HashMap<>());
//但是程序效率低，并且在复合操作(同时遍历添加删除)的时候会报并发修改异常ConcurrentModificationException(当方法检测到对象的并发修改，但不允许这种修改时，抛出此异常)
```

### JUC中的同步容器类

- ArrayList-->CopyOnWriteArrayList
- ArraySet-->CopyOnWriteArraySet
- HashMap-->ConcurrentHashMap
- TreeMap-->ConcurrentSkipListMap

```java
//使用CopyOnWriteArrayList的场景最好在使用Iterator，且写操作少的环境中，因为写的多了，会降低程序的效率，因为CopyOnWrite每次写的时候都会复制一个备份，增大开销。

public class TestCopyOnWriteArrayList {
    public static void main(String[] args) {
        MyThread th = new MyThread();
        for (int i=0;i<10;i++){
            new Thread(th).start(); //启动10个线程
        }
    }
}
class MyThread implements  Runnable{
    //考虑线程安全
    public static CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();

    static {
        list.add("aaa");
        list.add("bbb");
        list.add("ccc");
    }
    @Override
    public void run() {
        //使用迭代器获取list里的值
        Iterator<String> it = list.iterator();
        while (it.hasNext()){
            System.out.println(it.next());
            //使用CopyOnWriteArrayList可以实现边读边写或边读边删
            list.add("eee");
        }
    }
}
```

## JUC

- 重入锁`lock.lock()`

- 定时锁`lock.tryLock()`

- 原子类：`AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference`

- 同步容器类：`ConcurrentHashMap、ConcurrentSkipListMap、CopyOnWriteArrayList、CopyOnWriteArraySet`

- 同步工具类：`CountDownLatch、Semaphore和CyclicBarrier`

### 原子类

Java.util.concurrent.atomic里边封装了一系列常用的数据类型对应的封装类：

**AtomicBoolean、AtomicInteger、AtomicLong、AtomicReference**。

其中封装类里的变量都用了volatile，同时底层使用了CAS算法，代码效率比synchronized和Lock实现的线程同步都高，是一种无锁的**线程同步**。

```java
class AtomicDemo implements Runnable{
    //线程共享变量
    private AtomicInteger serialNumber  =  new AtomicInteger (0)；
    @Override
    public void run() {
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            
        }
    	System.out.println(SerialNumber.get());
    }
    public int getSerialNumber(){
    	return serialNumber .getAndIncrement();
    }
}
```

### 同步工具类

同步一批线程

#### CountDownLatch

- CountDownLatch可以完成类似于阻塞当前线程的功能，即一个线程或多个线程一直等待，直到其他线程执行的操作完成。
- CountDownLatch是一个计数器闭锁，用一个给定的计数器来初始化，该计数器的操作是原子操作，即同时只能有一个线程去操作该计数器。
- 调用该类await方法的线程会一直处于阻塞状态，直到其他线程调用countDown方法，每次调用countDown方法，计数器的值减1。当计数器值减至零时，所有因调用await()方法而处于等待状态的线程就会继续往下执行。

```java
public class TestCountDownLatch {
    public static void main(String[] args) {
        final CountDownLatch latch = new CountDownLatch(50);
        LatchDemo ld = new LatchDemo(latch);

        long start = System.currentTimeMillis();
        for (int i = 0; i < 50; i++) {
            new Thread(ld).start();
        }

        try {
            latch.await();
        } catch (InterruptedException e) {
        }

        long end = System.currentTimeMillis();
        System.out.println("耗费时间为：" + (end - start));
    }

}

class LatchDemo implements Runnable {
    private CountDownLatch latch;
    public LatchDemo(CountDownLatch latch) {
        this.latch = latch;
    }
    @Override
    public void run() {
        try {
            for (int i = 0; i < 50000; i++) {
                if (i % 2 == 0) {
                    System.out.println(i);
                }
            }
        } finally {
            latch.countDown();
        }
    }
}
```

#### Semaphore

信号量，可以控制同时访问的线程个数。通过acquire()获取一个许可，如果没有就等待，而release()释放一个许可。

```java
//假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现：
public class Test {
    public static void main(String[] args) {
        int N = 8;            //工人数
        Semaphore semaphore = new Semaphore(5); //机器数目
        for(int i=0;i<N;i++) new Worker(i,semaphore).start();
    }

    static class Worker extends Thread{
        private int num;
        private Semaphore semaphore;
        public Worker(int num,Semaphore semaphore){
            this.num = num;
            this.semaphore = semaphore;
        }

        @Override
        public void run() {
            try {
                semaphore.acquire();
                System.out.println("工人"+this.num+"占用一个机器在生产...");
                Thread.sleep(2000);
                System.out.println("工人"+this.num+"释放出机器");
                semaphore.release();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

#### CyclicBarrier

- "循环栅栏"，可循环使用的屏障，通过它可以实现让一组线程等待都至某个状态之后再全部同时执行。
- 它让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程都到齐了才会继续干活。即一组线程都调用await()方法之后再继续执行下面的代码。

比如周末公司组织大巴去旅游，总共有三个景点，每个景点约定好游玩时间，一个景点结束后需要集中一起出发到下一个景点。

##### 方法

```java
//parties 是参与线程的个数，barrierAction是最后一个到达线程要做的任务
public CyclicBarrier(int parties)
public CyclicBarrier(int parties, Runnable barrierAction)
```

```java
//线程调用 await() 表示自己已经到达栅栏，BrokenBarrierException 表示栅栏已经被破坏，破坏的原因可能是其中一个线程 await() 时被中断或者超时
public int await() throws InterruptedException, BrokenBarrierException
public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException
//获得CyclicBarrier阻塞的线程数量
getNumberWaiting
```

##### 实例

```java
//所有线程会等待全部线程到达栅栏之后才会继续执行，并且最后到达的线程会完成 Runnable 的任务。
public class CyclicBarrierDemo {
    static class TaskThread extends Thread {
        CyclicBarrier barrier;
        public TaskThread(CyclicBarrier barrier) {
            this.barrier = barrier;
        }
        @Override
        public void run() {
            try {
                Thread.sleep(1000);
                System.out.println(getName() + " 到达栅栏 A");
                barrier.await();
                System.out.println(getName() + " 冲破栅栏 A");
                
                Thread.sleep(2000);
                System.out.println(getName() + " 到达栅栏 B");
                barrier.await();
                System.out.println(getName() + " 冲破栅栏 B");
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    
    public static void main(String[] args) {
        int threadNum = 5;
        CyclicBarrier barrier = new CyclicBarrier(threadNum, new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName() + " 完成最后任务");
            }
        });
        for(int i = 0; i < threadNum; i++) {
            new TaskThread(barrier).start();
        }
    }
    
}

输出：
Thread-1 到达栅栏 A
Thread-3 到达栅栏 A
Thread-0 到达栅栏 A
Thread-4 到达栅栏 A
Thread-2 到达栅栏 A
Thread-2 完成最后任务
Thread-2 冲破栅栏 A
Thread-1 冲破栅栏 A
Thread-3 冲破栅栏 A
Thread-4 冲破栅栏 A
Thread-0 冲破栅栏 A
Thread-4 到达栅栏 B
Thread-0 到达栅栏 B
Thread-3 到达栅栏 B
Thread-2 到达栅栏 B
Thread-1 到达栅栏 B
Thread-1 完成最后任务
Thread-1 冲破栅栏 B
Thread-0 冲破栅栏 B
Thread-4 冲破栅栏 B
Thread-2 冲破栅栏 B
Thread-3 冲破栅栏 B    
```

其中CountDownLatch指的是一个或多个线程等待其他线程完成，CyclicBarrier指的是的等待一组线程全部完成。

### 线程交换器Exchanger

```java
//Exchanger 用于线程之间数据交换，通过Exchanger.exchange(obj) 这个方法交换 
//如果第一个线程执行到exchange方法，它会等待第二个线程也执行到exchange，当两个线程都执行到同步点时，这两个线程就可以交换数据。 

public class ExchangerTest {
    private static String steve=null;
    private static String tao=null;

    public static void main(String[] args) {
        final Exchanger<String> exchanger=new Exchanger<>();
        final ExchangerTest test=new ExchangerTest();
        Thread t1= new Thread(new Runnable() {
            @Override
            public void run() {
                test.a(exchanger);
            }
        });
        Thread t2= new Thread(new Runnable() {
            @Override
            public void run() {
                test.b(exchanger);
            }
        });
        t1.start();
        t2.start();
        //等t1 t2线程执行结束，不然数据没有交换完毕
        while (t1.isAlive() || t2.isAlive() ){}

        System.out.println("steve :"+steve);
        System.out.println("tao :"+tao);
    }
    
    public void  a(Exchanger<String> exchanger){
        steve="steve";
        try {
            //把交换来的数据替换本身的数据
            System.out.println("steve ="+steve);
            steve= exchanger.exchange(steve);
            System.out.println("a 交换数据完成！时间："+System.currentTimeMillis());
            //等待模拟延迟和处理耗费的时间
            TimeUnit.SECONDS.sleep(1);
        } catch ( Exception e) {
            e.printStackTrace();
        }
    }
    public void  b(Exchanger<String> exchanger){
        tao="tao";
        try {
            //把交换来的数据替换本身的数据
            System.out.println("tao ="+tao);
            tao=exchanger.exchange(tao);
            System.out.println("b 交换数据完成！时间："+System.currentTimeMillis());
            TimeUnit.SECONDS.sleep(4);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## 线程之间的通信

### 生产者/消费者模型

- 产生数据的模块，就形象地称为**生产者**；
- 而处理数据的模块，就称为**消费者**；
- 生产者和消费者之间的中介就叫做**缓冲区，一般就是一个队列**。

在生产者-消费者模型中，当队列满时，生产者需要交出对队列的占用权，并进入挂起状态，等待消费者消费了数据，然后消费者通知生产者队列有空间。同样地，当队列空时，消费者也必须等待，等待生产者通知它队列中有数据。这种互相通信的过程就需要线程间的协作。

Java中线程通信协作方式：

1. 配合synchronized加锁实现的线程通信。

2. 配合ReentrantLock加锁实现的线程通信。

3. 利用管道流实现通信。

4. JUC里的线程交换器。

### 配合synchronized加锁的线程实现通信

借助Object类的三个方法`wait()/notify()/notifyAll()`实现，`wait()、notify()、notifyAll()`方法是本地方法，并且为final方法，无法被重写。

- 调用某个对象的wait()方法能让当前线程阻塞，相当于让当前线程交出（释放）此同步锁，然后进入等待状态，等待后续再次获得此同步锁。
- 调用某个对象的notify()方法能够唤醒一个正在等待这个同步锁对象的线程，如果有多个线程都在等待这个同步锁对象，则只能唤醒其中一个线程；
- 调用notifyAll()方法能够唤醒所有正在等待这个同步锁对象的线程；

**PS：**`notify()、notifyAll()`方法只是唤醒等待该同步锁的线程，并不决定哪个线程能够获取到锁。

```java

//测试
public class Run {
    public static void main(String[] args) {
        //创建锁对象
        Object obj = new Object();
        //这里是1个生产者1个消费者进行数据的交互。
        //如果多创建了几个生产者消费者线程，要防止假死，即防止一直唤醒同类线程(生产者唤醒生产者，消费者唤醒消费者)，这时需要将notify()改为notifyAll()增加唤醒异类线程的权重
        P p = new P(obj);
        C r = new C(obj);
        p.start();
        r.start();
    }
}
    
//定义一个类，模拟队列
public class ValueObject {
    public static String value = "";
}

//生产者线程
public class P extends Thread{
    private Object obj;
    public P(Object obj) {
        super();
        this.obj = obj;
    }

    @Override
    public void run() {
        while (true) {
            try {
                synchronized (obj) { //当前线程必须获得锁才可以进行下面的操作
                    if (!ValueObject.value.equals("")) {//如果Value不为空，说明字符串还没被消费，所以调用wait方法，把当前线程（生成线程）阻塞
                        obj.wait();
                    }
                    String value = System.currentTimeMillis() + "_" + System.nanoTime();
                    System.out.println("set的值是" + value);
                    ValueObject.value = value;//为空的话，将生产数据放到队列
                    obj.notify();//生产完就唤醒等待该对象锁的线程，（这里只有一个消费者等这个锁，所以就是唤醒的它）
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

//消费者线程
public class C extends Thread {
    private Object obj;
    public C(Object obj) {
        super();
        this.obj = obj;
    }
    @Override
    public void run() {
        while (true) {
            try {
                synchronized (obj) {
                    if (ValueObject.value.equals("")) {//如果字符串为空，即被消费完了，所以wait等待。
                        obj.wait();
                    }
                    System.out.println("get的值是" + ValueObject.value);
                    ValueObject.value = "";  //把队列里的数据消费掉了
                    obj.notify();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}
```

### 配合ReentrantLock加锁实现的线程通信

借助Condition类的`await()/signal()/signalAll()`来实现线程通信，线程通信的实现比较推荐使用Condition

- Condition是个接口，基本的方法就是await()和signal()方法；
- Condition依赖于Lock接口，生成一个Condition的基本代码是`lock.newCondition()`
- 调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用

**Conditon中的await()对应Object的wait()；**

**Condition中的signal()对应Object的notify()；**

**Condition中的signalAll()对应Object的notifyAll()。**

```java
//测试
public class Run {
    public static void main(String[] args) {
        Lock lock = new ReentrantLock();
        Condition condition = lock.newCondition();
        P p = new P(lock,condition);
        C r = new C(lock,condition);
        p.start();
        r.start();
    }
}

//定义一个类，模拟队列
public class ValueObject {
    public static String value = "";
}

//生产者线程
public class P extends Thread{
    private ReentrantLock lock;
    private Condition condition;
    public P(ReentrantLock lock, Condition condition) {
        this.lock = lock;
        this.condition = condition;
    }

    @Override
    public void run() {
        while (true) {
            try {
                lock.lock();//获得锁
                if (!ValueObject.value.equals("")) {//如果Value不为空，说明字符串还没被消费，所以调用wait方法，把当前线程（生成线程）阻塞
                    condition.await(); //没被消费则阻塞该生产线程，当然也释放了锁，进入等锁的队列
                }
                String value = System.currentTimeMillis() + "_" + System.nanoTime();
                System.out.println("set的值是" + value);
                ValueObject.value = value;//为空的话，生产数据放到队列
                co1);//生产完就唤醒等待该对象锁的线程，（这里只有一个消费者等这个锁，所以就是唤醒的它）

            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                lock.unlock();
            }
        }
    }
    
 //消费者线程
public class C extends Thread {
    private ReentrantLock lock;
    private Condition condition;
    public C(ReentrantLock lock, Condition condition) {
        this.lock = lock;
        this.condition = condition;
    }

    @Override
    public void run() {
        while (true) {
            try {
                lock.lock();//获得锁
                if (ValueObject.value.equals("")) {//如果字符串为空，即被消费完了，所以wait等待。
                    condition.await();
                }
                System.out.println("get的值是" + ValueObject.value);
                ValueObject.value = "";  //把队列里的数据消费掉了
                condition.signal();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                lock.unlock();
            }
        }
    }
}
```

## 线程按序交替

编写一个程序，开启三个线程，这三个线程的ID分别为A、B、C，每个线程将自己的ID在屏幕上打印10遍，要求输出的结果必须按顺序显示，如:ABCABCABC……依次递归。

```java
//使用Condition进行线程间通信即可(也可以使用wait()和notify()):
package cn.ybzy.demo;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;
public class ABCABCThread {
    public static void main(String[] args) {
        ABCABCThread at = new ABCABCThread();
        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 1;i <= 10;i++){
                    at.loopA(i);
                }
            }
        },"A").start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 1;i <= 10;i++){
                    at.loopB(i);
                }
            }
        },"B").start();

        new Thread(new Runnable() {
            @Override
            public void run() {
                for (int i = 1;i <= 10;i++){
                    at.loopC(i);
                }
            }
        },"C").start();
    }
    
    private int number = 1;//程序启动起来默认执行的线程标记
    private Lock lock = new ReentrantLock();
    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private Condition condition3 = lock.newCondition();

    public void loopA(int totalLoop){
        lock.lock();
        try {
            //判断number
            if(number != 1){
                condition1.await();
            }
            System.out.println(Thread.currentThread().getName()  + "\t" + totalLoop);
            number = 2;
            condition2.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    public void loopB(int totalLoop){
        lock.lock();
        try {
            //判断number
            if(number != 2){
                condition2.await();
            }
            System.out.println(Thread.currentThread().getName()  + "\t" + totalLoop);
            number = 3;
            condition3.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    public void loopC(int totalLoop){
        lock.lock();
        try {
            //判断number
            if(number != 3){
                condition3.await();
            }
            System.out.println(Thread.currentThread().getName()  + "\t" + totalLoop);
            number = 1;
            condition1.signal();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}
```



## 线程池

![img](img_%E5%A4%9A%E7%BA%BF%E7%A8%8B/clipboard-1629594514263.png)

### Executor

负责线程的使用和调度的线程池根接口，里面有一个execute()方法，用来执行线程

```java
public interface Executor {
    void execute(Runnable command);
}
```

### ExecutorService

线程池接口，提供了线程池生命周期方法

#### 线程池生命周期

线程池有五种状态：**RUNNING、SHUTDOWN、STOP、TIDYING、TERMINATED**

![img](img_%E5%A4%9A%E7%BA%BF%E7%A8%8B/clipboard-1629594630521.png)

1. 线程池在构造前（new操作）是初始状态，一旦构造完成线程池就进入了执行状态RUNNING，随时准备接受任务来执行，构造完成后并没有线程被立即启动，默认情况下线程池中的线程初始时为 0， 当有新的任务到来时才会创建新线程。

2. 线程池运行中可以通过shutdown()和shutdownNow()来改变运行状态

   线程池Executor是异步的执行任务，因此任何时刻不能够直接获取提交的任务的状态。**这些任务有可能已经完成，也有可能正在执行或者还在排队等待执行**。

   `shutdown()`是一个平缓的关闭过程，线程池停止接受新的任务，同时等待已经提交的任务执行完毕，包括那些进入队列还没有开始的任务，这时候线程池处于SHUTDOWN状态；

   `shutdownNow()`是一个立即关闭过程，线程池停止接受新的任务，同时线程池取消所有正在执行的任务和已经进入队列但是还没有执行的任务，这时候线程池处于STOP状态。

3. 一般情况下我们认为shutdown()或者shutdownNow()执行完毕，线程池就进入TERMINATED状态，此时线程池就结束了。当然，在shutdown/stop到TERMINATED状态之间还存在一个TIDYING状态。

#### ExecutorService常用方法

![image-20210822092319003](img_%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210822092319003.png)

- isShutdown()描述的是非RUNNING状态，也就是SHUTDOWN/STOP/TERMINATED三种状态
- isTerminated()描述的是TERMINATED状态
- awaitTermination()描述的是等待线程池关闭的时间，如果等待时间线程池还没有关闭将会抛出一个超时异常

#### `Future<V>`接口

![image-20210822092906064](img_%E5%A4%9A%E7%BA%BF%E7%A8%8B/image-20210822092906064.png)

- cancel(boolean)会向任务发送一个中断信号。任务已完成、已被取消、不能取消都会返回false。任务在排队等待执行则会取消成功返回true，任务正在执行也会返回true，但是线程是否取消取决于传入参数，当传入参数为fasle时，允许执行完成，为true时，会发送中断信号尝试取消。
- isCancelled()和上述方法返回值保持一致。
- isDone()只要任务完成即返回true，不管有没有抛出异常。当调用cancel(boolean)方法返回后，不管有没有取消isDone()都会返回true。
- get()/get(long,TimeUnit)可以获取结果。其中get()将阻塞，直至结果准备就绪，会抛出InterruptedException, ExecutionException异常，get(long,TimeUnit)可以设置超时时间，会抛出InterruptedException, ExecutionException, TimeoutException异常。

```java
//例子：
ResultView view = new ResultView();
Future<ResultView> future = executor.submit(() -> {  
    ResultView result = new ResultView();
    .....................................
    return result;
});
try {    
    view = future.get(3000, TimeUnit.MILLISECONDS);
} catch (InterruptedException | ExecutionException e) {
    view.setMsg("中断异常");
} catch (TimeoutException e) {
    view.setMsg("超时异常");
    //尝试中断
    future.cancel(true);
}
```

Java1.8之前CompletionService能够实现按照任务完成的先后顺序获取任务的结果，Java1.8实现了CompletableFuture组合式、异步编程

参考：[Java8新特性整理之CompletableFuture：组合式、异步编程](https://blog.csdn.net/u011726984/article/details/79320004)



### ThreadPoolExecutor

线程池实现类，提供了线程池的维护操作等相关方法

```java
public class ThreadPoolExecutor extends AbstractExecutorService {
    //ThreadPoolExecutor中的构造方法
    public ThreadPoolExecutor(        
            int corePoolSize, // 1        
            int maximumPoolSize,  // 2
            long keepAliveTime,  // 3
            TimeUnit unit,  // 4
            BlockingQueue<Runnable> workQueue, // 5
            ThreadFactory threadFactory,  // 6
            RejectedExecutionHandler handler ) { //7
            
            if (corePoolSize < 0 || maximumPoolSize <= 0 || maximumPoolSize < corePoolSize || keepAliveTime < 0)
                throw new IllegalArgumentException();
                
            if (workQueue == null || threadFactory == null || handler == null)
                throw new NullPointerException();
                
            this.corePoolSize = corePoolSize;
            this.maximumPoolSize = maximumPoolSize;
            this.workQueue = workQueue;
            this.keepAliveTime = unit.toNanos(keepAliveTime);
            this.threadFactory = threadFactory;
            this.handler = handler;
    }		
}					
```

| 序号 | 名称            | 类型                     | 含义             |
| ---- | --------------- | ------------------------ | ---------------- |
| 1    | corePoolSize    | int                      | 核心线程池大小   |
| 2    | maximumPoolSize | int                      | 最大线程池大小   |
| 3    | keepAliveTime   | long                     | 线程最大空闲时间 |
| 4    | unit            | TimeUnit                 | 时间单位         |
| 5    | workQueue       | BlockingQueue<Runnable>  | 线程等待队列     |
| 6    | threadFactory   | ThreadFactory            | 线程创建工厂     |
| 7    | handler         | RejectedExecutionHandler | 拒绝策略         |

#### 参数详解

ThreadPoolExecutor类可设置的参数主要有：

- corePoolSize

   核心线程数，核心线程会一直存活，即使没有任务需要处理。当线程数小于核心线程数时，即使现有的线程空闲，线程池也会优先创建新线程来处理任务，而不是直接交给现有的线程处理。

   核心线程在allowCoreThreadTimeout被设置为true时会超时退出，默认情况下不会退出。

- maximumPoolSize

   当线程数大于或等于核心线程，且任务队列已满时，线程池会创建新的线程，直到线程数量达到maximumPoolSize。如果线程数已等于maximumPoolSize，且任务队列已满，则已超出线程池的处理能力，线程池会拒绝处理任务而抛出异常。

- keepAliveTime 

   当线程空闲时间达到keepAliveTime，该线程会退出，直到线程数量等于corePoolSize。如果allowCoreThreadTimeout设置为true，则所有线程均会退出直到线程数量为0。

- workQueue

   一个阻塞队列，用来存储等待执行的任务，常用的有如下几种：

   - ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。
   - LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO （先进先出） 排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。
   - SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。
   - PriorityBlockingQueue：一个具有优先级得无限阻塞队列。

   queueCapacity

   任务队列中的容量。从maximumPoolSize的描述上可以看出，任务队列的容量会影响到线程的变化，因此任务队列的长度也需要恰当的设置。

- rejectedExecutionHandler

   拒绝策略。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务rejectedExectutionHandler参数字段用于配置拒绝策略，常用拒绝策略如下

   - `AbortPolicy`：表示无法处理新任务时抛出异常RejectedExecutionException，默认策略。
   - `CallerRunsPolicy`：用调用者所在线程来运行任务。
   - `DiscardOldestPolicy`： 该策略将丢弃最老的一个请求，也就是丢弃即将被执行的任务，并尝试再次提交当前任务。
   - `DiscardPolicy`：不处理，丢弃掉 。

6. allowCoreThreadTimeout

   是否允许核心线程空闲退出，默认值为false。

#### 处理流程

线程池按以下行为执行任务

1. 当线程数小于核心线程数时，创建线程。

2. 当线程数大于等于核心线程数，且任务队列未满时，将任务放入任务队列。

3. 当线程数大于等于核心线程数，且任务队列已满

   若线程数小于最大线程数，创建线程

   若线程数等于最大线程数，抛出异常，拒绝任务

```java
public class ThreadTest {
    public static void main(String[] args) throws InterruptedException, IOException {
        int corePoolSize = 2;
        int maximumPoolSize = 4;
        long keepAliveTime = 10;
        TimeUnit unit = TimeUnit.SECONDS;
        BlockingQueue<Runnable> workQueue = new ArrayBlockingQueue<>(2);
        ThreadFactory threadFactory = new NameTreadFactory();
        /*
        ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。 默认策略
		ThreadPoolExecutor.DiscardPolicy：也是丢弃任务，但是不抛出异常。 
		ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程） 
		ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务
        */
        RejectedExecutionHandler handler = new MyIgnorePolicy();
        ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit,
                workQueue, threadFactory, handler);
        executor.prestartAllCoreThreads(); // 预启动所有核心线程
        
        for (int i = 1; i <= 10; i++) {
            MyTask task = new MyTask(String.valueOf(i));
            executor.execute(task);
        }

        System.in.read(); //阻塞主线程
    }

    
    static class NameTreadFactory implements ThreadFactory {
        private final AtomicInteger mThreadNum = new AtomicInteger(1);
        @Override
        public Thread newThread(Runnable r) {
            Thread t = new Thread(r, "my-thread-" + mThreadNum.getAndIncrement());
            System.out.println(t.getName() + " has been created");
            return t;
        }
    }

    public static class MyIgnorePolicy implements RejectedExecutionHandler {
        public void rejectedExecution(Runnable r, ThreadPoolExecutor e) {
            doLog(r, e);
        }
        private void doLog(Runnable r, ThreadPoolExecutor e) {
            // 可做日志记录等
            System.err.println( r.toString() + " rejected");
			// System.out.println("completedTaskCount: " + e.getCompletedTaskCount());
        }
    }

    static class MyTask implements Runnable {
        private String name;
        public MyTask(String name) {
            this.name = name;
        }
        @Override
        public void run() {
            try {
                System.out.println(this.toString() + " is running!");
                Thread.sleep(3000); //让任务执行慢点
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        public String getName() {
            return name;
        }

        @Override
        public String toString() {
            return "MyTask [name=" + name + "]";
        }
    }
}
/*
一共创建了4个线程
10个task任务，任务1、2、3、6先占满了核心线程和最大线程数量，然后4、5任务进入等待队列，7-10任务被直接忽略拒绝执行，等有线程执行完后通知4、5任务继续执行。
*/

输出：
my-thread-1 has been created
my-thread-2 has been created
my-thread-3 has been created
MyTask [name=2] is running!
MyTask [name=1] is running!
my-thread-4 has been created
MyTask [name=3] is running!
MyTask [name=7] rejected
MyTask [name=8] rejected
MyTask [name=9] rejected
MyTask [name=6] is running!
MyTask [name=10] rejected
MyTask [name=4] is running!
MyTask [name=5] is running!
```



参考：

[线程池之ThreadPoolExecutor概述](https://www.jianshu.com/p/f030aa5d7a28)

[ThreadPoolTaskExecutor和ThreadPoolExecutor区别](https://blog.csdn.net/weixin_43168010/article/details/97613895)



### ScheduledThreadPoolExecutor

ScheduledThreadPoolExecutor实现了ScheduledExecutorService接口，该接口定义了**可延时执行异步任务和可周期执行异步任务的特有功能**，相应的方法分别为：

```java
//delay或initialDelay：达到给定的延时时间后，执行任务

//这里传入的是实现Runnable接口的任务，因此通过ScheduledFuture.get()获取结果为null
public ScheduledFuture<?>  schedule(Runnable command,long delay, TimeUnit unit);

//这里传入的是实现Callable接口的任务，因此，返回的是任务的最终计算结果
public <V> ScheduledFuture<V> schedule(Callable<V> callable,long delay, TimeUnit unit);

//period：每次执行的开始的最小间隔时间，是以上一个任务开始的时间计时，period时间过去后，检测上一个任务是否执行完毕，如果上一个任务执行完毕，则当前任务立即执行，如果上一个任务没有执行完毕，则需要等上一个任务执行完毕后立即执行，周期性执行任务。
public ScheduledFuture<?> scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit);

//period：前一次执行结束到下一次执行开始的间隔时间，上一个任务执行结束后到下一次任务执行，中间延时时间间隔为delay。以这种方式，周期性执行任务。
public ScheduledFuture<?> scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit);
```

```java
public class TestScheduledTread {
    public static void main(String[] args) {
        ScheduledThreadPoolExecutor scheduled = new ScheduledThreadPoolExecutor(10);
        scheduled.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName());
            }
        }, 0, 40, TimeUnit.MILLISECONDS);

        //0表示首次执行任务的延迟时间，
        // 40表示每次执行任务的间隔时间，
        // TimeUnit.MILLISECONDS执行的时间间隔数值单位
    }
}
```



### Executors

线程池工具类，相当于一个工厂类，用来创建合适的线程池，返回ExecutorService类型的线程池，Executors工厂实际上就是调用的ThreadPoolExecutor的构造方法，传入默认参数。

```java
public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
}
```

- `ExecutorService newFixedThreadPool()` : 创建固定大小的线程池，超出的线程会在队列中等待，但是队列大小无限制，可能造成内存泄露
- `ExecutorService newCachedThreadPool()` : 缓存线程池，线程池的数量不固定，可以根据需求自动的更改数量，但是线程大小无限制，可能造成内存泄露
- `ExecutorService newSingleThreadExecutor() `: 创建单个线程池。 线程池中只有一个线程
- `ScheduledExecutorService newScheduledThreadPool()` : 创建固定大小的线程，可以延迟或定时的执行任务，但是任务是单线程方式执行，一旦一个任务失败其他任务也受影响

同时上述四种方法都不支持自定义拒绝策略，阿里Java规范中明确禁止使用Executors。

```java
public class demo1 {
    public static void main(String[] args) {
        //创建一个固定线程数的线程池
        ExecutorService service = Executors.newFixedThreadPool(10);
        //向线程池提交线程
        service.submit(new NumberThread());
        //使用完毕线程池后要关闭
        service.shutdown();
    }
}

class NumberThread implements  Runnable{
    @Override
    public void run() {
        for (int i=0;i<100;i++){
            System.out.println(Thread.currentThread().getName() + " i的值：" + i);
        }
    }
}
```



### SpringBoot中线程池

通常使用ThreadPoolTaskExecutor，这个类则是spring包下的，是spring为我们提供的线程池类

```java
//如果用线程池对多线程进行管理，需添加线程池配置类:
@Configuration
@EnableAsync
public class ExecturConfig {
    @Bean
    public Executor taskExector() {
        //ThreadPoolTaskExecutor这个类则是spring包下的，是spring为我们提供的线程池类
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        //通过Runtime方法来获取当前服务器cpu内核，根据cpu内核来创建核心线程数和最大线程数
        int threadCount = Runtime.getRuntime().availableProcessors();
        executor.setCorePoolSize(threadCount);//核心池大小
        executor.setMaxPoolSize(threadCount);//最大线程数
        executor.setQueueCapacity(200);//队列程度
        executor.setKeepAliveSeconds(60);//线程空闲时间
        executor.setThreadNamePrefix("taskExecutor-");//线程前缀名称
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());//配置拒绝策略
        executor.initialize();
        return executor;
}
```

```java
@Component
public class TestClass {
    @Async("taskExecutor")
    public void testFunction() throws Exception {
        //当在方法上标注了@Async注解之后，在被调用的时候主线程会主动使用多线程来调用此方法
    }
}

//或
@Component
public class TestClass {
    @AutoWired
    private ThreadPoolTaskExecutor taskExecutor;
    public void testFunction() throws Exception {
        taskExecutor.submit...
    }
}
```

#### 线程池配置日志

```java
@Component
@Aspect
public class ExecutorAspect {
    @Pointcut("execution(* org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor.submit(..))
    		||execution(* org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor.execute(..))")
    public void executorLog(){}
    
    @Before("executorLog()")
    public void before(JoinPoint joinPoint){
        String methodName=joinPoint.getSignature().getName();
        ThreadPoolTaskExecutor threadPoolTaskExecutor = (ThreadPoolTaskExecutor) joinPoint.getTarget();
        ThreadPoolExecutor threadPoolExecutor = threadPoolTaskExecutor.getThreadPoolExecutor();
        logger.info("{},taskCount [{}], completedTaskCount [{}], activeCount [{}], queueSize [{}]",
    	     //分别为方法名、任务总数、已完成数、活跃线程数，队列大小
                methodName,
                threadPoolExecutor.getTaskCount(),
                threadPoolExecutor.getCompletedTaskCount(),
                threadPoolExecutor.getActiveCount(),
                threadPoolExecutor.getQueue().size());
    }
}
```



## 读写锁ReadWriteLock

- ReadWriteLock同Lock一样也是一个接口，提供了readLock和writeLock两种锁的操作机制，一个是读锁，一个是写锁。
- 读锁是共享的，写锁是独占的，读锁可以在没有写锁的时候被多个线程同时持有，但是每次只能有一个写线程。也就是说在对共享资源加写锁之前需要释放读锁，同时，一个获得了读锁的线程必须能看到前一个释放的写锁所更新的内容。

- 读写锁比互斥锁允许对于共享数据更大程度的并发，与互斥锁相比，读写锁是否能够提高性能取决于读写数据的频率、读取和写入操作的持续时间、以及读线程和写线程之间的竞争。假设你的程序中涉及到对一些共享资源的读和写操作，且写操作没有读操作那么频繁时，可以使用读写锁。

**读写锁的互斥原则：**

- 读-读能共存，
- 读-写不能共存，
- 写-写不能共存。

```java
package cn.ybzy.demo;

import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class TestReadWriteLock {
    public static void main(String[] args) {
        ReadWriteLockDemo rwd = new ReadWriteLockDemo();
        //启动100个读线程
        for (int i = 0; i < 100; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    rwd.get();
                }
            },"Read").start();
        }
        //写线程
        new Thread(new Runnable() {
            @Override
            public void run() {
                rwd.set((int) (Math.random() * 101));
            }
        }, "Write").start();
    }
}

class ReadWriteLockDemo {
    //模拟共享资源--Number
    private int number = 0;
    // 实际实现类--ReentrantReadWriteLock，构造器里是可以传入一个布尔值做参数的，默认false表示非公平模式
    private ReadWriteLock readWriteLock = new ReentrantReadWriteLock();

    //读
    public void get() {
        //使用读锁
        readWriteLock.readLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + " : " + number);
        } finally {
            readWriteLock.readLock().unlock();
        }
    }

    //写
    public void set(int number) {
        readWriteLock.writeLock().lock();
        try {
            this.number = number;
            System.out.println(Thread.currentThread().getName() + " : " + number);
        } finally {
            readWriteLock.writeLock().unlock();
        }
    }
}
```

### ReentrantReadWriteLock

ReadWriteLock是接口，我们实现读写锁实质是用接口的实现类ReentrantReadWriteLock。

- 获取公平和非公平锁，默认为false，非公平锁。
  - 非公平模式(默认)：比公平锁更高的吞吐量。
  - 公平模式：多线程获取锁的概率相同。

- 可重入

  写锁(写线程)可以在不释放已经拥有的写锁的情况下，重新获取读锁，但是不允许读锁(读线程)获取写锁。

- 锁降级

  可重入特性还允许从写锁降级到读锁——锁降级指的是把持住(当前拥有的)写锁，再获取到读锁，随后释放(先前有用的)写锁的过程。当前线程拥有写锁，然后将其释放，最后再获取读锁，这种并不能称之为锁降级。使用了锁降级，就可以减去释放写锁的步骤。

- 锁获取的中断

  在读锁和写锁的获取过程中支持中断 。

- 支持Condition

  写锁提供了Condition实现，`ReentrantLock.newCondition`读锁不支持Condition。

- 监控

  该类支持确定锁是否持有或争用的方法。这些方法是为了监视系统状态而设计的，而不是用于同步控制。



```java
//锁降级
public static void main(String[] args) {
    CachedData cd = new CachedData();
    for (int i = 0; i < 10; i++) {
        new Thread(new Runnable() {
            @Override
            public void run() {
                cd.processCachedData(Thread.currentThread().getName()+"放入的新数据");
            }
        }
    },"t"+i).start(); 
}


class CachedData {
    //模拟共享数据
    String data = "原来的数据";
    //volatile修饰，保持内存可见性,数据是不是最新的
    volatile boolean isUpdate;
    //可重入读写锁
    final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();

    public void processCachedData(String d) {
        //首先获取读锁
        rwl.readLock().lock();
        //发现数据不是最新的则放弃读锁，获取写锁
        if (!isUpdate) {
            rwl.readLock().unlock();
            rwl.writeLock().lock();
            try {
                if (!isUpdate) {
                    data = d;  //拿到写锁后，把新的数据写入
                    isUpdate = true;
                }
                rwl.readLock().lock(); //没释放写锁直接获取读锁
            } finally {
                //进行锁降级
                rwl.writeLock().unlock();
            }
        }

        try {
            // 使用最新的数据，这个打印一下
            System.out.println(data);
        } finally {
            rwl.readLock().unlock();
        }
    }
}

//输出:t3抢到了写锁修改了数据，isUpdate修改为true,所以其他线程缓存都是最新的
t3放入的新数据
t3放入的新数据
t3放入的新数据
t3放入的新数据
t3放入的新数据
    ...
```

### 集合+读写锁

```java
class RWDictionary {
    //集合对象TreeMap中的元素默认按照keys的自然排序排列。
    //（对Integer来说，其自然排序就是数字的升序；对String来说，其自然排序就是按照字母表排序）
    private final Map<String, Object> m = new TreeMap<String, Object>();
    //读写锁
    private final ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
    //获取读锁
    private final Lock r = rwl.readLock();
    //获取写锁
    private final Lock w = rwl.writeLock();

    public Object get(String key) {
        r.lock();
        try {
            return m.get(key);
        } finally {
            r.unlock();
        }
    }

    public String[] allKeys() {
        r.lock();
        try {
            Set<String> rsSet = m.keySet();
            return rsSet.toArray(new String[rsSet.size()]);
        } finally {
            r.unlock();
        }
    }

    public Object put(String key, Object value) {
        w.lock();
        try {
            return m.put(key, value);
        } finally {
            w.unlock();
        }
    }

    public void clear() {
        w.lock();
        try {
            m.clear();
        } finally {
            w.unlock();
        }
    }
}
```

### 实现读写锁

1. 读/写锁的 Java 实现(Read / Write Lock Java Implementation)
2. 读/写锁的重入(Read / Write Lock Reentrance)
3. 读锁重入(Read Reentrance)
4. 写锁重入(Write Reentrance)
5. 读锁升级到写锁(Read to Write Reentrance)
6. 写锁降级到读锁(Write to Read Reentrance)
7. 可重入的 ReadWriteLock 的完整实现(Fully Reentrant ReadWriteLock)
8. 在 finally 中调用 unlock() (Calling unlock() from a finally-clause)

#### 读/写锁的 Java 实现

```java
/*
读取 没有线程正在做写操作，且没有线程在请求写操作。
写入 没有线程正在做读写操作。

使用writeRequests控制是否有线程在请求写操作，如果存在读线程和写线程同时在wait，当notifyAll唤醒的是读线程时，读线程会因为writeRequests > 0继续等待，将机会让给写线程，实现写线程优先

*/
public class ReadWriteLock{
    private int readers = 0;
    private int writers = 0;
    private int writeRequests = 0;

    public synchronized void lockRead() 
        throws InterruptedException{
        while(writers > 0 || writeRequests > 0){
            wait();
        }
        readers++;
    }

    public synchronized void unlockRead(){
        readers--;
        notifyAll();
    }

    public synchronized void lockWrite() 
        throws InterruptedException{
        writeRequests++;

        while(readers > 0 || writers > 0){
            wait();
        }
        writeRequests--;
        writers++;
    }

    public synchronized void unlockWrite() 
        throws InterruptedException{
        writers--;
        notifyAll();
    }
}
```



**测试**

```java
public static void main(String[] args){
    try {
        ReadWriteLock rwl=new ReadWriteLock();
        log.info("读线程开始");
        new Thread(()->{
            try {
                rwl.lockRead();
                Thread.sleep(5000);
                log.info("读完成");
                rwl.unlockRead();

                log.info("第二次读");
                rwl.lockRead();
                Thread.sleep(5000);
                log.info("读完成");
                rwl.unlockRead();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();
        Thread.sleep(2000);
        log.info("写线程开始");
        new Thread(()->{
            try {
                rwl.lockWrite();
                Thread.sleep(10000);
                log.info("写完成");
                rwl.unlockWrite();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }).start();
        Thread.sleep(60000);
    } catch (Exception e){
        e.printStackTrace();
    }
}


@Slf4j
public class ReadWriteLock {
    private int readers = 0;
    private int writers = 0;
    private int writeRequests = 0;

    public synchronized void lockRead()
            throws InterruptedException{
        log.info("lockRead start,readers={},writers={},writeRequests={}",readers,writers,writeRequests);
        while(writers > 0 || writeRequests > 0){
            wait();
        }
        readers++;
        log.info("lockRead end,readers={},writers={},writeRequests={}",readers,writers,writeRequests);
    }

    public synchronized void unlockRead(){
        log.info("unlockRead start,readers={},writers={},writeRequests={}",readers,writers,writeRequests);
        readers--;
        notifyAll();
        log.info("unlockRead end,readers={},writers={},writeRequests={}",readers,writers,writeRequests);
    }

    public synchronized void lockWrite()
            throws InterruptedException{
        log.info("lockWrite start,readers={},writers={},writeRequests={}",readers,writers,writeRequests);
        writeRequests++;

        while(readers > 0 || writers > 0){
            wait();
        }
        writeRequests--;
        writers++;
        log.info("lockWrite end,readers={},writers={},writeRequests={}",readers,writers,writeRequests);
    }

    public synchronized void unlockWrite()
            throws InterruptedException{
        log.info("unlockWrite start,readers={},writers={},writeRequests={}",readers,writers,writeRequests);
        writers--;
        notifyAll();
        log.info("unlockWrite end,readers={},writers={},writeRequests={}",readers,writers,writeRequests);
    }
}

输出：
17:05:27.285 [main] INFO com.shzx.Test14 - 读线程开始
17:05:27.320 [Thread-0] INFO com.shzx.ReadWriteLock - lockRead start,readers=0,writers=0,writeRequests=0
17:05:27.321 [Thread-0] INFO com.shzx.ReadWriteLock - lockRead end,readers=1,writers=0,writeRequests=0
17:05:29.320 [main] INFO com.shzx.Test14 - 写线程开始
17:05:29.322 [Thread-1] INFO com.shzx.ReadWriteLock - lockWrite start,readers=1,writers=0,writeRequests=0
17:05:32.321 [Thread-0] INFO com.shzx.Test14 - 读完成
17:05:32.321 [Thread-0] INFO com.shzx.ReadWriteLock - unlockRead start,readers=1,writers=0,writeRequests=1
17:05:32.321 [Thread-0] INFO com.shzx.ReadWriteLock - unlockRead end,readers=0,writers=0,writeRequests=1
17:05:32.321 [Thread-0] INFO com.shzx.Test14 - 第二次读
17:05:32.321 [Thread-1] INFO com.shzx.ReadWriteLock - lockWrite end,readers=0,writers=1,writeRequests=0
17:05:32.321 [Thread-0] INFO com.shzx.ReadWriteLock - lockRead start,readers=0,writers=1,writeRequests=0
17:05:42.322 [Thread-1] INFO com.shzx.Test14 - 写完成
17:05:42.322 [Thread-1] INFO com.shzx.ReadWriteLock - unlockWrite start,readers=0,writers=1,writeRequests=0
17:05:42.322 [Thread-1] INFO com.shzx.ReadWriteLock - unlockWrite end,readers=0,writers=0,writeRequests=0
17:05:42.322 [Thread-0] INFO com.shzx.ReadWriteLock - lockRead end,readers=1,writers=0,writeRequests=0
17:05:47.322 [Thread-0] INFO com.shzx.Test14 - 读完成
17:05:47.322 [Thread-0] INFO com.shzx.ReadWriteLock - unlockRead start,readers=1,writers=0,writeRequests=0
17:05:47.322 [Thread-0] INFO com.shzx.ReadWriteLock - unlockRead end,readers=0,writers=0,writeRequests=0

```

参考：[java多线程-读写锁](https://www.cnblogs.com/houziwty/p/5833659.html)



## ForkJoinPool分支合并框架

- ForkJoinPool是ExecutorService的实现类，因此是一种特殊的线程池。
- 使用ForkJoinPool能够使用**数量有限的线程**来完成非常多的具有父子关系的任务。
- ForkJoinPool这个工具从Java7 才开始提供的，优势在于，可以充分利用多cpu，多核cpu的优势，把一个任务拆分成多个“小任务”，把多个“小任务”放到多个处理器核心上并行执行；当多个“小任务”执行完成之后，再将这些执行结果合并起来即可。最终，实现用少量的线程，完成大数量的任务。
- ForkJoinPool使用了一个无限队列来保存需要执行的任务，而线程的数量则是通过构造函数传入，如果没有向构造函数中传入希望的线程数量，那么当前计算机可用的CPU数量会被设置为线程数量作为默认值。

**使用方法：**

- 创建了ForkJoinPool实例之后，就可以调用ForkJoinPool的`submit(ForkJoinTask task)` 或`invoke(ForkJoinTask task)`方法来执行指定任务了。
- 其中ForkJoinTask代表一个可以并行、合并的任务。ForkJoinTask是一个抽象类，它还有两个抽象子类：RecusiveAction和RecusiveTask。其中RecusiveTask代表有返回值的任务，而RecusiveAction代表没有返回值的任务。

```java
//RecusiveAction打印1-300之间的整数
public class ForkJoinPoolAction {
    public static void main(String[] args) throws Exception{
        PrintTask task = new PrintTask(1, 300);
        //创建实例，并执行分割任务
        ForkJoinPool pool = new ForkJoinPool();
        pool.submit(task);
        //线程阻塞，等待所有任务完成
        pool.awaitTermination(2, TimeUnit.SECONDS);
        pool.shutdown();
    }
}

class PrintTask extends RecursiveAction{
    private static final int THRESHOLD = 50; //一次最多只能打印50个数
    private int start;
    private int end;
    public PrintTask(int start, int end) {
        super();
        this.start = start;
        this.end = end;
    }

    @Override
    protected void compute() {
        if(end - start < THRESHOLD){
            for(int i=start;i<end;i++){
                System.out.println(Thread.currentThread().getName()+"的i值："+i);
            }
        }else {
            int middle =(start+end)/2;
            PrintTask left = new PrintTask(start, middle);
            PrintTask right = new PrintTask(middle, end);
            //并行执行两个“小任务”
            left.fork();
            right.fork();
        }
    }
}
```

```java
//通过RecursiveTask的返回值，来对一个长度为300的数组元素进行累加。
public class ForJoinPollTask {
    public static void main(String[] args) throws Exception {
        int[] arr = new int[300];
        Random random = new Random();
        int total =0;
        //初始化100个数组元素
        for(int i=0,len = arr.length;i<len;i++){
            int temp = random.nextInt(20);
            //对数组元素赋值，并将数组元素的值添加到sum总和中
            total += (arr[i]=temp);
        }
        System.out.println("初始化数组总和："+total);

        
        
        SumTask task = new SumTask(arr, 0, arr.length);
		//创建一个通用池，这个是jdk1.8提供的功能
        ForkJoinPool pool = ForkJoinPool.commonPool();
        Future<Integer> future = pool.submit(task); //提交分解的SumTask任务
        System.out.println("多线程执行结果："+future.get());
        pool.shutdown(); //关闭线程池
    }
}

class SumTask extends RecursiveTask<Integer>{
    private static final int THRESHOLD = 20; //每个小任务 最多只累加20个数
    private int arry[];
    private int start;
    private int end;

    public SumTask(int[] arry, int start, int end) {
        super();
        this.arry = arry;
        this.start = start;
        this.end = end;
    }

    @Override
    protected Integer compute() {
        int sum =0;
        //当end与start之间的差小于threshold时，开始进行实际的累加
        if(end - start <THRESHOLD){
            for(int i= start;i<end;i++){
                sum += arry[i];
            }
            return sum;
        }else {//当end与start之间的差大于threshold，即要累加的数超过20个时候，将大任务分解成小任务
            int middle = (start+ end)/2;
            SumTask left = new SumTask(arry, start, middle);
            SumTask right = new SumTask(arry, middle, end);
            //并行执行两个 小任务
            left.fork();
            right.fork();
            //把两个小任务累加的结果合并起来
            return left.join()+right.join();
        }
    }
}
```










































# 实操问题

## CPU使用率飙升

### 原理

CPU 使用率高的关键因素是计算密集型操作

日常程序中常见的耗CPU的操作：

1、频繁GC，访问量高时，有可能造成频繁的GC、甚至FGC。当调用量大时，内存分配过快，就会造成GC线程不停的执行，导致CPU飙高

2、序列化与反序列化，后文中举了一个真实的案例，程序执行xml解析的时，调用量增大的情况下，导致了CPU被打满

3、加密解密

4、正则表达式校验，曾经线上发生一次血案，正则校验将CPU打满。大概原因是：Java 正则表达式使用的引擎实现是 NFA 自动机，这种引擎在进行字符匹配会发生回溯（backtracking）

5、线程上下文切换、当启动了很多线程，而这些线程都处于不断的阻塞状态（锁等待、IO等待等）和执行状态的变化过程中。当锁竞争激烈时，很容易出现这种情况

6、某些线程在做无阻塞的运算，简单的例子while(true)中不停的做运算，没有任何阻塞。写程序时，如果需要做很久的计算，可以适当将程序sleep下

7、Excel 导出事件

[CPU使用率飙升](https://cloud.tencent.com/developer/article/1650717)

### 定位问题

```sh
1. top命令查看系统使用信息，找出消耗最大的进程，如进程id为24152
2. 查找该进程内最耗费CPU的线程,可以使用如下命令：ps -Lfp pid, ps -mp pid -o THREAD, top -Hp pid
如：
$ top -Hp 24152		# 查看java进程中各线程CPU等的使用情况
如最耗费性能的线程pid为24937
3. 获取线程id 24937的十六进制值
$ printf "%x\n" 24937
6169
4. 查看堆栈信息
4.1 使用jstack来输出线程id 24937的堆栈信息，根据线程id的十六进制值grep
$ jstack 24152 | grep 6169
"elasticsearch[Grenade][bulk][T#1]" #49 daemon prio=5 os_prio=0 tid=0x00007f78440b2000 nid=0x6169 runnable [0x00007f7840fa1000]

4.2 查看详细堆栈信息
$ jstack 24152	# 查看进程中所有线程调用栈

4.3 可以导出进程快照
$ jstack -l 24152 > ./24152.stack
# 查看线程操作(-C 表示查找出的文档展示上下10行)
$ cat 24152.stack | grep '6169' -C 10
```

**jstack堆栈信息解析：**

线程状态
Blocking: 现在在等待锁(Lock或synchronized)
Waiting: 等待其他线程执行某些操作
Runnable: 就绪或运行状态
Timed_Waiting: 限时等待


打印出该线程信息，显示该线程是runnable正常运行的就绪状态，经查看详细堆栈信息，应该是es内部创建分片索引的进程，因此占用比较多性能，在对自己环境进程正式排查的时候，可以多进行几次打印，对比多次之间的线程运行情况，正常情况下由于程序运行速度是非常快的，如果发现多次打印对于线程都一直处于同一状态如Runnable，而且堆栈信息也卡在相同的几处地方，就可以考虑看一下对应代码是不是存在死循环或者方法调用缓慢的问题了。

注意JDK运行工具和运行中的java进程必须同一个版本，且必须使用JDK工具所属用户运行命令



Locked ownable synchronizers 每个线程线的最后部分输出的当前线程持有的锁对象，类型和地址。

**备注：**

可以使用perf，Linux自带的强大性能分析工具，可以对对监控事件进行采样(案例：http://brendangregg.com/perf.html)
然后使用 FlameGraph ，生成svg火焰图，直观展示热点代码路径
下载链接：https://github.com/brendangregg/FlameGraph



[jstack](https://www.cnblogs.com/kongzhongqijing/articles/3630264.html) 

[JVM调试工具](https://www.cnblogs.com/JonaLin/p/13859494.html)

[定位消耗CPU最多的线程](https://blog.csdn.net/yue_2018/article/details/106598436)



[内存溢出排查过程，用了MAT和jvisualvm](https://aobing.blog.csdn.net/article/details/105376377?spm=1001.2014.3001.5502)

[排查CPU打到100%](https://aobing.blog.csdn.net/article/details/105278061?spm=1001.2014.3001.5502)

[使用jvisualVM监控远程linux服务器上运行的jar程序](https://blog.csdn.net/dap769815768/article/details/86759911)



[Locked ownable synchronizers（转）](https://www.cnblogs.com/softidea/p/4440290.html)


















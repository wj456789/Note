## try-with-resource

- 传统的`try-finally`方式存在复杂易出错和异常抑制(Suppressed)等问题。 使用`try-with-resource`，可以更安全、简洁地申请和关闭资源，同时解决了异常抑制问题。 
- `try-with-resource`是语法糖，其最终仍然会被编译成`try-finally`方式并调用close方法关闭资源。 
- 为了支持`try-with-resource`，资源类必须要实现`AutoClosable接口`，否则无法使用。在使用`try-with-resource`之前，请务必确认下资源类是否已经实现了`AutoClosable接口`。
- `try-with-resource`使用方式
  - `try-with-resource`使用很简单，申请资源的代码写在try后面的()中即可，无需显式调用`close方法`来关闭资源。 
  - 为了使程序更加健壮，在`try-with-resouce`中使用装饰器时，建议显式声明被装饰/包裹对象的引用。 

### 使用

能够借助`try-with-resource`关闭资源的类必须实现`AutoClosable接口`，重写`close方法`。如果是自定义资源类， 为了支持`try-with-resource`，请务必实现`AutoClosable接口`。 

```java
//申请资源的代码写在try后面的()中即可，资源关闭无需显式close
public void twrClose2NotCatch(String src, String dst) throws IOException {
    try (FileInputStream ins = new FileInputStream(src);
         OutputStream outs = new FileOutputStream(dst)) {
        byte[] buf = new byte[BUF_SIZE];
        int n;
        while ((n = ins.read(buf)) >= 0) {
            outs.write(buf, 0, n);
        }
    }
}
```

`try-with-resource`主要做了两件事：

- 添加调用close方法的代码，关闭资源。
- 使用addSuppressed方法附加异常，消除异常抑制的问题。

#### try-finally举例

##### 异常抑制

异常抑制（Suppressed）也有叫异常覆盖和异常屏蔽

```java
public class ConnectionNormal {
    public void send() throws Exception {
        throw new SendException("send fail.");
    }

    public void close() throws Exception {
        throw new CloseException("close fail");
    }
}

//按照程序逻辑，应该先抛出SendException，再抛出CloseException：
public static void main(String[] args) {
    try {
        test();
    } catch (Exception e) {
        e.printStackTrace();
    }
}


private static void test() throws Exception {
    ConnectionNormal conn = null;
    try {
        conn = new ConnectionNormal();
        conn.send();
    } finally {
        if (conn != null) {
            conn.close();
        }
    }
}

//运行后我们发现：
com.CloseException: close fail
at com.ConnectionNormal.close(ConnectionNormal.java:10)
    at com.TryWithResource.test(TryWithResource.java:20)
    at com.TryWithResource.main(TryWithResource.java:6)
```

SendException明明先被抛出了，但是没有丝毫痕迹，被后抛的CloseException给抑制了，这就是异常抑制，SendException被称为Suppressed Exception。关键的异常信息丢失，这会导致某些bug变得极其隐蔽而难以发现！

#### try-with-resource举例

`try-with-resource`为`Throwable类`新增了`addSuppressed方法`，支持将一个异常附加到另一个之上，从而解决异常抑制。

```java
public class ConnectionAutoClose implements AutoCloseable{
    public void send() throws Exception {
        throw new SendException("send fail.");
    }
    @Override
    public void close() throws Exception {
        throw new CloseException("close fail");
    }
}

private static void test2() {
    try (ConnectionAutoClose conn = new ConnectionAutoClose()) {
        conn.send();
    } catch (Exception e) {
        e.printStackTrace();
    }
}

运行结果：
com.SendException: send fail.
    at com.ConnectionAutoClose.send(ConnectionAutoClose.java:5)
    at com.TryWithResource.test2(TryWithResource.java:27)
    at com.TryWithResource.main(TryWithResource.java:6)
    Suppressed: com.CloseException: close fail
at com.ConnectionAutoClose.close(ConnectionAutoClose.java:10)
        at com.TryWithResource.test2(TryWithResource.java:28)
        ... 1 more
```

### 原理

```java
//try-with-resource反编译.class
private static void test2() {
    try {
        ConnectionAutoClose conn = new ConnectionAutoClose();
        Throwable var1 = null;
        try {
            conn.send();
        } catch (Throwable var11) {
            var1 = var11;
            throw var11;
        } finally {
            if (conn != null) {
                if (var1 != null) {
                    try {
                        conn.close();
                    } catch (Throwable var10) {
                        var1.addSuppressed(var10);
                    }
                } else {
                    conn.close();
                }
            }
        }
    } catch (Exception var13) {
        var13.printStackTrace();
    }
}
```

### 显式声明

为了使程序更加健壮，在try-with-resouce中使用装饰器时，建议显式声明被装饰 / 包裹对象的引用。

```java
//在finally中仅调用了out.close()，在GZIPOutputStream.close内部，会关闭被包裹的FileOutputStream，但是这个关闭可能会失败
public void gzipWrapper(File file) throws IOException {
   try (GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(file))) {
      ...
  }
}
```

```java
//fout.close一定会被调用
public void gzipWrapperRobust(File file) throws IOException {
   try (FileOutputStream fout = new FileOutputStream(file); // 显式声明
        GZIPOutputStream out = new GZIPOutputStream(fout)) {
      ...
  }
}
```



## 正则表达式

```java
//IPv4的地址格式，总长度 32位=4段*8位，每段之间用.分割， 每段都是0-255之间的十进制数值
System.out.println("10.45.168.74".matches("^((25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d)))\\.){3}(25[0-5]|2[0-4]\\d|((1\\d{2})|([1-9]?\\d)))$"));
//端口号0-65535
System.out.println("8080".matches("^([0-9]|[1-9]\\d|[1-9]\\d{2}|[1-9]\\d{3}|[1-5]\\d{4}|6[0-4]\\d{3}|65[0-4]\\d{2}|655[0-2]\\d|6553[0-5])$"));
```



## Java基础

### 类型强转

```java
Object obj;
List<Integer> list = castList(obj,Integer.class);
//list强转
private static <T> List<T> castList(Object obj, Class<T> clazz) {
    List<T> result = new ArrayList<T>();
    if (obj instanceof List<?>) {
        for (Object o : (List<?>) obj) {
            result.add(clazz.cast(o));
        }
        return result;
    }
    return null;
}
```

```java
Object obj;
Map<String,Object> map = castHashMap(obj,String.class,Object.class);

/**
 * 防止出现强转警告
 *
 * @param obj 强转对象
 * @param clazz1 HashMap的key
 * @param clazz2 HashMap的value
 * @param <K> Key泛型
 * @param <V> Value泛型
 * @return 强转后对象
 */
private <K, V> HashMap<K, V> castHashMap(Object obj, Class<K> clazz1, Class<V> clazz2) {
    HashMap<K, V> result = new HashMap<K, V>();
    if (obj instanceof HashMap<?, ?>) {
        for (Object o : ((HashMap<?, ?>) obj).keySet()) {
            result.put(clazz1.cast(o), clazz2.cast(((HashMap<?, ?>) obj).get(o)));
        }
        return result;
    }
    return null;
}
```



## 解压tar包

```java
private static final int BUFFER = 512;
private static final int TOOBIG = 0x6400000; // max size of unzipped data, 100MB
private static final int TOOMANY = 1024; // max number of files

public static void main(String[] args) {
    String sourcePath = "";
    String destDir = "";
    TarEntry entry;
    //接收byte[]数据  TarInputStream tis = new TarInputStream(new ByteArrayInputStream(sourceData))
    try (FileInputStream fis = new FileInputStream(sourcePath);
         TarInputStream tis = new TarInputStream(fis)) {
        while ((entry = tis.getNextEntry()) != null) {
            int total = 0;
            int entries = 0;
            byte[] data = new byte[BUFFER];
            String destPath = FileUtil.sanitzeFileName(entry.getName(), destDir);
            int count;
            try (FileOutputStream fos = new FileOutputStream(destPath)) {
                while ((count = tis.read(data, 0, BUFFER)) != -1) {
                    total += count;
                    if (total > TOOBIG) {
                        log.error("fileSize in package is too big");
                    }
                    fos.write(data, 0, count);
                }
                if (++entries > TOOMANY) {
                    log.error("fileNum in package is too many");
                }
            }
        }
    } catch (IOException e) {
        log.error("decompressTar error", e);
    }
}

/**
 * 文件路径检查
 *
 * @param entryName 文件名称
 * @param intendedDir 文件路径
 * @return 文件全路径
 * @throws IOException
 */
public static String sanitzeFileName(String entryName, String intendedDir) throws IOException {
    String canonicalPath = new File(intendedDir, entryName).getCanonicalPath();
    String canonicalID = new File(intendedDir).getCanonicalPath();
    if (canonicalPath.startsWith(canonicalID)) {
        return canonicalPath;
    } else {
        throw new IllegalStateException("File is outside extraction target directory.");
    }
}
```

## 数据运算越界检查

> oldAcc + (newVal * scale)

### 先决条件检查 

```java
public int safeAdd(int left, int right) {
    if (right > 0 ? left > Integer.MAX_VALUE - right
        : left < Integer.MIN_VALUE - right) {
        throw new ArithmeticException("Integer overflow");
    }
    return left + right;
}

//Java数据类型的合法取值范围是不对称的（最小值的绝对值比最大值大1），所以对最小值取负时，会导致溢出。
public int safeMultiply(int left, int right) {
    if (right > 0 ? left > Integer.MAX_VALUE / right
        || left < Integer.MIN_VALUE / right
        : (right < -1 ? left > Integer.MIN_VALUE / right 
           || left < Integer.MAX_VALUE / right
           : right == -1 && left == Integer.MIN_VALUE)) {
        throw new ArithmeticException("Integer overflow");
    }
    return left * right;
}
```

### 向上类型转换 

该方式对long类型不适用。 

```java
public static long intRangeCheck(long value) {
    // 向上类型转换
    if ((value < Integer.MIN_VALUE) || (value > Integer.MAX_VALUE)) {
        throw new ArithmeticException("Integer overflow");
    }
    return value;
}

public static int multAccum(int oldAcc, int newVal, int scale) {
    final long res = intRangeCheck(((long) oldAcc) +
                                   intRangeCheck((long) newVal * (long) scale));
    return (int) res; // Safe downcast
}
```

### BigInteger 

```java
private static final BigInteger bigMaxInt = BigInteger.valueOf(Integer.MAX_VALUE);
private static final BigInteger bigMinInt = BigInteger.valueOf(Integer.MIN_VALUE);
// BigInteger检查是否存在溢出
public static BigInteger intRangeCheck(BigInteger val) {
    if (val.compareTo(bigMaxInt) == 1 || val.compareTo(bigMinInt) == -1) {
        throw new ArithmeticException("Integer overflow");
    }
    return val;
}

public static int multAccum(int oldAcc, int newVal, int scale) {
    BigInteger product = BigInteger.valueOf(newVal).multiply(BigInteger.valueOf(scale));
    BigInteger res = intRangeCheck(BigInteger.valueOf(oldAcc).add(product));
    return res.intValue(); // Safe conversion
}
```

## Normalizer.normalize()

normalize方法对外部输入字符串做归一化/标准化处理，如：

```java
//将全角形式的字符转化为半角形式的字符，"＜root＞"-->"<root>"
Normalizer.normalize(str,Normalizer.Form.NFKC);
```

[关于Normalizer.normalize()方法的用途](https://blog.csdn.net/u010512607/article/details/79921353)

## @PostConstruct和@PreDestory执行顺序

构造函数==》postConstruct==>init==destory==>predestory==卸载servlet;;  



## Git

### 使用Git初始化本地仓库并首次提交代码到远程仓库

1. 首先，登录GitLab，创建一个新项目的私人仓库； 

2. 然后，在本地仓库（就是你写代码文件夹），右键，Git Bash Here，打开Git命令窗口； 

3. 按照如下步骤，添加远程仓库地址，并提交代码；  

   ```sh
   git init                           #初始化仓库
   git add .						 #把所有文件和文件夹添加到；
   git commit -m "first commit"       #把代码提交到本地仓库，并备注信息；
   git remote add origin 仓库地址      #设置远程仓库地址，创建远程主分支；
   git pull origin master 		       #把本地仓库的变化连接到远程仓库主分支
   git push -u origin master          #提交代码到远程仓库，master分支；
   ```

   

   添加远程仓库可能报错：fatal: remote origin already exists. 

   

   不使用pull直接push可能报如下错误：Updates were rejected because the remote contains work that you do












# 华为Java语言安全编程规范

## 前言

### 安全编码基本思想

- 程序在处理外部数据时必须经过严格的合法性校验 

- 避免与外部环境做多余的数据交互
- 通过防御性的编码策略来弥补潜在的编码人员的疏忽

### 不可信数据定义

文件（包括程序的配置文件）
注册表
网络
环境变量
命令行
用户输入（包括命令行、界面）
用户态数据（对于内核程序）
进程间通信（包括管道、消息、共享内存、socket等、RPC）
函数参数（对于API）
全局变量（在本函数内，其他线程会修改全局变量）



## 1 数据校验

### 规则 1.1 跨信任边界传递的不可信数据使用前必须进行校验

- 白名单验证接收
- 黑名单验证拒绝
- 白名单净化，净化的方式包括删除、编码、替换
  - 对所有非字母数字进行编码，如对“I like your web page!”使用URL编码，其净化后的输出为“I+like+your+web+page%21”
- 黑名单净化，剔除或者转换某些字符

### 规则 1.2 禁止直接使用不可信数据来拼接SQL语句

- 使用参数化查询：最有效的防护手段，对于sql语句中的表名、字段名、部分场景下的in条件不适用；

  ```java
  //如果攻击者的itemName输入为name' OR 'a' = 'a，参数化查询将会查找itemName匹配name' OR 'a' = 'a字符串的条目，而不是返回整个表中的所有条目
  
  String sqlString = "SELECT * FROM t_item WHERE owner=? AND itemName=?";
  stmt = connection.prepareStatement(sqlString);
  stmt.setString(1, userName);
  stmt.setString(2, itemName);
  rs = stmt.executeQuery();
  ```

  

- 对不可信数据进行白名单校验：适用于拼接sql语句中的表名、字段名；

  ```java
  cs = connection.prepareCall("{call sp_queryItem(?,?)}");
  cs.setString(1, userName);
  cs.setString(2, itemName);
  results = cs.executeQuery();
  
  //错误
  CREATE PROCEDURE sp_queryItem
      @userName varchar(50),
      @itemName varchar(50)
  AS
  BEGIN
      DECLARE @sql nvarchar(500);
      SET @sql = 'SELECT * FROM t_item
          WHERE owner = ''' + @userName + '''
          AND itemName = ''' + @itemName + '''';
      EXEC(@sql);
  END
  GO
  
  SQL Server正确存储过程：
  CREATE PROCEDURE sp_queryItem
      @userName varchar(50),
      @itemName varchar(50)
  AS
  BEGIN
      SELECT * FROM t_item
      WHERE userName = @userName
      AND itemName = @itemName;
  END
  GO
  ```

  ```xml
  <!--iBATIS SQL映射允许在SQL语句中通过#字符指定动态参数，例如：-->
  <select id="getItems" parameterClass="MyClass" resultClass="Item">
  	SELECT * FROM t_item WHERE owner = #userName# AND itemName = #itemName#
  </select>
  
  <!--错误-->
  <select id="getItems" parameterClass="MyClass" resultClass="items">
  	SELECT * FROM t_item WHERE owner = #userName# AND itemName = '$itemName$'
  </select>
  ```

  

- 对不可信数据进行转码：适用于拼接到sql语句中的由引号限制的字段。

  ```java
  public List<Book> queryBooks(List<Expression> queryCondition) {
  /* ... */
  try {
      StringBuilder sb = new StringBuilder("select * from t_book where ");
      Codec oe = new OracleCodec();
      if (queryCondition != null && !queryCondition.isEmpty()) {
          for (Expression e : queryCondition) {
              String exprString = e.getColumn() + e.getOperator();
              String safeValue = HWEncoder.encodeForSQL(oe, e.getValue());
              sb.append(exprString).append("'").append(safeValue).append("' and ");
          }
      sb.append("1=1");
      Statement stat = connection.createStatement();
      ResultSet rs = stat.executeQuery(sb.toString());
      //other omitted code
      }
  }
  /* ... */
  }
  ```

  

### 规则 1.3 禁止直接使用不可信数据记录日志

```java
if (!Pattern.matches("[A-Za-z0-9_]+", username)) {
    // Unsanitized username
    logger.severe("User login failed for unauthorized user");
} else if (loginSuccessful) {
    logger.severe("User login succeeded for: " + username);
} else {
    logger.severe("User login failed for: " + username);
}

//如果只需消除换行符和回车符，那么可以在记录日志前调用如下函数即可：
public String getcleanedMessage(String message){
    if (message == null) {
    	return "";
    }
    message = message.replace('\n', '_').replace('\r', '_');???
    return message;
}
```

### 规则 1.4 禁止使用不可信数据构造格式化字符串

```java
//如果没有经过正确的输入校验，攻击者可以通过提供一段包含%1tm、 te和%1ty之一的输入 ， 来 识 别日 期 。 例 如 攻 击 者输入"Date:tY-%1tm-te"，这样代码就会将具体的时间信息打印出来，实际输出如下：“Date: 1995-05-23 did not match! HINT: It was issued on 23rdof some month”。
class Format {
	static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);
    public static void main(String[] args) {
    	System.out.printf(args[0]+ " did not match! HINT: It was issued on %1$terd of some month",c);???
    }
}

//正确
class Format {
    static Calendar c = new GregorianCalendar(1995, GregorianCalendar.MAY, 23);
    public static void main(String[] args) {
    	System.out.printf("%s did not match! " + " HINT: It was issued on %2$terd of some month", args[0], c);
    }
}
```

### 规则 1.5 禁止向Runtime.exec()方法或java.lang.ProcessBuilder类传递不可信数据

执行系统命令或者外部程序

```java
//避免使用 Runtime.exec(),如果无法避免使用Runtime.exec()，则必须要对输入数据进行检查和净化

public static void main(String[] args) {
    …
    try {
        String encodeIP = HWEncoder.encodeForOS(new WindowsCodec(), args[0]);
        String cmd = "cmd.exe /c ping " + encodeIP;
        Process proc = Runtime.getRuntime().exec(cmd);
        …
    } catch (IOException ex) {
    	…
    }
    …
}
```

### 规则 1.6 文件路径校验前必须先进行标准化处理

目录遍历漏洞使得攻击者能够转移到一个特定目录进行I/O操作，等价路径漏洞使得攻击者可以使用与某个资源名不同但是等价的名称来绕过安全检查。

对于文件路径校验场景，获取文件路径时，必须使用getCanonicalPath()，禁止使用getAbsolutePath()。

```java
public static void main(String[] args) throws IOException {
    File f = new File(System.getProperty("user.home") + System.getProperty("file.separator") + args[0]);
    String canonicalPath = f.getCanonicalPath();//返回文件的绝对路径
    if (!isInSecureDir(Paths.get(canonicalPath))) {
    	...
    	throw new IllegalArgumentException();
    }
    if (!validate(canonicalPath)) {
        // Validation
    	throw new IllegalArgumentException();
    }
    /* ... */
}
```

### 规则 1.7 从ZipInputStream中解压文件必须进行安全检查

```java
static final int BUFFER = 512;
static final int TOOBIG = 0x6400000; // max size of unzipped data, 100MB
static final int TOOMANY = 1024; // max number of files

private String sanitzeFileName(String entryName, String intendedDir) throws IOException {
    File f = new File(intendedDir, entryName);
    String canonicalPath = f.getCanonicalPath();
    File iD = new File(intendedDir);
    String canonicalID = iD.getCanonicalPath();
    if (canonicalPath.startsWith(canonicalID)) {
    	return canonicalPath;
    } else {
    	throw new IllegalStateException("File is outside extraction target directory.");
    }
}

public final void unzip_compilant(String fileName， String destDir) throws java.io.IOException {
    …
    try {
        while ((entry = zis.getNextEntry()) != null) {
            BufferedOutputStream dest = null;
            int count;
            // Write the files to the disk, but ensure that the
            // entryName is valid,and that the file is not insanely big
            String name = sanitzeFileName(entry.getName(), destDir);
            …
            // process file
            FileOutputStream fos = new FileOutputStream(name);
            dest = new BufferedOutputStream(fos, BUFFER);
            // check every entry's size
            while (count = zis.read(data, 0, BUFFER) != -1) {
                total += count;
                if (total > TOOBIG) {
                	break;
                }
                dest.write(data, 0, count);
            }
            entries++;
            // if the total number of entry is larger than the max
            // number,it will throw exception.
            if (entries > TOOMANY) {
            	//handle exception
            }
            // if the total size of zip file is bigger than the max size
            // value,it will throw exception.
            if (total > TOOBIG) {
            	//handle exception
            }
            //finally close stream
            …
        }
    }
    finally {
    // close stream
    }
}
```



### 规则 1.8 禁止直接使用不可信数据来拼接XML	

```java
//白名单校验
private void createXMLStream(BufferedOutputStream outStream, User user) throws IOException {
    // Write XML string if userID contains alphanumeric and underscore characters only
    if (!Pattern.matches("[_a-bA-B0-9]+", user.getUserId())) {
    	// Handle format violation
    }
    if (!Pattern.matches("[_a-bA-B0-9]+", user.getDescription())) {
    	// Handle format violation
    }
    String xmlString = "<user><id>" + user.getUserId()
    	+ "</id><role>operator</role><description>"
    	+ user.getDescription() + "</description></user>";
    outStream.write(xmlString.getBytes());
    outStream.flush();
}


//使用安全的XML库，使用dom4j来构建XML，Dom4j将会对文本数据域进行XML编码，从而使得XML的原始结构和格式免受破坏。	
public static void buidlXML(FileWriter writer, User user) throws IOException {
    Document userDoc = DocumentHelper.createDocument();
    Element userElem = userDoc.addElement("user");
    Element idElem = userElem.addElement("id");
    idElem.setText(user.getUserId());
    Element roleElem = userElem.addElement("role");
    roleElem.setText("operator");
    Element descrElem = userElem.addElement("description");
    descrElem.setText(user.getDescription());
    XMLWriter output = null;
    try {
        OutputFormat format = OutputFormat.createPrettyPrint();
        format.setEncoding("UTF-8");
        output = new XMLWriter(writer, format);
        output.write(userDoc);
        output.flush();
    }
    finally {
        try {
            output.close();
        } catch (Exception e) {
        	// handle exception
        }
    }
}

//转码
private void createXMLStream(BufferedOutputStream outStream, User user) throws IOException {
    …
    String encodeUserId = HWEncoder.encodeForXML(user.getUserId());
    String encodeDec = HWEncoder.encodeForXML(user.getDescription());
    String xmlString = "<user><id>" + encodeUserId + "</id><role>operator</role><description>" +
    	encodeDec
    	+ "</description></user>";
    outStream.write(xmlString.getBytes());
    outStream.flush();
}
```

???

### 规则 1.9 防止解析不可信来源的XML导致的外部实体（XML External Entity）攻击

### 规则 1.10 防止解析不可信来源的XML导致的内部实体扩展（XML Entity Expansion）攻击

### 规则 1.11 禁止使用不安全的XSLT转换XML文件

### 规则 1.12 禁止直接使用不可信数据构造正则表达式

> 在用户输入字符串提交给正则解析之前，进行白名单字符处理（比如字母和数字）是一个很好的输入净化策略。
>
> ReDos攻击是Java代码正则使用不当导致的常见安全风险。容易存在ReDos攻击的正则表达之主要有两类：	

### 建议 1.1 字符串校验前先进行标准化

```java
//验证字符串之前对其进行标准化，将字符串中的“\uFE64”“\uFE65”替代为“<”“>”，后续黑名单校验正确检测恶意输入“<script>”并抛出IllegalStateException。
String s = "\uFE64" + "script" + "\uFE65";
// Normalize
s = Normalizer.normalize(s, Form.NFKC);
// Validate
Pattern pattern = Pattern.compile("[<>]");
Matcher matcher = pattern.matcher(s);
if (matcher.find()) {
    // Found blacklisted tag
    throw new IllegalStateException();
}else {
    // ...
}
```



## 2 方法与表达式

### 规则 2.1 禁止直接使用可能为null的对象，防止出现空指针引用

### 建议 2.1 不要在断言中使用有副作用的表达式

> 使用assert断言语是对代码进行诊断测试的方便机制。当使用有副作用的断言表达式时，assert语句的行为
> 取决于运行时属性的状态，启用时，assert语句会计算表达式的值，如果值为false时抛出AssertionError异常；当关闭断言时，assert语句(断言表达式)不执行，导致程序的运行结果不一致。所以应该禁止在断言
> 中使用有副作用的表达式。有副作用的表达式一般指更改对象状态或修改变量值等操作的语句。

```java
private ArrayList<String> names;
void process(int index) {
    boolean nullsRemoved = names.remove(null);
    assert nullsRemoved; // No side effect
    // ...
}
```

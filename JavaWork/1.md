## NIO

NIO（Non-blocking I/O，在Java领域，也称为New I/O）：一种同步非阻塞的I/O模型

Buffer（缓冲区）、Channel（通道）、Selector（选择器） 

client-->Buffer-->Channel<-->Channel-->Buffer-->server

### Buffer

Buffer：缓冲区本质为一块可读写数据的内存，Java中包装为Buffer对象，并提供了一组操作方法

Java NIO不同于IO的一点：NIO面向缓冲区，而IO面向流

- 读中，limit和capacity的含义相同；写中，capacity仍然代表这块缓冲区的大小，limit代表写的范围。 
- 标记（mark）一个备忘位置，调用mark()方法的话，mark值将存储当前position的值，等下次调用reset()方法时，会设定position的值为之前的标记值； 
- (capacity、limit、position、mark) 四个属性值之间的关系：0 <= mark <= position <= limit <= capacity

### Channel 

- 双向异步，可读可写
- 通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入

### Selector

Selector：用于侦听多个通道是否已做好读写准备，配合非阻塞IO实现单个线程管理多个通道。



## 类加载

### 类加载过程

**加载 --> 链接 --> 初始化**

**链接：验证 --> 准备 --> 解析**

#### 加载

由类加载器（ClassLoader）执行的。将字节码从不同数据源读到 jvm 中，数据源包括 zip 压缩包，网络，运行时计算生成，其他文件生成，数据库等。

#### 链接

验证：验证字节码信息是否符合 jvm 规范；

准备：分配内存，并为静态变量赋初始值；

解析：将常量池中的符号引用转换为直接引用。也可以在初始化之后再开始，来支持 java 的运行时绑定。

#### 初始化

执行静态初始化块 (static{}) 和类变量赋值，先初始化父类，后初始化子类；

不要在 static 块中抛出异常，否则会导致类初始化失败，抛 ExceptionInInitializerError 异常，进而导致其他异常。

#### 懒加载

所有的类都是在对其第一次使用时，动态加载到 JVM 中的。当程序创建第一个对类的静态成员的引用时，就会加载这个类。使用 new 创建类对象的时候也会被当作对类的静态成员的引用。因此 java 程序在它开始运行之前并非被完全加载，其各个类都是在必需时才加载的。

### classloader的层次结构

1. 启动类加载器 (BootstrapClassLoader)

   查找 jre 核心库，加载路径下的 Class 文件

2. 扩展类加载器 (ExtClassLoader)

   查找 jre/lib/ext 扩展包

3. 应用程序类加载器 (AppClassLoader)

   查找环境变量 CLASSPATH 目录

4. 自定义类加载器 (UserDefineClassLoader)

   查找用户定义的目录



双亲委派：先由父类加载器加载，加载不到后再由子类加载器加载；

如果Class文件不在父类的加载路径中，则由子类加载，如果仍然找不到，抛ClassNotFound异常。

先加载 JDK 中的类，再加载用户的类。

### 类的初始化过程

#### 初始化时机（类加载时机）

- JVM 启动时，先初始化用户指定的主类
- 初始化一个类的子类（会首先初始化子类的父类）

-  访问类的静态变量或静态方法
-  创建类实例
-  反射调用类

https://blog.csdn.net/weixin_39983051/article/details/111361114

特点：JVM 会加锁来保证类初始化只进行一次，可以用来实现单例模式

### 对象初始化顺序

普通类：（静态变量和静态代码块只和出现顺序有关，普通变量和普通代码块也之和出现顺序有关）

1. 静态变量
2. 静态代码块
3. 普通变量
4. 普通代码块
5. 构造函数

继承的子类：（静态——父类——子类）

1. 父类静态变量
2. 父类静态代码块
3. 子类静态变量
4. 子类静态代码块
5. 父类普通变量
6. 父类普通代码块
7. 父类构造函数
8. 子类普通变量
9. 子类普通代码块
10. 子类构造函数

类初始化顺序：父类静态，子类静态，父类代码块、父类构造，子类代码块，子类构造。

在 JVM 中表示两个 Class 对象是否为同一个类存在两个必要条件：

- 类的完整类名必须一致
- 加载这个类的ClassLoader（指ClassLoader实例对象）必须相同

换句话说，在 JVM 中，即时这两个类对象（class对象）来源于同一个 Class 文件，被同一个虚拟机所加载，但只要加载他们的 ClassLoader 实例对象不同，那么这两个类对象也是不相等的。



















### 外部和内部类

1. 外部类初次加载，会初始化静态变量、静态代码块、静态方法，但不会加载内部类和静态内部类。
2. 实例化外部类，调用外部类的静态方法、静态变量，则外部类必须先进行加载，但只加载一次。
3. 直接调用静态内部类时，外部类不会加载。



## JVM

### 栈内存

#### 虚拟机栈

- 虚拟机栈线程私有，每个线程都有自己独立的虚拟机栈
- 虚拟机栈是用于描述java方法执行的内存模型。 每个java方法在执行时，会创建一个“栈帧”。
- 通常说的“栈内存”，确切的说，指的是虚拟机栈的栈帧中的局部变量表，因为这里存放了一个方法的所有局部变量。 

##### 栈帧

栈帧的大小在程序代码编译时确定。

栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构。栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。每一个方法从调用至执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。

一个线程中方法的调用链可能会很长，很多方法都同时处于执行状态。对于JVM执行引擎来说，在在活动线程中，只有位于JVM虚拟机栈栈顶的元素才是有效的，即称为当前栈帧，与这个栈帧相关连的方法称为当前方法，定义这个方法的类叫做当前类。

##### 异常

- 虚拟机栈的StackOverflowError

  若单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError

  JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽。比如一个无结束条件的递归函数调用。

- 虚拟机栈的OutOfMemoryError

  不同于StackOverflowError，OutOfMemoryError指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。

  JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存”。当虚拟机栈能够使用最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常。

###### 详解

内存泄漏（StackOverflowError）：是指**程序在申请内存后，无法释放已申请的内存空间**，导致系统无法及时回收内存并且分配给其他进程使用。通常少次数的内存无法及时回收并不会到程序造成什么影响，但是如果在内存本身就比较少获取多次导致内存无法正常回收时，就会导致内存不够用，最终导致内存溢出。
内存溢出 （OutOfMemoryError）：:指**程序申请内存时，没有足够的内存供申请者使用**，导致数据无法正常存储到内存中。也就是说给你个int类型的存储数据大小的空间，但是却存储一个long类型的数据，这样就会导致内存溢出。

关系：内存泄露最终会导致内存溢出，由于系统中的内存是有限的，如果过度占用资源而不及时释放，最后会导致内存不足，从而无法给所需要存储的数据提供足够的内存，从而导致内存溢出。导致内存溢出也可能是由于在给数据分配大小时没有根据实际要求分配，最后导致分配的内存无法满足数据的需求，从而导致内存溢出。

区别：内存泄露是由于GC无法及时或者无法识别可以回收的数据进行及时的回收，导致内存的浪费；内存溢出是由于数据所需要的内存无法得到满足，导致数据无法正常存储到内存中。内存泄露的多次表现就是会导致内存溢出。



- `java.lang.OutOfMemoryError: Java heap space`: 堆内存不足。可能为内存泄漏、堆配置过小或配置不合理。可通过-Xms, -Xmx配置。

  ```sh
  # 打印当前对象的个数和大小
  $ jmap -histo <java_pid>
  
  # 打印当前存活对象的个数和大小,此命令会触发一次full gc
  $ jmap -histo:live <java_pid>
  
  # 查看gc情况
  $ jstat -gc <pid> 
  
  # 获取内存信息
  $ jmap -heap:format=b <java_pid> 
  在启动时增加-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath="具体的路径"，当系统OutOfMemory之后，会将内存信息收集下来。
  
  
  jmap -dump:live,format=b,file=aaa 29082
  ```

  ```sh
  1. top命令查看系统使用信息，找出消耗最大的进程，如进程id为24152
  2. 查找该进程内最耗费CPU的线程,可以使用如下命令：
  ps -Lfp pid, ps -mp pid -o THREAD, top -Hp pid
  如：
  $ top -Hp 24152
  如最耗费性能的线程pid为24937
  获取线程id 24937的十六进制值
  $ printf "%x\n" 24937
  6169
  使用jstack来输出线程id 24937的堆栈信息，根据线程id的十六进制值grep
  $ jstack 24152 | grep 6169
  "elasticsearch[Grenade][bulk][T#1]" #49 daemon prio=5 os_prio=0 tid=0x00007f78440b2000 nid=0x6169 runnable [0x00007f7840fa1000]
  查看详细堆栈信息
  $ jstack 24152
  
  打印出该线程信息，显示该线程是runnable正常运行的就绪状态，经查看详细堆栈信息，应该是es内部创建分片索引的进程，因此占用比较多性能，在对自己环境进程正式排查的时候，可以多进行几次打印，对比多次之间的线程运行情况，正常情况下由于程序运行速度是非常快的，如果发现多次打印对于线程都一直处于同一状态如Runnable，而且堆栈信息也卡在相同的几处地方，就可以考虑看一下对应代码是不是存在死循环或者方法调用缓慢的问题了。
  
  注意JDK运行工具和运行中的java进程必须同一个版本，且必须使用JDK工具所属用户运行命令
  ```

https://www.jianshu.com/p/a4ad53179df3

https://www.cnblogs.com/kongzhongqijing/articles/3630264.html

https://www.cnblogs.com/JonaLin/p/13859494.html

https://blog.csdn.net/yue_2018/article/details/106598436

- `java.lang.OutOfMemoryError: PermGen`: JDK1.7以前，“space“: 永久代(方法区)空间不足。一般为加载类型过多(加载过多的class文件)引起。可通过-XX:PermSize和-XX:MaxPermSize配置，也可以查看是否使用 -noclassgc 参数，JDK1.8之后为 `java.lang.OutOfMemoryError: Metaspace` 。
- `StackOverFlowError`: 栈空间不足。一般为递归调用引起。通过-Xss配置。
- `java.lang.OutOfMemoryError`: 可能为直接内存溢出。一般为通过 NIO 或 JNI 不断分配内存导致。通过 -XX:MaxDirectMemorySize配置。





#### 本地方法栈

本地方法栈的功能和特点类似于虚拟机栈，均具有线程隔离的特点以及都能抛出StackOverflowError和OutOfMemoryError异常。不同的是，本地方法栈服务的对象是JVM执行的native方法，而虚拟机栈服务的是JVM执行的java方法。 



### 直接内存

NIO的Buffer提供了一个可以不经过JVM内存直接访问**系统物理内存**的类——DirectBuffer。 

DirectBuffer类继承自ByteBuffer，但和普通的ByteBuffer不同，普通的ByteBuffer仍在JVM堆上分配内存，其最大内存受到最大堆内存的限制；

而DirectBuffer直接分配在物理内存中，并不占用堆空间，其可申请的最大内存受操作系统限制。

直接内存的单次分配和读写操作比普通Buffer快，但它的创建、销毁比普通Buffer慢。因此直接内存使用于需要大内存空间且频繁访问的场合，不适用于频繁申请释放内存的场合。

比如 Java8 使用元空间：元空间主要存储加载的类信息，这些数据只会在程序启动时直接分配足够的直接内存，可以减少程序的启动时间，运行期一般不会频繁加载新的类，故运行期不需要频繁分配内存。堆内存主要存放的是运行时对象，需要频繁的创建与销毁。 

直接内存可以使用 -XX:MaxDirectMemorySize 配置 

### 堆内存

Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。 

### 引用类型

- 强引用：发生 gc 的时候不会被回收。
- 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。
- 弱引用：有用但不是必须的对象，在下一次GC时会被回收。
- 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。

#### 详解

##### strong reference

Object c = new Car(); //只要c还指向car object, car object就不会被回收，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

##### soft reference 

当系统内存不足时， soft reference指向的object才会被回收。

有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。 

##### weak reference

描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 

`WeakReference<Car> weakCar = new WeakReference<Car>(car);`

当一个对象仅仅被 weak reference 指向, 而没有任何其他 strong reference 指向的时候, 如果GC运行, 那么这个对象就会被回收。当要获得 weak reference 引用的 object 时, 首先需要判断它是否已经被回收     :`if(weakCar.get()!=null)`。

另外， java提供了一个ReferenceQueue来保存这些所指向的对象已经被回收的reference。

##### PhantomReference

无用对象，这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。 

### 垃圾识别

不会被访问到的对象是垃圾 

#### GC root 可达性分析

**GC root原理**：通过对枚举GC root对象做引用可达性分析，即从GC roots对象开始，向下搜索，形成的路径称之为引用链（从GC Roots开始遍历对象，没有被遍历到的对象为垃圾 ）。如果一个对象到GC roots对象没有任何引用，没有形成引用链，那么该对象等待GC回收。 

**Java中可以作为GC Roots的对象**

1、虚拟机栈（javaStack）中引用的对象，也就是方法栈使用到的参数、局部变量、临时变量等。

2、方法区中的类静态属性引用的对象。

3、方法区中常量引用的对象。

4、本地方法栈中 JNI (Native方法)引用的对象。

#### 引用计数法

记录每个对象被引用的数量，当被引用的数量为0时，则标记为垃圾

缺点：无法处理循环引用的问题

### 垃圾回收

#### 清除(sweep) 

将垃圾对象所占据的内存标记为空闲内存，然后存在一个空闲列表(free list)中。当需要创建对象时，从空闲列表中寻找空闲内存，分配给新创建的对象

#### 整理(compact)

把存活的对象搬到内存的起始位置，然后在连续的空间内顺序分配

#### 复制(copy)

将内存分为两个部分，并分别用 from 和 to 指针来维护。每次只在 from 指向的内存中分配内存，当发生垃圾回收时，将 from 指向区域中存活的对象复制到 to 指向的内存区域，然后将 from 指针和 to 指针互换位置。



年轻代的GC使用“停止-复制（Stop-and-copy）”清理法（将Eden区和一个Survivor中仍然存活的对象拷贝到另一个Survivor中） 

老年代 gc 用的是标记-整理算法，即标记存活的对象，向一端移动，保证内存的完整性，然后将未标记的清掉 

gc 主要的回收的内存区域有堆区和方法区



### 垃圾回收器

#### Minor GC

特点：发生次数多，采用时间短，回收掉大量对象

收集器：serial, Parallel Scavenge, Parallel New.均采用复制算法. Serial是单线程,Parallel New可以看成Serial多线程版本. Parallel Scanvenge和Parallel New类似，但更注重吞吐率，且不能与CMS一起使用

#### Full GC

特点：发生次数少，耗时长

收集器：Serial Old(整理), Parallel Old(整理), CMS(清除). Serial Old是单线程的，Parallel Old可以看成Serial Old的多线程版本.  CMS是并发收集器，除了初始标记和重新标记操作需要Stop the world，其它时间可以与应用程序一起并发执行



Full GC 触发条件

老年代空间不足；

方法区(Metaspace)空间不足；

通过minor GC进入老年代的平均大小大于老年代的可用内存；

老年代被写满；



## 远程调试

### server

- **jdk1.3x或之前**：-Xnoagent -Djava.compiler=NONE -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8788
- **jdk1.4x**： -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8788
- **jdk1.5-8**：-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8788

####  参数解析

- -Xrunjdwp/-agentlib:jdwp:  使用jdwp来运行调试环境
- transport: 通信方式，dt_socket使用的是socket,dt_shmem使用的是共享内存，其中dt_shmem只适用于windows
- server: 是否以作为调试服务端运行jvm
- suspend: 程序启动后先暂停，等待客户端连接
- address: 服务端监听的地址
- onuncaught：当出现uncaught exception 后，是否中断jvm运行

### client

- jdb  -connect com.sun.jdi.SocketAttach:port=5005,hostname=localhost
- stop, step, next, cont, locals, print, threads… , 可在jdk中通过help查看
- 也可以通过eclipse，IDEA 远程调试功能连接

**应用**

```sh
# linux可以在server端直接运行
$ java -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8788

# client在linux调试
$ jdb -connect com.sun.jdi.SocketAttach:port=5005,hostname=localhost

# tomcat在 catalina.sh 开头加上下面一句话即可远程debug
CATALINA_OPTS="-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8788"
```

-client，-server 这两个参数用于设置虚拟机使用何种运行模式，一定要作为第一个参数，client模式启动比较快，但运行时性能和内存管理效率不如server模式，通常用于客户端应用程序。相反，server模式启动比client慢，但可获得更高的运行性能。 在windows上，缺省的虚拟机类型为client模式，如果要使用server模式，就需要在启动虚拟机时加-server参数，以获得更高性能，对服务器端应用，推荐采用server模式，尤其是多个CPU的系统。在Linux，Solaris上缺省采用server模式。  此外，在多cup下，建议用server模式 



JAVA_OPTS 直接设置 jvm 参数， 另一个 CATALINA_OPTS 设置 tomcat 参数

在linux和windows常使用不同方式设置：

Linux服务器：  在catalina.sh的第一行增加：  JAVA_OPTS=  -Xms64m  -Xmx256m  -XX:PermSize=128M  -XX:MaxNewSize=256m  -XX:MaxPermSize=256m 

Windows服务器：  在catalina.bat的第一行增加：  set JAVA_OPTS=-Xms64m -Xmx256m -XX:PermSize=128M -XX:MaxNewSize=256m -XX:MaxPermSize=256m  





**容量(Capacity)**：缓冲区能够容纳的数据元素的最大数量; 位置(Position)：下一个要被读或写的元素的索引; 边界(Limit)：缓冲区的第一个不能被读或写的元素;标记(Mark)：一个备忘位置。** 



**ZipEntry.getSize()方法判断其大小，以试图解决之前的问题。但不幸的是，恶意攻击者可以伪造ZIP文件中用来描述解压条目大小的字段** 



**unmodifiableMap.clear()执行时报异常java.lang.UnsupportedOperationException**



规则7.2 方法抛出的异常，应该与本身的抽象层次相对应**

**规则7.3 在****ﬁ****nally****块中不要使用return、break或continue使****ﬁ****nally****块非正常结束**





Files.exists()



**如果List<String> list = new ArrayList<>();那么删除倒数第2个不会抛出异常，其他都抛出异常。**

**如果是LinkedList，那么最后一个和倒数第2个不会抛出异常不会抛出异常，其他都抛出异常。**

并且删除倒数第二个之后循环结束



List<? super T>（下界） 适合用来存放数据。只能添加T类型或其子类类型；添加存放之后这些类型都会转换为T的任意超类类型；取出元素可以强转为T泛型，也可以直接使用Object接受；

```java
ArrayList<? super Number> superList = new ArrayList<>();

Integer a = 10;
superList.add(a);

Number number = (Number) superList.get(0);
Object object = superList.get(0);
```



List<? extends T>（上界） 适合用来读取数据。 假如使用T类型不同的子类去添加到list中时，各种子类无法相互转换从而导致编译失败，因此不能添加元素，但是可以接收初始化赋值；读取出来的数据必须使用T类型或其父类接受，因为不确定具体的类型；

```java
ArrayList<? extends Number> extendsList = new ArrayList<>();

//extendsList.add(10); // 直接添加会报错

ArrayList<Integer> list = new ArrayList<>();
list.add(10);
extendsList = list; // 虽然不能直接添加元素，但是可以使用这种方式初始化，相当于将一个容器的东西倒入另一个容器，这种情况只能使用Number的子类作为泛型的集合才能给extendsList赋值，但是使用Number的父类做泛型的集合进行赋值就会报错。

// ArrayList<Object> objects = new ArrayList<>();
// objects.add("123");
// extendsList = objects; // Object是Number的父类，编译失败

Number number1 = extendsList.get(0);
Object object2 = extendsList.get(0);

//ArrayList<? extends Number> list1 = new ArrayList<Integer>();
//Integer number2 = list1.get(0); // 这样会报错，因为list1可能指的是List<Double>
```



1. 调用`invalidate()` 方法会使该Session无效，无效只是不能调用`setAttribute`或者`getAttribute`之类的方法了，Session对象还在；
2. 调用过`invalidate()`方法的Session对象如果再执行`setAttribute`或者`getAttribute`方法会抛出`IllegalStateException`；
3. 调用`invalidate()` 方法会将该Session绑定的对象全部解绑，因此如果调用`request.getSession(false)`方法，返回值会是null——即此时request没有绑定任何Session;
4. 如果调用`invalidate()` 方法后执行`request.getSession()`或者`request.getSession(true)`,那么此时会创建一个新的Session给该Request对象绑定；需要特殊说明的是，`getSession()`无参和参数为true的效果是一样的，并且此时如果你再次执行`request.getSession(false)`方法，返回的就不是null了，而是上面新创建的Session对象。

 










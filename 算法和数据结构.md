# 算法和数据结构

## 数据结构

> 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。
>
> 通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。

数据结构包括数据的逻辑结构、数据的存储结构以及数据的运算；

- 逻辑结构有：集合结构、线性结构、树形结构和图状结构。
- 物理结构有：线性存储结构和非线性存储结构，线性存储结构(线性表)有顺序(顺序表)、链式(链表)、索引和散列4种结构；非线性存储结构有树形存储结构、图形存储结构。
  - 顺序使用连续地址空间存储元素
  - 链式中指针指向下一个元素地址
  - 索引使用索引表存放元素地址
  - 散列通过散列算法计算地址

线性表有栈，队列，实现方式可以是顺序表也可以是链表；顺序表有数组；非线性存储结构有树、堆、图。

集合中ArrayList是顺序表，LinkedList是链表；

### 数组

- 数组是静态的，一个数组实例具有固定的大小，一旦创建了就无法改变容量了。而集合是可以动态扩展容量，可以根据需要动态改变大小。

- 数组的存放的类型中`Object[]`可以存放多种类型，其他只能是一种（基本类型/引用类型）；集合存放的类型可以不是一种(不加泛型时添加的类型是Object，取出时转换成自己的类型就行了)，但是添加泛型时只能是一种。

#### 稀疏数组

> 所谓稀疏数组就是数组中大部分的内容值都未被使用（或都为零），在数组中仅有少部分的空间使用。因此造成内存空间的浪费，为了节省内存空间，并且不影响数组中原有的内容值，我们可以采用一种压缩的方式来表示稀疏数组的内容。

假设有一个9*7的数组，其内容如下：

![clipboard (5)](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard%20(5).png)

在此数组中，共有63个空间，但却只使用了5个元素，造成58个元素空间的浪费。

以下我们就使用稀疏数组重新来定义这个数组：

![clipboard (6)](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard%20(6).png)

在稀疏数组中第一部分所记录的是原数组的列数和行数以及元素使用的个数；

第二部分所记录的是原数组中元素的位置和内容；

经过压缩之后，原来需要声明大小为63的数组，而使用压缩后，只需要声明大小为6*3的数组，仅需18个存储空间。

```java
public class TestArray {
    public static void main(String[] args) {
        /*
        Integer[][] arr=new Integer[9][7];
        arr[1][1]=3;
        ...
        */

        Node[] nodes=new Node[6];
        nodes[0]=new Node(9,7,5);
        nodes[1]=new Node(1,1,3);
        nodes[2]=new Node(3,0,1);
        nodes[3]=new Node(3,1,4);
        nodes[4]=new Node(4,2,7);
        nodes[5]=new Node(5,5,5);

        for(int i=0;i<nodes[0].getRow();i++){
            for(int j=0;j<nodes[0].getCol();j++){
                int k;
                for(k=1;k<nodes.length;k++){
                    if(nodes[k].getRow()==i&&nodes[k].getCol()==j){
                        System.out.print(nodes[k].getVal()+"   ");
                        break;
                    }
                }
                if(k==nodes.length){
                    System.out.print("0   ");
                }
            }
            System.out.println("");
        }
    }
}

@Data
@AllArgsConstructor
class Node{
    private int row;
    private int col;
    private int val;
}

输出：
0   0   0   0   0   0   0   
0   3   0   0   0   0   0   
0   0   0   0   0   0   0   
1   4   0   0   0   0   0   
0   0   7   0   0   0   0   
0   0   0   0   0   5   0   
0   0   0   0   0   0   0   
0   0   0   0   0   0   0   
0   0   0   0   0   0   0
```

### 链表

> 链表是一种线性表，在每一个节点里存到下一个节点的指针(Pointer)，

#### 单向链表

> 一个单链表的节点(Node)分为两个部分，第一个部分(data)保存或者显示关于节点的信息，另一个部分存储下一个节点的地址。最后一个节点存储地址的部分指向空值。链表有一个头节点。

输出：[D->C->B->A]

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1652799105762.png)

#### 用单向链表实现栈

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1652970462872.png)

#### 双端链表

多了对尾节点的引用

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1653314848344.png)

#### 用双端链表实现队列

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1653574602259.png)

#### 有序链表

链表中的数据有序，这称为有序链表。在有序链表中，数据是按照关键值有序排列的。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1653314969403.png)

在有序链表中插入和删除某一项最多需要O(N)次，平均需要O(N/2)次，优先级队列可以使用有序链表来实现。



### 抽象数据类型（ADT）

抽象是抽取出事物具有的普遍性本质，是对事物的一个概括，是一种思考问题的方式。

**抽象数据类型（ADT）是指一个数学模型及定义在该模型上的一组操作。**它仅取决于其逻辑特征，而与计算机内部如何表示和实现无关。

比如整型，各个计算机，不管大型机、小型机、PC、平板电脑甚至智能手机，都有“整型”类型，也需要整型运算，那么整型其实就是一个抽象数据类型。 

比如栈，对于使用者只需要知道 pop() 和 push() 方法或其它方法的存在以及如何使用即可，使用者不需要知道我们是使用数组或是链表中那种结构来实现的。

#### 实现具有迭代器的单链表

让链表本身实现迭代功能，代替我们用循环去遍历链表里的所有节点数据

1、定义一个ListInterface<T>接口（相当于一个ADT），指定了单链表中的各种基本操作：

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1653576279645.png)



2、定义ListWithIteratorInterface<T> 接口并 extends ListInterface<T>

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1653576334540.png)

3、定义了一个类LinkListWithIterator<T> 实现了LinkListWithIterator<T>  接口（相当于ADT的实现类），LinkListWithIterator<T> 中定义了一个内部类：IteratorForLinkedList，该内部类 implements Iterator<T>

通过LinkListWithIterator<T> 的对象调用 getIterator() 获得一个迭代器，而该迭代器类又是LinkListWithIterator<T> 的内部类，即可以直接迭代LinkListWithIterator的数据域。**LinkListWithIterator<T> 就表示一个带有迭代器的单链表了。**

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1653576392109.png)











### 栈

<img src="img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211114160624460.png" alt="image-20211114160624460" style="zoom:80%;" />

> **栈**（英语：stack）又称为**堆栈**或**堆叠，**栈作为一种数据结构，是一种**只能在一端进行插入和删除操作的特殊线性表**。先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。

允许进行插入和删除操作的一端称为栈顶(top)，另一端为栈底(bottom)；栈中元素个数为零时称为空栈。插入一般称为进栈（PUSH），删除则称为退栈（POP）。

#### 数组实现栈

```java
public class TestStack {
    public static void main(String[] args) {
        MyStack myStack=new MyStack();
        myStack.push(1);
        myStack.push(2);
        myStack.push(3);
        myStack.push(4);
        myStack.push(5);
        myStack.push(6);
        myStack.push(7);
        myStack.push(8);
        myStack.push(9);
        myStack.push(10);
        myStack.push(11);

        while(!myStack.isEmpty()){
            System.out.println(myStack.pop());
        }
    }
}

class MyStack{
    private Object[] data;  //栈内部封装的数组，用来保存压入栈的数据元素
    private int maxSize;    //栈的最大长度
    private int top;        //变量始终指向栈顶第一个元素，栈是空栈，默认值是-1

    //初始化栈
    public MyStack(){
        data=new Object[10];
        this.maxSize=10;
        top=-1;
    }

    //压栈
    public void push(Object o){
        if(top==maxSize-1){
            if((maxSize<<1)>Integer.MAX_VALUE){
                maxSize=Integer.MAX_VALUE;
            }else {
                maxSize=maxSize<<1;
            }
            //扩容
            data= Arrays.copyOf(data,maxSize);
        }
        data[++top]=o;
    }

    //获取栈顶元素值
    public Object peek(){
        if(top==-1){
            throw new EmptyStackException();
        }
        return data[top];
    }

    //实现出栈
    public Object pop(){
        Object obj=peek();
        data[top--]=null;
        return obj;
    }

    //判断是不是空栈
    public boolean isEmpty(){
        return (top==-1);
    }

    //判断是不是满栈
    public boolean isFull(){
        return (top==maxSize-1);
    }
}
```

#### 利用栈判断分隔符是否匹配

> 写过xml标签或者html标签的，**我们都知道<必须和最近的>进行匹配，[ 也必须和最近的 ] 进行匹配。**
>
> 比如：<abc[123]abc>这是符号相匹配的，如果是 <abc[123>abc] 那就是不匹配的。
>
> 对于 12<a[b{c}]>，我们分析在栈中的数据：遇到匹配正确的就消除

```java
public static void main(String[] args) {
    String str="12<a[b{c}]>";
    char[] chars = str.toCharArray();
    Stack<Character> stack=new Stack<>();

    char ch;
    boolean flag=true;
    for(char c:chars){
        if(c=='<'||c=='['||c=='{'){
            stack.push(c);
        }
        if(c=='>'||c==']'||c=='}'){
            if(!stack.isEmpty()){
                char pop = stack.pop();
                if(!(c=='>'&&pop=='<'||c==']'&&pop=='['||c=='}'&&pop=='{')){
                    System.out.println("左符号"+pop+"和右符号"+c+"不匹配");
                    flag=false;
                }
            }else {
                //左边符号多余
                System.out.println("左符号"+c+"无匹配");
                flag=false;
                break;
            }
        }
    }

    //右边符号多余
    if(flag&&!stack.isEmpty()){
        flag=false;
        while(!stack.isEmpty()){
            System.out.println("右符号"+stack.pop()+"无匹配");
        }
    }

    if(flag){
        System.out.println("匹配成功");
    }
}
```

### 队列

#### 常用队列

##### Queue

根接口

```java
public interface Queue<E> extends Collection<E> {
    boolean add(E e);
	E remove();
    
    boolean offer(E e);
    E poll();
    
    E peek();
}
```

##### ArrayDeque

数组实现的双端队列

![image-20220215192353286](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220215192353286.png)

##### LinkedList

链表实现的双端队列

![image-20220215192423210](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220215192423210.png)

##### ArrayBlockingQueue

数组实现的优先单向队列

![image-20220215192453673](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220215192453673.png)

##### LinkedBlockingDeque

链表实现的优先双端队列

![image-20220215192516089](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220215192516089.png)

##### 队列应用

```java
public static void main(String[] args) {
    Deque<String> list = new LinkedList<>();
    list.addFirst("1");
    list.addLast("2");
    list.removeFirst();
    list.removeLast();

    list.offerFirst("3");
    list.offerLast("4");
    list.pollFirst();
    list.pollLast();

    //push 和 pop都在头部操作
    list.push("5");
    list.pop();

    list.add("6");//尾部添加
    list.remove();//头部删除

    list.offer("7");//尾部添加
    list.poll();//头部删除
    
    //ArrayDeque使用和LinkedList完全相同，但是常当作栈来使用
    Deque<String> arrayDeque=new ArrayDeque<>();
    arrayDeque.push("1");
    arrayDeque.pop();
}
```



#### 队列原理

> 队列（queue）是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。
>

队列分为：

- 单向队列（Queue）：只能在一端插入数据，另一端删除数据。
- 双向队列（Deque）：每一端都可以进行插入数据和删除数据操作。
- 优先级队列（Priority Queue），优先级队列是比栈和队列更专用的数据结构，在优先级队列中，数据项按照关键字进行排序，关键字最小（或者最大）的数据项往往在队列的最前面，而数据项在插入的时候都会插入到合适的位置以确保队列的有序。

##### 单向循环队列

```java
public class TestQueue {
    public static void main(String[] args) {
        MyQueue myQueue=new MyQueue(3);
        myQueue.insert(1);
        myQueue.insert(2);
        myQueue.insert(3);

        System.out.println(myQueue.peekFront());
        myQueue.remove();
        System.out.println(myQueue.peekFront());

        myQueue.insert(4);
        myQueue.insert(5);
    }
}

class MyQueue{
    private Object[] queArray;
    //队列总大小
    private int maxSize;
    //前端
    private int front;
    //尾端
    private int rear;
    //队列中元素的实际数目
    private int nItems;

    public MyQueue(int size){
        maxSize=size;
        queArray=new Object[maxSize];
        //虽然初始状态不同，始终指向第一个和最后一个元素
        front=0;
        rear=-1;
        nItems=0;
    }

    public void insert(int value){
        if(isFull()){
            System.out.println("队列已满");
        }else {
            //队尾已满，循环回来指向队列的第一个元素
            if(rear==maxSize-1){
                rear=-1;
            }
            queArray[++rear]=value;
            nItems++;
        }
    }

    public Object remove(){
        Object removeValue=null;
        if(!isEmpty()){
            removeValue=queArray[front];
            queArray[front++]=null;
            if(front==maxSize){
                front=0;
            }
            nItems--;
        }
        return removeValue;
    }

    //查看队头数据
    public Object peekFront(){
        return queArray[front];
    }

    public boolean isFull(){
        return (nItems==maxSize);
    }

    public boolean isEmpty(){
        return (nItems==0);
    }

    public int getSize(){
        return nItems;
    }
}
```

##### 双端队列

> 双端队列就是一个两端都是结尾或者开头的队列， 队列的每一端都可以进行插入数据项和移除数据项，这些方法可以叫做：`addFirst()、addLast()、removeFirst()、removeLast()`

- 双端队列内部维护着"头部下标"、"尾部下标"。**头部下标**指向的是**队列中第一位元素**，**尾部下标**指向的是**下一个尾部元素插入的位置**。

- 当头部元素入队时，头部下标向左移动一位；头部元素出队时，头部下标向右移动一位。

  当尾部元素入队时，尾部下标向右移动一位；尾部元素出队时，尾部下标向左移动一位。

- 下标从数组第0位时，向左移动一位，会跳转到数组的最后一位。下标从数组最后一位时，向右移动一位，会跳转到数组的第0位。

  下标越界时的跳转操作，在细节上是通过下标取模实现的。

**取模计算：**

在jdk中基于数组的双端队列实现中，强制保持内部数组容量为2的平方(初始化时容量为2^4^=16，每次自动扩容容量 * 2)，因此其取模运算可以通过按位与(&)运算来加快计算速度。

```java
System.out.println((15 + 1) & (16 - 1));
System.out.println((0 - 1) & (16 - 1));

System.out.println((15 + 1) %16);
System.out.println((0 + 15) %16);

输出：
0
15
0
15
```

```java
//ArrayDeque
public void addLast(E e) {
    if (e == null) throw new NullPointerException();
    elements[tail] = e;
    if ( (tail = (tail + 1) & (elements.length - 1)) == head ) doubleCapacity();
}

public void addFirst(E e) {
    if (e == null) throw new NullPointerException();
    elements[head = (head - 1) & (elements.length - 1)] = e;
    if (head == tail) doubleCapacity();
}

public E pollFirst() {
    int h = head;
    E result = (E) elements[h];
    // Element is null if deque empty
    if (result == null) return null;
    elements[h] = null;     // Must null out slot
    head = (h + 1) & (elements.length - 1);
    return result;
}

public E pollLast() {
    int t = (tail - 1) & (elements.length - 1);
    E result = (E) elements[t];
    if (result == null) return null;
    elements[t] = null;
    tail = t;
    return result;
}
```



**扩容操作：**

只有在队列为空时，头部下标才会和尾部下标重合；而当插入新的入队元素之后，使得头部下标等于尾部下标时，说明内部数组的容量已经达到了极限，需要进行扩容才能容纳更多的元素。

1. 将"头部下标"直至"当前内部数组尾部"的元素按照顺序整体复制到新扩容数组的起始位置(**红色背景的元素**)

2. 将"当前内部数组头部"直至"尾部下标"的元素按照顺序整体复制到新扩容数组中(位于第一步操作复制的数据区间之后)(**蓝色背景的元素**)

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard.png)

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1644927033455.png)

```java
//ArrayDeque
private void doubleCapacity() {
    assert head == tail;
    int p = head;
    int n = elements.length;
    int r = n - p; // number of elements to the right of p
    int newCapacity = n << 1;
    if (newCapacity < 0) throw new IllegalStateException("Sorry, deque too big");
    Object[] a = new Object[newCapacity];
    System.arraycopy(elements, p, a, 0, r);
    System.arraycopy(elements, 0, a, r, p);
    elements = a;
    head = 0;
    tail = n;
}
```

##### 优先级队列

在优先级队列中，数据项按照关键字进行排序，关键字最小（或者最大）的数据项往往在队列的最前面，而数据项在插入的时候都会插入到合适的位置以确保队列的有序。对于优先权相同的元素，可按先进先出次序处理或按任意优先权进行。

**数组实现优先级队列，声明为int类型的数组，关键字是数组里面的元素，在插入的时候按照从大到小的顺序排列，也就是越小的元素优先级越高。**

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1645184663792.png)

### 集合

#### ArrayList

<img src="img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211114160523563.png" alt="image-20211114160523563" style="zoom:80%;" />

```java
//将arr1数组里从索引为2的元素开始, 复制到数组arr2里的索引为5的位置, 复制的元素个数为10个.
System.arrayCopy( arr1, 2, arr2, 5, 10);

//扩容1.5倍
newSize=arr.length+(arr.length>>1);
arr=Arrays.copyOf(arr,newSize);
```

```java
class MyArrayList{
    private Object[] arr;
    private int nElems;//数组的真实长度

    //初始化
    public MyArrayList(){
        //其中ArrayList初始容量也是10
        arr=new Object[10];
        nElems=0;
    }

    //添加
    public void add(Object o){
        if(nElems==arr.length){
            arr=Arrays.copyOf(arr,arr.length+(arr.length>>1));
        }
        arr[nElems++]=o;
    }

    //删除
    public void delete(Object o){
        int i=0;
        //找出该元素在数组中的下标i
        //if(找到了)
        System.arraycopy(arr,i+1,arr,i,nElems-1-i);
        arr[nElems--]=0;
    }
}
```

## 算术表达式

**前缀表达式，中缀表达式，后缀表达式：这三种表达式其实就是算术表达式的三种写法，以 3+4-5为例**

- 前缀表达式：操作符在操作数的前面，是一种没有括号的算术表达式，例如，- 1 + 2 3，它等价于1-(2+3)
- 中缀表达式：操作符在操作数的中间，这也是人类最容易识别的算术表达式 3+4-5
- 后缀表达式：操作符在操作数的后面，是一种没有括号的算术表达式，比如 3 4+5-，等价于(3+4)-5

### 后缀表达式

后缀表达式，指的是不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则）。

*从左到右扫描，遇到运算符取出运算符前两位操作数计算，将结果放入表达式，循环计算*

**如何将中缀表达式转换为后缀表达式**

对于这个问题，转换的规则如下：

1. 初始化两个栈：运算符栈s1，中间结果栈s2

2. 从左到右扫描表达式

3. 遇到操作数压入s2

4. 遇到运算符，比较其与s1栈顶运算符的优先级

   a、如果s1栈不是空的，并且栈顶元素不是“（ ”  并且优先级比栈顶元素相等或还小就弹出s1栈顶的元素，压入s2栈

   b、否则，就直接压入栈s1，循环判断a

5. 遇到括号

   a、遇到左括号（  ，直接压入s1栈

   b、遇到有括号  ），依次弹出s1栈顶的元素，压入s2栈，知道遇到左括号为止，然后将这对括号丢掉

6. 重复2-5，扫描完所有表达式

7. 将s1中剩余的运算符压入s2栈

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1646350408170.png)

















































## 算法

> 按照某种逻辑关系组织起来的一批数据，按一定的方式把它存放在计算机的内存里，在这个基础上为了实现某个功能（比如查找某个元素，删除某个元素，给所有元素排序等等）而进行的一些列操作，我们把这一些列的操作步骤描述出来就是算法。

**时间复杂度和空间复杂度是衡量算法优劣的重要指标：**

- 时间复杂度：是用程序执行的次数来衡量，不是程序执行的时间。

- 空间复杂度：用程序执行所需要的最大内存。

其中基本操作执行次数的函数 T(n)，若存在函数 f(n)，使得当n趋近于无穷大时，T(n)/ f(n)的极限值为不等于零的常数，则称 f(n)是T(n)的同数量级函数。

记作 T(n)= O(f(n))，称O(f(n)) 为算法的**渐进时间复杂度**，简称**时间复杂度**。渐进时间复杂度用大写O来表示，所以也被称为**大O表达式**。

**大O表达式                                     算法的好坏**

O(1) 												最好					大O常数阶

O(logn) 										  比较好				大O对数阶

O(n)                                                良好					大O线性阶

O(n^2)                                            不好					大O平方阶

O(n^3)                                            很不好				

O(2^n)                                            很很不好

O(n!)                                               最不好



**比如：**

> 给小灰一条长16寸的面包，小灰每5天吃掉面包剩余长度的一半，第一次吃掉8寸，第二次吃掉4寸，第三次吃掉2寸......那么小灰把面包吃得只剩下1寸，需要多少天呢？
>
> 这个问题翻译一下，就是数字16不断地除以2，除几次以后的结果等于1？这里要涉及到数学当中的对数，以2位底，16的对数，可以简写为lg16。
>
> 因此，把面包吃得只剩下1寸，需要 5 X lg16 = 5 X 4 = 20 天。
>
> 如果面包的长度是 N 寸呢？
>
> 需要 5 X lgN = 5lgN天，记作 T(n) = 5lgN

```java
void eat2(int n){
   for(int i=1; i<n; i*=2){     
       System.out.println("等待一天");
       System.out.println("等待一天");
       System.out.println("等待一天");
       System.out.println("等待一天");
       System.out.println("吃一半面包");
   }
}
```

程序的设计中要不就是时间换空间，要不就是用空间去换时间。并且时间和空间是可以进行相互转化的；我们在程序当中，请求分页，请求分段，都属于用时间去换空间。在项目当中使用各种缓存技术，都属于利用空间去换时间。

### 查找算法

> 有序数组的二分查找

```java
public int find(Integer[] array,int searchKey){
    int lowerBound=0;
    int upperBound=array.length-1;
    int curIn;

    while(true){
        curIn=(lowerBound+upperBound)/2;
        if(array[curIn]== searchKey){
            return curIn;
        }else if(lowerBound>upperBound){
            return array.length;
        }else{
            if(array[curIn]<searchKey){
                lowerBound=curIn+1;
            }else {
                upperBound=curIn-1;
            }
        }
    }
}
```



### 排序算法

#### 冒泡排序

```java
public static void main(String[] args) {
    Integer[] is=new Integer[]{2,3,1};
    bubSort(is);
    System.out.println(Arrays.asList(is));
}

public static void bubSort(Integer[] array){
    int outer;	//冒泡出来的元素放置的下标位置，从后向前 
    int inner;
    for(outer=array.length-1;outer>=1;outer--){
        for(inner=0;inner<outer;inner++){
            if(array[inner]>array[inner+1]){	//前面的元素比后面大，交换位置
                int temp=array[inner];
                array[inner]=array[inner+1];
                array[inner+1]=temp;
            }
        }
    }
}
```

#### 选择排序

```java
public static void selectSort(Integer[] array){
    int outer;	//选择出来的元素放置的下标位置，从前向后
    int inner;
    int min;

    for(outer=0;outer<array.length-1;outer++){
        min=outer;	//每次循环初始化min指向outer的位置，剩下的元素中的第一个
        for(inner=outer+1;inner<=array.length-1;inner++){
            if(array[inner]<array[min]){
                min=inner;
            }
        }//每次循环完成后，min指向的元素才是真正最小元素
        
        if(min!=outer){
            int temp=array[min];
            array[min]=array[outer];
            array[outer]=temp;
        }
    }
}
```



#### 插入排序

```java
public static void insertSort(Integer[] array){
    int outer;	//指向需要插入的元素
    int inner;	//指向outer之前元素
    int temp;

    //数列中每一个数和它前面的数据比较，如果inner指向的数较大，数往后移位，inner向前遍历,直到inner指向的数较小，在这之后插入这个数
    for(outer=1;outer<=array.length-1;outer++){
        inner=outer-1;
        temp=array[outer];
        while(inner>=0&&array[inner]>temp){	//从小到大
            array[inner+1]=array[inner];
            inner--;
        }
        array[inner+1]=temp;
    }
}
```



```java
public static void main(String[] args) {
    int[] array=new int[]{1,67,9,32,54,7,12};
    sort(array);
    for(int i:array){
        System.out.println(i);
    }
}

//数列中每一个数和它前面的所有数据比较，如果前面的数较大，往后移位，直到前面的数较小，在这之后插入这个数
public static void sort(int[] array){
    int preIndex;
    int current;
    for(int i=1;i<=array.length-1;i++){
        preIndex=i-1;
        current=array[i];
        while(preIndex>=0&&array[preIndex]>current){
            array[preIndex+1]=array[preIndex];
            preIndex--;
        }
        array[preIndex+1]=current;
    }
}
```

#### 希尔排序

也是一种插入排序

将数组按照增量分组，对每组使用直接插入排序算法排序，初始增量gap=length/2，然后缩小增量gap=gap/2，直到增量为1将整个数组分为一组

如100个数据，先分为100/2=50组，每组2个值，每组分别排序

​						  再分为50/2=25组，每组4个值

​						  再分为25/2=12组，每组9或8个值

​						  ...

​						  最后分为2/2=1组，100为一组整体排序

```java
public static void main(String[] args) {
    int[] array=new int[]{1,67,9,32,54,7,12};
    sort(array);
    for(int i:array){
        System.out.println(i);
    }
}

public static void sort(int[] array){
    int gap=array.length/2;
    while(gap>0){
        int preIndex;
        int current;
        for(int i=gap;i<=array.length-1;i++){
            preIndex=i-gap;
            current=array[i];
            while(preIndex>=0&&array[preIndex]>current){
                array[preIndex+gap]=array[preIndex];
                preIndex-=gap;
            }
            array[preIndex+gap]=current;
        }
        gap/=2;
    }
}
```



#### 快速排序

对于一个数列进行排序，比基准小的放在基准前，比基准大的放在基准后，然后再将小于基准的子序列和大于基准的子序列递归排序

```java
public static void main(String[] args) {
    int[] array=new int[]{1,67,9,32,54,7,12};
    quickSort(array, 0, array.length - 1);
    for(int i:array){
        System.out.println(i);
    }
}

public static void quickSort(int[] array,int start,int end){
    if(start>=end){
        return;
    }else{
        int patition = patition(array, start, end);
        if(patition>start){
            quickSort(array,start,patition-1);
        }
        if(patition<end){
            quickSort(array,patition+1,end);
        }
    }
}

//选开始值为基准，从前开始找到大于基准的坐标，从后开始找到小于基准的坐标，将两个值交换，然后在两个坐标之间继续循环，直到从后开始的坐标小于从前开始的坐标
public static int patition(int[] array,int start,int end){
    int i=start;
    int j=end+1;
    int pivot=array[start];		//pivot为基准值
    while(true){
        while(i<end&&array[++i]<pivot){}	//取大于基准的坐标
        while(j>start&&array[--j]>pivot){}	//取小于基准的坐标
        if(i>=j){
            break;
        }else{
            swap(array,i,j);
        }
    }
    swap(array,j,start);
    return j;
}

public static int[] swap(int[] array,int i,int j){
    int temp=array[i];
    array[i]=array[j];
    array[j]=temp;
    return array;
}
```

   

#### 归并排序

归并算法的中心是归并两个已经有序的数组。归并两个有序数组A和B，就生成了第三个有序数组C。数组C包含数组A和B的所有数据项。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1648339685703.png)

### 递归

#### 定义

递归，就是在运行的过程中调用自己。

一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解

递归必须要有三个要素：

- 边界条件
- 递归前进段
- 递归返回段

当边界条件不满足时，递归前进；当边界条件满足时，递归返回。

一个递归方法每次都是用不同的参数值反复调用自己，当某种参数值使得递归的方法返回，而不再调用自身，这种情况称为边界值，也叫基值。当递归方法返回时，递归过程通过逐渐完成各层方法实例的未执行部分，而从最内层返回到最外层的原始调用处。

#### 求一个数的阶乘：n!

> n! = n\*(n-1)\*(n-2)\*......1
>
> 规定：
>
> 0！=1
>
> 1！=1
>
> 负数没有阶乘

n! = n\*(n-1)！

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1648250795099.png)



#### 计算数字三角形的路径

> 7              
>
> 3 8           
>
> 8 1 0        
>
> 2 7 4 4      
>
> 4 5 2 6 5
>
> 在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往下或右下走。只需要求出这个最大和即可，不必给出具体路径。 
>
> 三角形的行数大于1小于等于100，数字为 0 - 99

**输入格式：** 

5 //三角形行数。下面是三角形 

7 

3 8 

8 1 0 

2 7 4 4 

4 5 2 6 5

**解题思路：**

用二维数组存放数字三角形

`D[r][j]` //表示第i行第j个元素的数值；

`maxSum(i,j)` //表示从根部到第i行最大路径的，所有数值的最大和；

用递归的思想，在 `D(i,j)` 位置，下一个能走的位置为 `D(i+1,j)` 和 `D(i+1,j+1)`，进行递归

`MaxSum(i,j)=max(MaxSum(i+1,j),MaxSum(i+1,j+1))+D[i][j];`

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1648250865053.png)



#### 递归的二分查找

注意：二分查找的数组一定是有序的！！！

在有序数组array[]中，不断将数组的中间值（mid）和被查找的值比较，如果被查找的值等于array[mid],就返回下标mid; 否则，就将查找范围缩小一半。如果被查找的值小于array[mid], 就继续在左半边查找;如果被查找的值大于array[mid], 就继续在右半边查找。 直到查找到该值或者查找范围为空时， 查找结束。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1648251909165.png)

**递归的二分查找和非递归的二分查找效率都为O(logN)**



#### 汉诺塔问题

> 汉诺塔问题是由很多放置在三个塔座上的盘子组成的一个古老的难题。如下图所示，所有盘子的直径是不同的，并且盘子中央都有一个洞使得它们刚好可以放在塔座上。所有的盘子刚开始都放置在A 塔座上。这个难题的目标是将所有的盘子都从塔座A移动到塔座C上，每次只可以移动一个盘子，并且任何一个盘子都不可以放置在比自己小的盘子之上。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1648337733772.png)



无论有多少个盘子，我们都将其看做只有两个盘子。假设有 N 个盘子在塔座A上，我们将其看为两个盘子，其中(N-1)~1个盘子看成是一个盘子，最下面第N个盘子看成是一个盘子，那么解决办法为：

　　①、先将A塔座的第(N-1)~1个盘子看成是一个盘子，放到中介塔座B上，然后将第N个盘子放到目标塔座C上。

　　②、然后A塔座为空，看成是中介塔座，B塔座这时候有N-1个盘子，将第(N-2)~1个盘子看成是一个盘子，放到中介塔座A上，然后将B塔座的第(N-1)号盘子放到目标塔座C上。

　　③、这时候A塔座上有(N-2)个盘子，B塔座为空，又将B塔座视为中介塔座，重复①，②步骤，直到所有盘子都放到目标塔座C上结束。 实质上这种递归我们又叫：双递归函数

第一次递归将 n-1 个盘子从原塔座放到中间塔座上，然后将第 n 个盘子从原塔座放到目标塔座上

第二次递归将 n-1 个盘子从中间塔座放到目标塔座上

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1648337800822.png)

#### 递归实现归并排序

归并排序的思想是把一个数组分成两半，排序每一半，然后将数组的两半归并成为一个有序的数组。如何来为每一部分排序呢？用递归：

　　把每一半都分为四分之一，对每个四分之一进行排序，然后把它们归并成一个有序的一半。类似的，如何给每个四分之一数组排序呢？把每个四分之一分成八分之一，对每个八分之一进行排序，以此类推，反复的分割数组，直到得到的子数组是一个数据项，那这就是这个递归算法的边界值，也就是假定一个数据项的元素是有序的。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1649288565696.png)



![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1649288602249.png)



#### 消除递归

把递归转变成非递归算法

**题目： 求1+2+3+4+....+n的值：**

递归来分析这个问题：**1+2+3+4+....+n=n+(n-1+....+1)**

递归和栈有着紧密的联系，而且大多数编译器都是用栈来实现递归的，这里我们就模拟一下底层编译器的处理方法来转换递归算法。

**递归：**

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1649288677310.png)

**非递归：**

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1649288715978.png)

#### 求一个数的乘方

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1649288812543.png)

求x的y次方的值，当y是偶数的时候，最后能转换成两个数相乘，当时当y是奇数的时候，最后我们必须要在返回值后面额外的乘以一个x。

x^y= (x^2)^(y/2)，定义a=x^2,b=y/2, 则得到形如： x^y= a^b;

具体算法：

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1649288849057.png)

#### 背包问题

在最简单的形式中，包括试图将不同重量的数据项放到背包中，以使得背包最后达到指定的总重量。

假设想要让背包精确地承重20磅，并且有 5 个可以放入的数据项，它们的重量分别是 11 磅，8 磅，7 磅，6 磅，5 磅。



算法的关键点：

1、递归的边界：

 选择的数据项的总和符合目标重量——找到

 试验了所有的组合没有符合目标重量——没找到

2、怎么递归：

从选择的第一个数据项开始，剩余的数据项的和必须符合背包的目标重量减去第一个数据项的重量——递归

如果没有合适的组合，放弃第一个数据项，并且从第二个数据项开始再重复一遍整个过程——递归

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1649632358565.png)







#### 组合问题

> 有5个登山队员，名称为 A,B,C,D和E。想要从这五个队员中选择三个队员去登峰，这时候如何列出所有的队员组合。（不考虑顺序）

　　还是以递归的思想来解决：首先这五个人的组合选择三个人分成两个部分，第一部分包含A队员，第二部分不包含A队员。假设把从 5 个人中选出 3 个人的组合简写为（5,3），规定 n 是这群人的大小，并且 k 是组队的大小。那么根据组合公式可以有：

　　(n,k) = (n-1,k-1) + (n-1,k)



对于从 5 个人中选择 3 个人，有：

　　(5,3) = (4,2)+(4,3)

　　(4,2)表示已经有A队员了，然后从剩下的4个队员中选择2个队员，(4,3)表示从5个人中剔除A队员，从剩下的4个队员中选择3个队员，这两种情况相加就是从5个队员中选择3个队员。

　　现在已经把一个大问题转换为两个小问题了。从4个人的人群中做两次选择（一次选择2个，一次选择3个），而不是从5个人的人群中选择3个。

　　从4个人的人群中选择2个人，又可以表示为：(4,2) = (3,1) + (3,2)，以此类推，很容易想到递归的思想。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1649634369445.png)





























### 分治算法

当我们求解某些问题时，由于这些问题要处理的数据相当多，或求解过程相当复杂，使得直接求解花费时间会相当长，或者根本无法直接求出。对于这类问题，我们往往先把它分解成几个子问题，找到求出这几个子问题的解法后，再找到合适的方法，把它们组合成求整个问题的解法。这就是分治策略的基本思想。

递归的二分查找法就是一个分治算法的典型例子，在这个方法中含有两个对自身的递归调用，分别对应于问题的两个部分。二分查找中，将查找范围分成比查找值大的一部分和比查找值小的一部分，每次递归调用只会有一个部分执行。
















## NIO

NIO（Non-blocking I/O，在Java领域，也称为New I/O）：一种同步非阻塞的I/O模型

Buffer（缓冲区）、Channel（通道）、Selector（选择器） 

client-->Buffer-->Channel<-->Channel-->Buffer-->server

### Buffer

Buffer：缓冲区本质为一块可读写数据的内存，Java中包装为Buffer对象，并提供了一组操作方法

Java NIO不同于IO的一点：NIO面向缓冲区，而IO面向流

- 读中，limit和capacity的含义相同；写中，capacity仍然代表这块缓冲区的大小，limit代表写的范围。 
- 标记（mark）一个备忘位置，调用mark()方法的话，mark值将存储当前position的值，等下次调用reset()方法时，会设定position的值为之前的标记值； 
- (capacity、limit、position、mark) 四个属性值之间的关系：0 <= mark <= position <= limit <= capacity

### Channel 

- 双向异步，可读可写
- 通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入 

### Selector

Selector：用于侦听多个通道是否已做好读写准备，配合非阻塞IO实现单个线程管理多个通道。



## 类加载

### 类加载时机

https://blog.csdn.net/weixin_39983051/article/details/111361114

### 外部和内部类

1. 外部类初次加载，会初始化静态变量、静态代码块、静态方法，但不会加载内部类和静态内部类。
2. 实例化外部类，调用外部类的静态方法、静态变量，则外部类必须先进行加载，但只加载一次。
3. 直接调用静态内部类时，外部类不会加载。

## 六大设计原则

### SOLID原则

面向对象设计五个基本原则 ：

- 单一功能原则（SRP）：表明一个类有且只有一个职责。

- 开闭原则（OCP）：一个类应该对扩展开放，对修改关闭。

- 里氏替换原则（LSP）：派生的子类应该是可替换基类的，也就是说将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立 。通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能 ，子类必须拥有父类的属性和方法。

- 接口分离原则（ISP）：表明类不应该被迫依赖他们不使用的方法，也就是说一个接口应该拥有尽可能少的行为，它是精简的，也是单一的。

- 依赖反转原则（DIP）：表明高层模块不应该依赖低层模块，他们都应该依赖抽象类或者接口。这意味着不应该在高层模块中使用具体的低层模块。

  ```java
  class Program {
      public void work() {
  
      }
  }
  
  class Engineer {
      Program program;
  
      public void setProgram(Program p) {
          program = p;
      }
  
      public void manage() {
          program.work();
      }
  }
  //这里我们的类Engineer就是上层类，底层的类就是Program。
  //这时引入新的类SuperProgram 会对Engineer类造成影响，必须修改Engineer类 
  ```

  ```java
  //通过IProgram接口添加抽象层
  interface IProgram {
      public void work();
  }
  
  class Program implements IProgram {
      public void work() {}
  }
  
  class SuperProgram implements IProgram {
      public void work() {}
  }
  
  class Engineer {
      IProgram program;
  
      public void setProgram(IProgram p) {
          program = p;
      }
  
      public void manage() {
          program.work();
      }
  }
  ```

### 迪米特原则

是指一个对象应该对其他对象保持最少的了解，又叫最少知道原则，尽量降低类与类之间的耦合度。 



## JVM

### 栈内存

#### 虚拟机栈

- 虚拟机栈线程私有，每个线程都有自己独立的虚拟机栈
- 虚拟机栈是用于描述java方法执行的内存模型。 每个java方法在执行时，会创建一个“栈帧”，栈帧的结构分为“局部变量表、操作数栈、动态链接、方法出口”几个部分
- 通常说的“栈内存”，确切的说，指的是虚拟机栈的栈帧中的局部变量表，因为这里存放了一个方法的所有局部变量。 

##### 异常

- 虚拟机栈的StackOverflowError

  若单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError（栈溢出错误）

  JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽。比如一个无结束条件的递归函数调用。

- 虚拟机栈的OutOfMemoryError

  不同于StackOverflowError，OutOfMemoryError指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。

  JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存”。当虚拟机栈能够使用最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常。

#### 本地方法栈

本地方法栈的功能和特点类似于虚拟机栈，均具有线程隔离的特点以及都能抛出StackOverflowError和OutOfMemoryError异常。不同的是，本地方法栈服务的对象是JVM执行的native方法，而虚拟机栈服务的是JVM执行的java方法。 



### 直接内存

NIO的Buffer提供了一个可以不经过JVM内存直接访问**系统物理内存**的类——DirectBuffer。 

DirectBuffer类继承自ByteBuffer，但和普通的ByteBuffer不同，普通的ByteBuffer仍在JVM堆上分配内存，其最大内存受到最大堆内存的限制；

而DirectBuffer直接分配在物理内存中，并不占用堆空间，其可申请的最大内存受操作系统限制。

直接内存的单次分配和读写操作比普通Buffer快，但它的创建、销毁比普通Buffer慢。因此直接内存使用于需要大内存空间且频繁访问的场合，不适用于频繁申请释放内存的场合。

比如 Java8 使用元空间：元空间主要存储加载的类信息，这些数据只会在程序启动时直接分配足够的直接内存，可以减少程序的启动时间，运行期一般不会频繁加载新的类，故运行期不需要频繁分配内存。堆内存主要存放的是运行时对象，需要频繁的创建与销毁。 

### 堆内存

Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。对象的堆内存由称为垃圾回收器的自动内存管理系统回收。 



### GC root

**GC root原理**：通过对枚举GC root对象做引用可达性分析，即从GC root对象开始，向下搜索，形成的路径称之为引用链（从GC Roots开始遍历对象，没有被遍历到的对象为垃圾 ）。如果一个对象到GC roots对象没有任何引用，没有形成引用链，那么该对象等待GC回收。 

**Java中可以作为GC Roots的对象**

1、虚拟机栈（javaStack）中引用的对象，也就是方法栈使用到的参数、局部变量、临时变量等。

2、方法区中的类静态属性引用的对象。

3、方法区中常量引用的对象。

4、本地方法栈中 JNI (Native方法)引用的对象。



### 引用类型

- 强引用：发生 gc 的时候不会被回收。
- 软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。
- 弱引用：有用但不是必须的对象，在下一次GC时会被回收。
- 虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。

#### 详解

##### strong reference

Object c = new Car(); //只要c还指向car object, car object就不会被回收，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

##### soft reference 

当系统内存不足时， soft reference指向的object才会被回收。

有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。 

##### weak reference

描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。 

`WeakReference<Car> weakCar = new WeakReference<Car>(car);`

当一个对象仅仅被 weak reference 指向, 而没有任何其他 strong reference 指向的时候, 如果GC运行, 那么这个对象就会被回收。当要获得 weak reference 引用的 object 时, 首先需要判断它是否已经被回收     :`if(weakCar.get()!=null)`。

另外， java提供了一个ReferenceQueue来保存这些所指向的对象已经被回收的reference。

##### PhantomReference

无用对象，这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。 


















# 设计模式

## 分类

总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

## 单例模式

单例模式确保某个类只有一个实例，而且自行实例化并向其他所有对象提供这个实例。

### 饿汉式单例:

```java
//在类加载的时候创建实例对象。不会出现线程安全，JVM在类加载时保证只会有一个线程去执行类的初始化方法
public class Singleton(){
    private Singleton(){}
    private static Singleton single=new Singleton();
    public static Singleton getInstance(){
    	return single;
    }
}
```

### 懒汉式单例:

```java
//在第一次调用时实例化自己，会出现线程安全
public class Singleton{
    private Singleton(){}
    private static Singleton single=null;
    public static Singleton getInstance(){
        if(single==null){
            single=new Singleton();
        }
        return single;
    }
}
```

### 双重锁模式:

```java
//双重检查模式，进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避免多线程问题。
public class Singleton {  
    
	/*
	new 不是一个原子操作 ,指令可能会重排序
	1、重排序：先分配内存，让 instance 指向这块内存 ，然后执行对象的初始化 ，这种会有问题，在初始化执行没有完成 ，这时候 cpu 切换时间片 ，
    导致其他线程执行第一个判断不为空，直接返回 ，但是对象还没有初始化完
    2、正常排序：先分配内存，然后对象初始化，让 instance 指向这个内存
    总结 ： valotile 修饰变量，指令不会重排序 ，也就是上面的步骤2
	*/
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getInstance () {
        if (singleton == null) {  
            
            //将判断为空和new操作原子化，同时synchronized也保证了内存可见
            synchronized (Singleton.class) {  
                if (singleton == null) {  
                	singleton = new Singleton();
                }  
            } 
            
        }  
        return singleton;  
    }  
}
```

#### 单例模式结合HASHMAP实现缓存

```java
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getInstance () {  
        if (singleton == null) {  
            synchronized (Singleton.class) {  
                if (singleton == null) {  
                	singleton = new Singleton();
                }  
            } 
        }  
        return singleton;  
    }  
    
    private Map<String, Object> cacheDataMap = new ConcurrentHashMap<String, Object>();
    public Map<String, Portalbas> getCacheDataMap() {
		return cacheDataMap;
	}

	public void setCacheDataMap(Map<String, Object> cacheDataMap) {
		this.cacheDataMap = cacheDataMap;
	}
    
    /*
    public void addCacheData(String key,Object obj){
        cacheDataMap.put(key,obj);
    }
    public Object getCacheData(String key){
        return cacheDataMap.get(key);
    }
    public void removeCacheData(String key){
    	if(cacheDataMap.containsKey(key)){
            cacheDataMap.remove(key);
        }
    }
    */
}
```

### 静态内部类单例模式

- 外部类加载时并不需要立即加载内部类，内部类不被加载则不去初始化instance，故而不占内存。
- 只有第一次调用getInstance()方法会导致虚拟机加载SingleTonHoler类，才会去初始化instance。
- 这种方法不仅能确保线程安全，也能保证单例的唯一性，同时也延迟了单例的实例化，但是由于是静态内部类的形式去创建单例的，故外部无法传递参数进去。

```java
public class SingleTon {
    private SingleTon() {}
    private static class SingleTonHoler {
        private static SingleTon instance = new SingleTon();
    }
    public static SingleTon getInstance() {
        return SingleTonHoler.instance;
    }
}
```

### 枚举单例模式

默认枚举实例的创建是线程安全的，并且在任何情况下都是单例。实际上

- 枚举类隐藏了私有的构造器。
- 枚举类的域是相应类型的一个实例对象

```java
public enum Singleton {
    INSTANCE;
    //可以省略此方法，通过Singleton.INSTANCE进行操作
    public static Singleton getInstance() {
        return Singleton.INSTANCE;
    }
}
```



## 工厂方法模式

定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”。

结构：工厂方法模式的主要角色如下。

抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。

具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。

抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。（只有一类产品）

具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。

如：A牧场产牛，B牧场产羊，AFarm.newAnimals();

## 抽象工厂模式

​	定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。

​	结构：抽象工厂模式的主要角色如下。

抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。

具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。

抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。（拥有多类产品）

具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。

如：A工厂产牛，水果，B工厂产羊，蔬菜，AFarm.newAnimals(),AFarm.newPlants();

两者都是始终由一家工厂创建类对象

## 装饰器模式

定义：指在不改变现有对象结构的情况下，动态地给该对象增加额外功能的模式。

结构：装饰模式主要包含以下角色。

抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。

具体构件（Concrete   Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。

抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。

具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

## 代理模式

为其他对象提供一种代理，以控制对这个对象的访问；通过代理对象访问目标对象，可以增强额外的操作，扩展目标对象的功能；

### 静态代理 

静态就是程序运行之前就已经存在代理类的字节码文件 

```java
public interface UserService {
    public void login(String username,String password);
    public String logout();
}

public class UserServiceImpl implements UserService {
    @Override
    public void login(String username, String password) {
        System.out.println("UserServiceImpl.login:"+username+","+password);
    }

	 @Override
    public String logout() {
        System.out.println("UserServiceImpl.logout");
        return "byebye";
    }
}

//代理的三要素：
//1.目标类的接口
//2.目标类的实例
//3.交叉业务逻辑，要执行的操作
//代理对象需要和目标对象实现相同的接口
public class UserServiceProxy implements UserService {
    
    private UserService userService=new UserServiceImpl();

    @Override
    public void login(String username, String password) {
        try {
            Method method = userService.getClass().getMethod("login", String.class, String.class);
            invoke(method,username,password);
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
    }

    @Override
    public String logout() {
        try {
            Method method = userService.getClass().getMethod("logout");
            return invoke(method).toString();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
        return null;
    }

    //封装到公共方法中，统一入口，模块化
    private Object invoke(Method method,Object...args){
        //1.打印日志
        System.out.println(method.getName()+" 启动 at:["+new Date().getTime()+"]");
        //2.执行业务
        try {
            return method.invoke(userService,args);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        return null;
    }
} 
 
public static void main(String[] args) {
    UserService userService=new UserServiceProxy();
    userService.login("admin","123");
    System.out.println(userService.logout());
} 
```

缺点：这种实现方式很直观也很简单，但其缺点是代理对象必须提前写出

### 动态代理

代理类是程序在运行期间由JVM根据反射等机制动态生成的，自动生成代理类和代理对象 。

所谓动态就是指在程序运行前不存在代理类的字节码文件。

#### JDK动态代理

目标对象必须实现一个或多个接口，如果没有实现任何接口，则无法使用jdk的动态代理

```java
public static void main(String[] args) {
    //调用Proxy类的newProxyInstance()方法动态的生成代理类和实例
    UserService userService= (UserService) Proxy.newProxyInstance(
            UserServiceImpl.class.getClassLoader(), //目标类的类加载器
            new Class[]{UserService.class}, //目标类的接口列表
            new InvocationHandler() { //交叉业务逻辑
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    //1.打印日志
                    System.out.println(method.getName()+" login at:["+new Date().getTime()+"]");
                    //2.执行业务
                    System.out.println("开启事务。。。。");
                    Object returnValue = null;
                    try {
                        returnValue = method.invoke(new UserServiceImpl(), args);
                        System.out.println("提交事务。。。。。");
                    } catch  (Exception e) {
                        System.out.println("回滚事务。。。。。");
                        throw e; //一定要抛出异常
                    }
                    return returnValue;
                }
            }
    );

    userService.login("admin","123");
    System.out.println("-------------------------------------------------");
    System.out.println(userService.logout());
    //代理类的类型
    System.out.println(userService.getClass());
}
```

缺点：可以看出静态代理和JDK代理有一个共同的缺点，就是目标对象必须实现一个或多个接口。

#### Cglib代理

没有实现接口，CGLib采用动态创建子类的方式生成代理对象，动态创建代理实例。（所以不能对目标类中的private、final等方法进行代理）。JDK1.8中JDK代理比cglib代理性能更好

```java
public static void main(String[] args) {

	HelloWorld helloWorld = (HelloWorld) Enhancer.create(
            HelloWorld.class, //目标类的类型
            new InvocationHandler() { //交叉业务逻辑
                @Override
                public Object invoke(Object o, Method method, Object[] args) throws Throwable {
                    System.out.println(method.getName() + " start at:[" + new Date().getTime() + "]");
                    return method.invoke(new HelloWorld(), args);
                }
            }
    );

    helloWorld.sayHello();
    //代理类的类型
    System.out.println(helloWorld.getClass());
}
```


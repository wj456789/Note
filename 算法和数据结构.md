# 数据结构

逻辑结构有：集合结构、线性结构、树形结构和图状结构.
物理结构有：线性存储结构和非线性存储结构，线性存储结构(线性表)有顺序(顺序表)、链式(链表)、索引和散列4种结构；非线性存储结构有树形存储结构、图形存储结构。

线性表有栈，队列，实现方式可以是顺序表也可以是链表；顺序表有数组；非线性存储结构有树、堆、图。

集合中ArrayList是顺序表，LinkedList是链表；

## 排序算法

### 插入排序

```java
public static void main(String[] args) {
    int[] array=new int[]{1,67,9,32,54,7,12};
    sort(array);
    for(int i:array){
        System.out.println(i);
    }
}

//数列中每一个数和之前数据比较，如果之前的数较大，往后移位，直到之前的数较小，在这之后插入这个数
public static void sort(int[] array){
    int preIndex;
    int current;
    for(int i=1;i<=array.length-1;i++){
        preIndex=i-1;
        current=array[i];
        while(preIndex>=0&&array[preIndex]>current){
            array[preIndex+1]=array[preIndex];
            preIndex--;
        }
        array[preIndex+1]=current;
    }
}
```

### 希尔排序

也是一种插入排序

将数组按照增量分组，对每组使用直接插入排序算法排序，初始增量gap=length/2，然后缩小增量gap=gap/2，直到增量为1将整个数组分为一组

如100个数据，先分为100/2=50组，每组2个值，每组分别排序

​						  再分为50/2=25组，每组4个值

​						  再分为25/2=12组，每组9或8个值

​						  ...

​						  最后分为2/2=1组，100为一组整体排序

```java
public static void main(String[] args) {
    int[] array=new int[]{1,67,9,32,54,7,12};
    sort(array);
    for(int i:array){
        System.out.println(i);
    }
}

public static void sort(int[] array){
    int gap=array.length/2;
    while(gap>0){
        int preIndex;
        int current;
        for(int i=gap;i<=array.length-1;i++){
            preIndex=i-gap;
            current=array[i];
            while(preIndex>=0&&array[preIndex]>current){
                array[preIndex+gap]=array[preIndex];
                preIndex-=gap;
            }
            array[preIndex+gap]=current;
        }
        gap/=2;
    }
}
```



### 快速排序

对于一个数列进行排序，比基准小的放在基准前，比基准大的放在基准后，然后再将小于基准的子序列和大于基准的子序列递归排序

```java
public static void main(String[] args) {
    int[] array=new int[]{1,67,9,32,54,7,12};
    quickSort(array, 0, array.length - 1);
    for(int i:array){
        System.out.println(i);
    }
}

public static void quickSort(int[] array,int start,int end){
    if(start>=end){
        return;
    }else{
        int patition = patition(array, start, end);
        if(patition>start){
            quickSort(array,start,patition-1);
        }
        if(patition<end){
            quickSort(array,patition+1,end);
        }
    }
}

//选开始值为基准，从前开始找到大于基准的坐标，从后开始找到小于基准的坐标，将两个值交换，然后在两个坐标之间继续循环，直到从后开始的坐标小于从前开始的坐标
public static int patition(int[] array,int start,int end){
    int i=start;
    int j=end+1;
    int pivot=array[start];		//pivot为基准值
    while(true){
        while(i<end&&array[++i]<pivot){}	//取大于基准的坐标
        while(j>start&&array[--j]>pivot){}	//取小于基准的坐标
        if(i>=j){
            break;
        }else{
            swap(array,i,j);
        }
    }
    swap(array,j,start);
    return j;
}

public static int[] swap(int[] array,int i,int j){
    int temp=array[i];
    array[i]=array[j];
    array[j]=temp;
    return array;
}
```


# 牛客网

## 字符串最后一个单词的长度

描述

计算字符串最后一个单词的长度，单词以空格隔开，字符串长度小于5000。

输入描述：

输入一行，代表要计算的字符串，非空，长度小于5000。

输出描述：

输出一个整数，表示输入字符串最后一个单词的长度。

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String str=sc.nextLine();
        String[] s=str.split(" ");
        int length=s[s.length-1].length();
        System.out.println(length);
    }
}
```

## 计算某字母出现次数

描述

写出一个程序，接受一个由字母、数字和空格组成的字符串，和一个字母，然后输出输入字符串中该字母的出现次数。不区分大小写，字符串长度小于500。

输入描述：

第一行输入一个由字母和数字以及空格组成的字符串，第二行输入一个字母。

输出描述：

输出输入字符串中含有该字符的个数。

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String str1=sc.nextLine().toLowerCase();
        Character c=sc.nextLine().toLowerCase().charAt(0);
        int count=0;
        for(int i=0;i<=str1.length()-1;i++){
            if(c==str1.charAt(i)){
                count++;
            }
        }
        System.out.println(count);
    }
}
```



## 明明的随机数

描述

明明想在学校中请一些同学一起做一项问卷调查，为了实验的客观性，他先用计算机生成了N个1到1000之间的随机整数（N≤1000），对于其中重复的数字，只保留一个，把其余相同的数去掉，不同的数对应着不同的学生的学号。然后再把这些数从小到大排序，按照排好的顺序去找同学做调查。请你协助明明完成“去重”与“排序”的工作(同一个测试用例里可能会有多组数据(用于不同的调查)，希望大家能正确处理)。

注：测试用例保证输入参数的正确性，答题者无需验证。测试用例不止一组。

当没有新的输入时，说明输入结束。

输入描述：

注意：输入可能有多组数据(用于不同的调查)。每组数据都包括多行，第一行先输入随机整数的个数N，接下来的N行再输入相应个数的整数。具体格式请看下面的"示例"。

输出描述：

返回多行，处理后的结果

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        while(sc.hasNext()){
            int n=sc.nextInt();
            Set set=new TreeSet();
            for(int i=1;i<=n;i++){
                set.add(sc.nextInt());
            }
            Iterator it=set.iterator();
            while(it.hasNext()){
                System.out.println(it.next());
            }
        }
    }
}
```

## 字符串分隔

描述

•连续输入字符串，请按长度为8拆分每个字符串后输出到新的字符串数组；
•长度不是8整数倍的字符串请在后面补数字0，空字符串不处理。

输入描述：

连续输入字符串(输入多次,每个字符串长度小于100)

输出描述：

输出到长度为8的新字符串数组

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        while(sc.hasNext()){
            String str=sc.nextLine();
            int nn=8-str.length()%8;
            while(nn>0&&nn<8){
                str+="0";
                nn--;
            }
            
            /*
            int n=str.length()/8;
            for(int j=0;j<n;j++){
                System.out.println(str.substring(8*j,8*(j+1)));
            }
            */
            while(str.length()>0){
                System.out.println(str.substring(0,8));
                str=str.substring(8);
            }
        }
    }
}
```

## 进制转换

描述

写出一个程序，接受一个十六进制的数，输出该数值的十进制表示。

输入描述：

输入一个十六进制的数值字符串。注意：一个用例会同时有多组输入数据，请参考帖子https://www.nowcoder.com/discuss/276处理多组输入的问题。

输出描述：

输出该数值的十进制字符串。不同组的测试用例用\n隔开。

```java
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner scanner = new Scanner(System.in);
            while(scanner.hasNext()){
                String str = scanner.nextLine();
                System.out.println(Integer.valueOf(str.substring(2),16).toString());
            }
        }
    }
}
```

```java
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            String str = sc.nextLine();
            String num = str.substring(2,str.length());
            int result = 0;
            int power = 1;
            for(int i = num.length() - 1; i >= 0; i--){
                char c = num.charAt(i);
                if(c >= '0' && c <= '9'){
                    result += (c - '0') * power;
                }else if (c >= 'A' && c <= 'F'){
                    result += (c - 'A' + 10) * power;
                }
                power *= 16;
            }
            System.out.println(result);
        }
        sc.close();
    }
}
```

## 质数因子

描述

功能:输入一个正整数，按照从小到大的顺序输出它的所有质因子（重复的也要列举）（如180的质因子为2 2 3 3 5 ）

最后一个数后面也要有空格

输入描述：

输入一个long型整数

输出描述：

按照从小到大的顺序输出它的所有质数的因子，以空格隔开。最后一个数后面也要有空格。

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        long l=sc.nextLong();
        long ll=(long)Math.sqrt(l);
        for(int i=2;i<=ll;i++){
            while(l%i==0){
                System.out.print(i+" ");
                l/=i;
            }
        }
        System.out.print(l==1?"":l+" ");
    }
}
```

## 取近似值

描述

写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整；小于5，则向下取整。

输入描述：

输入一个正浮点数值

输出描述：

输出该数值的近似整数值

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        float f=sc.nextFloat();
        int i=(int)f;
        if((f-i)>=0.5){
            System.out.println(i+1);
        }else{
            System.out.println(i);
        }
    }
}
```



## 合并表记录

描述

数据表记录包含表索引和数值（int范围的正整数），请对表索引相同的记录进行合并，即将相同索引的数值进行求和运算，输出按照key值升序进行输出。

输入描述：

先输入键值对的个数
然后输入成对的index和value值，以空格隔开

输出描述：

输出合并后的键值对（多行）

示例1

输入：

```
4
0 1
0 2
1 2
3 4
```

复制

输出：

```
0 3
1 2
3 4
```

```java
//个人错误
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        Map<Integer,Integer> map=new TreeMap<>();
        for(int i=1;i<=n;i++){
            String str=sc.nextLine();
            String[] s=str.split(" ");
            int n1=Integer.parseInt(s[0]);
            int n2=Integer.parseInt(s[1]);
            if(map.containsKey(n1)){
                map.put(n1,map.get(n1)+n2);
            }else{
                map.put(n1,n2);
            }
        }
        for(int nn:map.keySet()){
            System.out.println(nn+" "+map.get(nn));
        }
    }
}

//错误解析：其中nextInt()获取输入的一个int值，nextLine()获取回车之前的一行字符串，next()以回车为间隔获取每个字符串
```

```java
//答案
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        Map<Integer,Integer> map=new TreeMap<>();
        for(int i=1;i<=n;i++){
            int n1=sc.nextInt();
            int n2=sc.nextInt();
            if(map.containsKey(n1)){
                map.put(n1,map.get(n1)+n2);
            }else{
                map.put(n1,n2);
            }
        }
        for(int nn:map.keySet()){
            System.out.println(nn+" "+map.get(nn));
        }
    }
}
```

## 提取不重复的整数

描述

输入一个int型整数，按照从右向左的阅读顺序，返回一个不含重复数字的新的整数。

保证输入的整数最后一位不是0。

输入描述：

输入一个int型整数

输出描述：

按照从右向左的阅读顺序，返回一个不含重复数字的新的整数

示例1

输入：

```
9876673
```

复制

输出：

```
37689
```

```java
//个人正确
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String str=sc.nextLine();
        Set<Character> set=new LinkedHashSet<>();
        for(int i=str.length()-1;i>=0;i--){
            set.add(str.charAt(i));
        }
        for(Character c:set){
            System.out.print(c);
        }
    }
}
```

```java
//答案
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        char[] c=(n+"").toCharArray();
        String str="";
        for(int i=c.length-1;i>=0;i--){
            if(!str.contains(c[i]+"")){
                str+=c[i];
            }
        }
        System.out.println(Integer.valueOf(str));
    }
}
```







## 字符个数统计

描述

编写一个函数，计算字符串中含有的不同字符的个数。字符在ASCII码范围内(0~127，包括0和127)，换行表示结束符，不算在字符里。不在范围内的不作统计。多个相同的字符只计算一次

例如，对于字符串abaca而言，有a、b、c三种不同的字符，因此输出3。

输入描述：

输入一行没有空格的字符串。

输出描述：

输出 输入字符串 中范围在(0~127，包括0和127)字符的种数。

示例1

输入：

```
abc
```

复制

输出：

```
3
```

```java
//个人错误
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String str=sc.nextLine();
        Set<Character> set=new HashSet<>();
        for(int i=0;i<str.length();i++){
            int n=(int)str.charAt(i);
            if(n>=0&&n<=127){
                set.add(str.charAt(i));
            }
        }
        System.out.println(set.size());
    }
}
//错误解析：其中next()方法没有空格，nextLine()有空格；字符可强转为int，值为unicode或者ASCII码
```

```java
//答案
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String line = scanner.next();
        //总共有128个字符。字需要用128位
        BitSet bitSet = new BitSet(128);
        for (char c : line.toCharArray()) {
            //判断字符c是否已出现
            if (!bitSet.get(c)) {
                //未出现就设置为已出现
                bitSet.set(c);
            }
        }
        //统计有多少字符已出现过
        System.out.println(bitSet.cardinality());
    }
}
```



## 数字颠倒

描述

输入一个整数，将这个整数以字符串的形式逆序输出

程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001

输入描述：

输入一个int整数

输出描述：

将这个整数以字符串的形式逆序输出

示例1

输入：

```
1516000
```

复制

输出：

```
0006151
```

```java
//个人正确
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        char[] c=(n+"").toCharArray();
        for(int i=c.length-1;i>=0;i--){
            System.out.print(c[i]);
        }
    }
}
```

```java
//答案
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        StringBuffer sb=new StringBuffer(n+"");
        sb.reverse();
        System.out.println(sb.toString());
    }
}
```





## 字符串反转

描述

接受一个只包含小写字母的字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）

输入描述：

输入一行，为一个只包含小写字母的字符串。

输出描述：

输出该字符串反转后的字符串。

示例1

输入：

```
abcd
```

复制

输出：

```
dcba
```

```java
//个人正确
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String str=sc.nextLine();
        StringBuffer sb=new StringBuffer(str);
        sb.reverse();
        System.out.println(sb);
    }
}
```

```java
//答案
import java.util.*;
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        while(scanner.hasNext()){
            String str= scanner.nextLine();
            //将字符串变成char数组再倒序输出
            char[] chars= str.toCharArray();
            for(int i=chars.length-1;i>=0;i--){
                System.out.print(chars[i]);
            }
            System.out.println();
        }
    }
}
```







## 句子逆序

描述

将一个英文语句以单词为单位逆序排放。例如“I am a boy”，逆序排放后为“boy a am I”
所有单词之间用一个空格隔开，语句中除了英文字母外，不再包含其他字符

输入描述：

输入一个英文语句，每个单词用空格隔开。保证输入只包含空格和字母。

输出描述：

得到逆序的句子

示例1

输入：

```
I am a boy
```

复制

输出：

```
boy a am I
```

```java
//个人正确
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String str=sc.nextLine();
        String[] s=str.split(" ");
        String str1="";
        for(int i=s.length-1;i>=0;i--){
            str1+=s[i]+" ";
        }
        str1=str1.substring(0,str1.length()-1);
        System.out.println(str1);
    }
}
```

```java
//答案，使用栈
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String in=sc.nextLine();
        String[] arr=in.split("\\s");
        String str="";
        Stack<String> stack=new Stack<>();
        for(String str1:arr){
            stack.push(str1);
        }
        while(!stack.isEmpty()){
            str+=stack.pop()+" ";
        }
        System.out.println(str);
    }
}


//使用队列，队列使用双向链表实现
public class ReverseWord {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Deque<String> words = new LinkedList<>();
        for (String word : scanner.nextLine().split("\\s+")) {
            words.addFirst(word);
        }
        System.out.println(String.join(" ", words));
    }
}
```





## 字符串排序

描述

给定n个字符串，请对n个字符串按照字典序排列。

输入描述：

输入第一行为一个正整数n(1≤n≤1000),下面n行为n个字符串(字符串长度≤100),字符串中只含有大小写字母。

输出描述：

数据输出n行，输出结果为按照字典序排列的字符串。

示例1

输入：

```
9
cap
to
cat
card
two
too
up
boat
boot
```

复制

输出：

```
boat
boot
cap
card
cat
to
too
two
up
```

```java
//个人正确
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String num=sc.nextLine();
        int _num=Integer.valueOf(num);
        List<String> list=new ArrayList<>();
        for(int i=1;i<=_num;i++){
            String str=sc.nextLine();
            list.add(str);
        }
        Collections.sort(list,(o1,o2)->{
            return o1.compareTo(o2);
        });
        for(String str:list){
            System.out.println(str);
        }
    }
}
```

```java
//答案
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        withPriorityQueue();
    }

    // 方法一: 调用API Arrays.sort
    public static void withArraysAPI() throws IOException {
        Scanner sc = new Scanner(System.in);
        while (sc.hasNext()){
            int n = sc.nextInt();
            String [] arr = new String[n];
            for(int i=0;i<n;i++){
                String str = sc.next();
                arr[i] = str;
            }
            Arrays.sort(arr);
            for(int i=0;i<arr.length;i++){
                System.out.println(arr[i]);
            }
        }
        sc.close();
    }

    // 方法二: 使用PriorityQueue
    public static void withPriorityQueue() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        PriorityQueue<String> pq = new PriorityQueue<>();
        String s = "";
        while ((s = br.readLine()) != null) {
            pq.offer(s);
        }
        br.close();

        while (!pq.isEmpty()) {
            System.out.println(pq.poll());
        }        
    }

    // 方法三: 使用list并自己实现Comparator, 比较能体现算法的思路
    public static void withComparator() throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        List<String> list = new ArrayList<>();
        String s = "";
        while ((s = br.readLine()) != null) {
            list.add(s);
        }
        br.close();

        list.sort(new Comparator<String>() {
            @Override
            public int compare(String s1, String s2) {
                int i = 0;
                while (i < s1.length() && i < s2.length()) {
                    if (s1.charAt(i) != s2.charAt(i)) {
                        return (s1.charAt(i) > s2.charAt(i))? 1: -1;
                    }
                    i++;
                }
                if (s1.length() == s2.length()) {
                    return 0;
                } else {
                    return (s1.length() > s2.length())? 1: -1;
                }
            }
        });

        for(int i = 0; i < list.size(); i++) {
            System.out.println(list.get(i));
        }
    }  
}
```



## 求int型正整数在内存中存储时1的个数

描述

输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。

输入描述：

 输入一个整数（int类型）

输出描述：

 这个数转换成2进制后，输出1的个数

示例1

输入：

```
5
```

复制

输出：

```
2
```

```java
//个人正确
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        String str=Integer.toBinaryString(n);
        System.out.println(str.length()-str.replaceAll("1","").length());
    }
}
```

```java
//答案：使用递归
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int i = sc.nextInt();
        System.out.println(countOne(i));
    }

    public static int countOne(int a){
        return a == 0 ? 0 : a % 2 + countOne(a / 2);
    }
}
```

## 购物单

描述

王强今天很开心，公司发给N元的年终奖。王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：

| 主件   | 附件           |
| ------ | -------------- |
| 电脑   | 打印机，扫描仪 |
| 书柜   | 图书           |
| 书桌   | 台灯，文具     |
| 工作椅 | 无             |

如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。王强想买的东西很多，为了不超出预算，他把每件物品规定了一个重要度，分为 5 等：用整数 1 **~** 5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

  设第 j 件物品的价格为 v[j] ，重要度为 w[j] ，共选中了 k 件物品，编号依次为 j 1 ， j 2 ，……， j k ，则所求的总和为：

v[j 1 ]*w[j 1 ]+v[j 2 ]*w[j 2 ]+ … +v[j k ]*w[j k ] 。（其中 * 为乘号）

  请你帮助王强设计一个满足要求的购物单。

输入描述：

输入的第 1 行，为两个正整数，用一个空格隔开：N m

（其中 N （ <32000 ）表示总钱数， m （ <60 ）为希望购买物品的个数。）



从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q



（其中 v 表示该物品的价格（ v<10000 ）， p 表示该物品的重要度（ 1 **~** 5 ）， q 表示该物品是主件还是附件。如果 q=0 ，表示该物品为主件，如果 q>0 ，表示该物品为附件， q 是所属主件的编号）

输出描述：

 输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（ <200000 ）。

示例1

输入：

```
1000 5
800 2 0
400 5 1
300 5 1
400 3 0
500 2 0
```

复制

输出：

```
2200
```

### 解析

其实这题就是0-1背包问题

首先来看一下经典背包问题，稍作修改就可以得出这题的解答

**0-1背包问题**

问题描述：有一个背包可以装物品的总重量为W，现有N个物品，每个物品中`w[i]`，价值`v[i]`，用背包装物品，能装的最大价值是多少？

**定义状态转移数组`dp[i][j]`，表示前i个物品，背包重量为j的情况下能装的最大价值。**

例如，`dp[3][4]=6`，表示用前3个物品装入重量为4的背包所能获得的最大价值为6，此时并不是3个物品全部装入，而是3个物品满足装入背包的条件下的最大价值。

状态转移方程：

`dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i])`

`dp[i-1`][j]表示当前物品不放入背包，`dp[i-1][j-w[i]]+v[i]`表示当前物品放入背包，**即当前第i个物品要么放入背包，要么不放入背包**。

```
dp = [[0]*(n+1) for _ in range(m+1)]
for i in range(1,m+1):
    for j in range(1,n+1):
        if j-w[i]>=0:
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]]+v[i])
        else:
            dp[i][j] = dp[i-1][j]
return dp[m][n]
```

**现在来看下购物车的解题思路**

购物车本质上还是0-1背包问题，只不过多了主件和附件。假设先不看附件，那么就和0-1背包一样了。附件不能单独出现，要依赖于主件。

对应于背包问题，主件的个数就是物品的个数，考虑每个主件时要考虑可能出现的情况。

输入例子:
1000 5
800 2 0
400 5 1
300 5 1
400 3 0
500 2 0

在当前的例子当中物品的个数就是3。

考虑每个物品时要考虑每种可能出现的情况，**1、主件，2、主件+附件1，3、主件+附件2，4、主件+附件1+附件2**，不一定每种情况都出现，只有当存在附件时才会出现对应的情况。

`w[i][k]`表示第i个物品的第k种情况，k的取值范围0~3，分别对应以上4中情况，`v[i][k]`表示第i个物品对应第k种情况的价值，现在就把购物车问题转化为了0-1背包问题。

状态转移方程可以定义为

`dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i][k]]+v[i][k])`

`dp[i-1][j]`表示当前物品不放入背包，`w[i][k]`表示第i个主件对应第k中情况，**即当前第i个物品的4中情况中价值最大的要么放入背包，要么不放入背包**。

**需要注意**：`dp[i][j] = max(物品不放入背包，主件，主件+附件1，主件+附件2，主件+附件1+附件2)`

```
dp = [[0]*(n+1) for _ in range(m+1)]
for i in range(1,m+1):
    for j in range(1,n+1):
        max_i = dp[i-1][j]
        for k in range(len(w[i])):
            if j-w[i][k]>=0:
                max_i = max(max_i, dp[i-1][j-w[i][k]]+v[i][k])
        dp[i][j] = max_i
print(dp[m][n])
```

```java
//答案
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int money = sc.nextInt();
        int n = sc.nextInt();
        if(n<=0||money<=0) System.out.println(0);

        good[] Gs = new good[n+1];
        for (int i = 1; i <= n; i++) {
            int v = sc.nextInt();
            int p = sc.nextInt();
            int q = sc.nextInt();
            Gs[i] = new good(v,p,q);

            if(q>0){
                if(Gs[q].a1==0){
                    Gs[q].setA1(i);
                }else {
                    Gs[q].setA2(i);
                }
            }
        }

        int[][] dp = new int[n+1][money+1];
        for (int i = 1; i <= n; i++) {
            int v=0,v1=0,v2=0,v3=0,tempdp=0,tempdp1=0,tempdp2=0,tempdp3=0;

            v = Gs[i].v;

            tempdp = Gs[i].p*v; //只有主件

            if(Gs[i].a1!=0){//主件加附件1
                v1 = Gs[Gs[i].a1].v+v;
                tempdp1 = tempdp + Gs[Gs[i].a1].v*Gs[Gs[i].a1].p;
            }

            if(Gs[i].a2!=0){//主件加附件2
                v2 = Gs[Gs[i].a2].v+v;
                tempdp2 = tempdp + Gs[Gs[i].a2].v*Gs[Gs[i].a2].p;
            }

            if(Gs[i].a1!=0&&Gs[i].a2!=0){//主件加附件1和附件2
                v3 = Gs[Gs[i].a1].v+Gs[Gs[i].a2].v+v;
                tempdp3 = tempdp + Gs[Gs[i].a1].v*Gs[Gs[i].a1].p + Gs[Gs[i].a2].v*Gs[Gs[i].a2].p;
            }

            for(int j=1; j<=money; j++){
                if(Gs[i].q > 0) {   //当物品i是附件时,相当于跳过
                    dp[i][j] = dp[i-1][j];
                } else {
                    dp[i][j] = dp[i-1][j];
                    if(j>=v&&v!=0) dp[i][j] = Math.max(dp[i][j],dp[i-1][j-v]+tempdp);
                    if(j>=v1&&v1!=0) dp[i][j] = Math.max(dp[i][j],dp[i-1][j-v1]+tempdp1);
                    if(j>=v2&&v2!=0) dp[i][j] = Math.max(dp[i][j],dp[i-1][j-v2]+tempdp2);
                    if(j>=v3&&v3!=0) dp[i][j] = Math.max(dp[i][j],dp[i-1][j-v3]+tempdp3);
                }
            }
        }
        System.out.println(dp[n][money]);


    }


    /**
     * 定义物品类
     */
    private static class good{
        public int v;  //物品的价格
        public int p;  //物品的重要度
        public int q;  //物品的主附件ID

        public int a1=0;   //附件1ID
        public int a2=0;   //附件2ID

        public good(int v, int p, int q) {
            this.v = v;
            this.p = p;
            this.q = q;
        }

        public void setA1(int a1) {
            this.a1 = a1;
        }

        public void setA2(int a2) {
            this.a2 = a2;
        }
    }
}
```



## 坐标移动

描述

开发一个坐标计算工具， A表示向左移动，D表示向右移动，W表示向上移动，S表示向下移动。从（0,0）点开始移动，从输入字符串里面读取一些坐标，并将最终输入结果输出到输出文件里面。

输入：

合法坐标为A(或者D或者W或者S) + 数字（两位以内）

坐标之间以;分隔。

非法坐标点需要进行丢弃。如AA10; A1A; $%$; YAD; 等。

下面是一个简单的例子 如：

A10;S20;W10;D30;X;A1A;B10A11;;A10;

处理过程：

起点（0,0）

\+  A10  = （-10,0）

\+  S20  = (-10,-20)

\+  W10 = (-10,-10)

\+  D30 = (20,-10)

\+  x  = 无效

\+  A1A  = 无效

\+  B10A11  = 无效

\+ 一个空 不影响

\+  A10 = (10,-10)

结果 （10， -10）

**注意请处理多组输入输出**

输入描述：

一行字符串

输出描述：

最终坐标，以逗号分隔

示例1

输入：

```
A10;S20;W10;D30;X;A1A;B10A11;;A10;
```

复制

输出：

```
10,-10
```

```java
//个人正确
import java.util.*;
import java.util.regex.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String str=sc.nextLine();
        String[] s= str.split(";");
        int x=0,y=0;
        for(int i=0;i<s.length;i++){
            if(Pattern.matches("(A|S|W|D)\\d{1,2}",s[i])){
                int n=Integer.parseInt(s[i].substring(1));
                if(s[i].startsWith("A")){
                    x-=n;
                }
                if(s[i].startsWith("D")){
                    x+=n;
                }
                if(s[i].startsWith("W")){
                    y+=n;
                }
                if(s[i].startsWith("S")){
                    y-=n;
                }
            }
        }
        System.out.println(x+","+y);
    }
}
```

```java
//答案：使用map，使用String.matches(regex)方法
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class Main{
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Map<Character, Integer> map = new HashMap<Character, Integer>();
        while(scanner.hasNext()) {
            String s = scanner.nextLine();
            int x = 0 , y = 0;
            String[] sArray = s.split(";");
            String res = "[ADWS]\\d{1}\\d?";
            for(int i = 0;i < sArray.length;i ++) {
                if(sArray[i].matches(res))
                    map.put(sArray[i].charAt(0),map.getOrDefault(sArray[i].charAt(0), 0)+Integer.valueOf(sArray[i].substring(1)));
            }
            x = x - map.get('A') + map.get('D');
            y = y - map.get('S') + map.get('W');
            System.out.println(x+","+y);
            map.clear();
        }
        scanner.close();
    }
}
```



## 识别有效的IP地址和掩码并进行分类统计

描述

请解析IP地址和对应的掩码，进行分类识别。要求按照A/B/C/D/E类地址归类，不合法的地址和掩码单独归类。

所有的IP地址划分为 A,B,C,D,E五类

A类地址1.0.0.0~126.255.255.255;

B类地址128.0.0.0~191.255.255.255;

C类地址192.0.0.0~223.255.255.255;

D类地址224.0.0.0~239.255.255.255；

E类地址240.0.0.0~255.255.255.255



私网IP范围是：

10.0.0.0～10.255.255.255

172.16.0.0～172.31.255.255

192.168.0.0～192.168.255.255

子网掩码为二进制下前面是连续的1，然后全是0。（例如：255.255.255.32就是一个非法的掩码）

注意二进制下全是1或者全是0均为非法

注意：

\1. 类似于【0.*.*.*】和【127.*.*.*】的IP地址不属于上述输入的任意一类，也不属于不合法ip地址，计数时可以忽略

\2. 私有IP地址和A,B,C,D,E类地址是不冲突的



输入描述：

多行字符串。每行一个IP地址和掩码，用~隔开。

输出描述：

统计A、B、C、D、E、错误IP地址或错误掩码、私有IP的个数，之间以空格隔开。

示例1

输入：

```
10.70.44.68~255.254.255.0
1.0.0.1~255.0.0.0
192.168.0.2~255.255.255.0
19..0.~255.255.255.0
```

复制

输出：

```
1 0 1 0 0 2 1
```



### 解析

坑一 统计错误IP地址或错误掩码的数目

```
一开始我想的是，统计每一个错误的ip地址和错误掩码，举个例子，0.0.10.1~255.245.55 ,ip是错的，
子网掩码也是错的，所以算俩个，后面才发现，ip和子网掩码都错只算一个。
```

坑二 私有地址和公有地址是不冲突的，都算

坑三 判断子网掩码错误时，忽略了全是1和全是0的情况

坑四 定义一个方法，将十进制的数转化为二进制，再作为字符串输出。将这四段字符串连成一个，通过indexof("0")和Lastindexof("1")的大小关系判断是否前面全为1，后面全为0。注意此处有两个坑，第一个坑是定义的转化二进制数字的方法中，高位的0是不会添加的，需要另外添加补成8位。比如16，定义的方法转化为10000，我们需要补成00010000。第二个坑是在于掩码中有的位置为空，比如255.255..0,使用split("\.")只能分成三段，会产生数组越界异常，因此分割完后判断数组长度是否为4，不是4直接计入错误类，此坑同样会出现在后续的判断IP中。



```java
//答案
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        int[] count=new int[7];
        while (sc.hasNext()){
            String str=sc.nextLine();
            String[] IPandYM=str.split("~");
            String[] YMarray=IPandYM[1].split("\\.");
            String[] IParray=IPandYM[0].split("\\.");
            boolean YMisWrong=false;
            String YMstr="";
            for (int i=0;i<4;i++){
                YMstr=YMstr+getBinary(Integer.valueOf(YMarray[i]));
            }
            if (YMstr.indexOf("0")==-1||YMstr.indexOf("1")==-1||YMstr.indexOf("0")<YMstr.lastIndexOf("1")
                ||IParray.length!=4||YMarray.length!=4){
                YMisWrong=true;
                   count[5]++; 


            }
            if (!YMisWrong){
                if(IParray[0]!=""&&Integer.valueOf(IParray[0])>=1&&Integer.valueOf(IParray[0])<=126){
                    if(IParray[1]!=""&&IParray[2]!=""&&IParray[3]!=""&&
                            Integer.valueOf(IParray[1])>=0&&Integer.valueOf(IParray[1])<=255&&
                            Integer.valueOf(IParray[2])>=0&&Integer.valueOf(IParray[2])<=255&&
                            Integer.valueOf(IParray[3])>=0&&Integer.valueOf(IParray[3])<=255){
                        count[0]++;
                        if (Integer.valueOf(IParray[0])==10) count[6]++;
                    }
                }else if(IParray[0]!=""&&Integer.valueOf(IParray[0])>=128&&Integer.valueOf(IParray[0])<=191){
                    if(IParray[1]!=""&&IParray[2]!=""&&IParray[3]!=""&&
                            Integer.valueOf(IParray[1])>=0&&Integer.valueOf(IParray[1])<=255&&
                            Integer.valueOf(IParray[2])>=0&&Integer.valueOf(IParray[2])<=255&&
                            Integer.valueOf(IParray[3])>=0&&Integer.valueOf(IParray[3])<=255){
                        count[1]++;
                        if (Integer.valueOf(IParray[0])==172&&Integer.valueOf(IParray[1])>=16&&Integer.valueOf(IParray[1])<=31) count[6]++;
                    }
                }else if(IParray[0]!=""&&Integer.valueOf(IParray[0])>=192&&Integer.valueOf(IParray[0])<=223){
                    if(IParray[1]!=""&&IParray[2]!=""&&IParray[3]!=""&&
                            Integer.valueOf(IParray[1])>=0&&Integer.valueOf(IParray[1])<=255&&
                            Integer.valueOf(IParray[2])>=0&&Integer.valueOf(IParray[2])<=255&&
                            Integer.valueOf(IParray[3])>=0&&Integer.valueOf(IParray[3])<=255){
                        count[2]++;
                        if (Integer.valueOf(IParray[0])==192&&Integer.valueOf(IParray[1])==168) count[6]++;
                    }
                }else if(IParray[0]!=""&&Integer.valueOf(IParray[0])>=224&&Integer.valueOf(IParray[0])<=239){
                    if(IParray[1]!=""&&IParray[2]!=""&&IParray[3]!=""&&
                            Integer.valueOf(IParray[1])>=0&&Integer.valueOf(IParray[1])<=255&&
                            Integer.valueOf(IParray[2])>=0&&Integer.valueOf(IParray[2])<=255&&
                            Integer.valueOf(IParray[3])>=0&&Integer.valueOf(IParray[3])<=255){
                        count[3]++;
                    }
                }else if(IParray[0]!=""&&Integer.valueOf(IParray[0])>=240&&Integer.valueOf(IParray[0])<=255){
                    if(IParray[1]!=""&&IParray[2]!=""&&IParray[3]!=""&&
                            Integer.valueOf(IParray[1])>=0&&Integer.valueOf(IParray[1])<=255&&
                            Integer.valueOf(IParray[2])>=0&&Integer.valueOf(IParray[2])<=255&&
                            Integer.valueOf(IParray[3])>=0&&Integer.valueOf(IParray[3])<=255){
                        count[4]++;
                    }
                }else{
                    if (Integer.valueOf(IParray[0])!=0&&Integer.valueOf(IParray[0])!=127){
                       count[5]++; 
                     }
                }
            }



        }
        System.out.println(count[0]+" "+count[1]+" "+count[2]+" "+count[3]+" "+count[4]+" "+count[5]+" "+count[6]);
    }

    public static String getBinary(int num) {
        int currentNum = num;//存放当前的被除数
        LinkedList<String> list = new LinkedList<String>();//存放余数，也是就二进制数
        if (num==0){
            return "00000000";
        }
        while (currentNum != 0) {
            if (currentNum % 2 == 0) {
                list.addFirst("0");
            } else {
                list.addFirst("1");
            }
            currentNum /= 2;
        }

        StringBuilder sb = new StringBuilder();//当然你可以使用其他形式作为方法的返回
        if (list.size()<8){
            for (int i = 0; i < 8 - list.size(); i++) {
                sb.append("0");
            }
        }
        for (int i = 0; i < list.size(); i++) {
            sb.append(list.get(i));
        }

        return sb.toString();
```





## 简单错误记录

描述

开发一个简单错误记录功能小模块，能够记录出错的代码所在的文件名称和行号。



处理：



1、 记录最多8条错误记录，循环记录，最后只用输出最后出现的八条错误记录。对相同的错误记录只记录一条，但是**错误计数增加。最后一个斜杠后面的带后缀名的部分（保留最后16位）和行号完全匹配的记录才做算是”相同“的错误记录。**

2、 超过16个字符的文件名称，只记录文件的最后有效16个字符；

3、 输入的文件可能带路径，记录文件名称不能带路径。

4、循环记录时，只以第一次出现的顺序为准，后面重复的不会更新它的出现时间，仍以第一次为准



输入描述：

每组只包含一个测试用例。一个测试用例包含一行或多行字符串。每行包括带路径文件名称，行号，以空格隔开。

输出描述：

将所有的记录统计并将结果输出，格式：文件名 代码行数 数目，一个空格隔开，如：

示例1

输入：

```
D:\zwtymj\xccb\ljj\cqzlyaszjvlsjmkwoqijggmybr 645
E:\je\rzuwnjvnuz 633
C:\km\tgjwpb\gy\atl 637
F:\weioj\hadd\connsh\rwyfvzsopsuiqjnr 647
E:\ns\mfwj\wqkoki\eez 648
D:\cfmwafhhgeyawnool 649
E:\czt\opwip\osnll\c 637
G:\nt\f 633
F:\fop\ywzqaop 631
F:\yay\jc\ywzqaop 631
```

复制

输出：

```
rzuwnjvnuz 633 1
atl 637 1
rwyfvzsopsuiqjnr 647 1
eez 648 1
fmwafhhgeyawnool 649 1
c 637 1
f 633 1
ywzqaop 631 2
```

```java
//个人错误
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String first="";
        Map<String,Integer> map=new LinkedHashMap<String,Integer>();
        List<String> list=new LinkedList<>();
        while(sc.hasNext()){
            String str=sc.nextLine();
            String[] s1=str.split(" ");
            String name=s1[0].substring(s1[0].lastIndexOf("\\")+1);
            if(name.contains(".")){
                name=name.substring(0,name.lastIndexOf("."));
            }
            if(name.length()>16){
                name=name.substring(name.length()-16);
            }
            String key=name+" "+s1[1];
            
            if(map.containsKey(key)){
                map.put(key,map.get(key)+1);
            }else{
                map.put(key,1);
                list.add(key);
            }
            if(list.size()>8){
                list.remove(0);
            }
        }
        sc.close();
        for(String key:list){
            System.out.println(key+" "+map.get(key));
        }
    }
}
//错误解析，只有正则表达式进行2次转义
```

```java
//答案：使用linkedhashmap
import java.io.*;
import java.util.*;
public class 简单错误记录linked{
    public static void main(String[] args) throws IOException{
        BufferedReader cin = new BufferedReader(new InputStreamReader(System.in));
        Map<String,Integer> m=new LinkedHashMap<String,Integer>();
        String tstr=null;
        while((tstr = cin.readLine()) != null && !tstr.equals("")){      //&& !tstr.equals(""))没有性能影响
            String[] str=tstr.split("\\s+");
            String fname=str[0].substring(str[0].lastIndexOf("\\")+1);
            fname=fname.substring(Math.max(fname.length()-16 ,0))+" "+str[1];  //max 最快推荐 ？：也可以 if太麻烦
            Integer tmp=m.get(fname);  //get==null较快写法
            if(tmp==null)
                m.put(fname,1);
            else
                m.put(fname, tmp+1);
        }
        int cnt=0;
        for(Map.Entry<String,Integer> it:m.entrySet()){
            if(m.size()-cnt<=8)
                System.out.println(it.getKey()+" "+it.getValue());
            cnt++;
        }
    }
}
/*
运行时间：45ms
占用内存：10772k

v3 改用bufferedReader
运行时间：18ms
占用内存：9600k
v4 split \\ 改为 lastIndexOf("\\")+1
运行时间：16ms
占用内存：9596k
* */
```





## 密码验证合格程序

描述

密码要求:

1.长度超过8位

2.包括大小写字母.数字.其它符号,以上四种至少三种

3.不能有相同长度大于2的子串重复

输入描述：

一组或多组长度超过2的字符串。每组占一行

输出描述：

如果符合要求输出：OK，否则输出NG

示例1

输入：

```
021Abc9000
021Abc9Abc1
021ABC9000
021$bc9000
```

复制

输出：

```
OK
NG
NG
OK
```



```java
//个人正确
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String s="NG";
        while(sc.hasNextLine()){
            String str=sc.nextLine();
            if(str.length()>8){
                int count=0;
                if(str.matches(".*[a-z].*")){
                    count++;
                }
                if(str.matches(".*[A-Z].*")){
                    count++;
                }
                if(str.matches(".*[0-9].*")){
                    count++;
                }
                if(str.matches(".*[^0-9a-zA-Z].*")){
                    count++;
                }
                if(count>=3){
                    Set<String> set=new HashSet<String>();
                    boolean flag=true;
                    for(int i=0;i<=str.length()-3;i++){
                        if(!set.add(str.substring(i,i+3))){
                            flag=false;
                            break;
                        }
                    }
                    if(flag){
                        System.out.println("OK");
                        continue;
                    }
                }
            }
            System.out.println("NG");
        }
    }
}
```







## 简单密码

描述

密码是我们生活中非常重要的东东，我们的那么一点不能说的秘密就全靠它了。哇哈哈. 接下来渊子要在密码之上再加一套密码，虽然简单但也安全。

 

假设渊子原来一个BBS上的密码为zvbo9441987,为了方便记忆，他通过一种算法把这个密码变换成YUANzhi1987，这个密码是他的名字和出生年份，怎么忘都忘不了，而且可以明目张胆地放在显眼的地方而不被别人知道真正的密码。

 

他是这么变换的，大家都知道手机上的字母： 1--1， abc--2, def--3, ghi--4, jkl--5, mno--6, pqrs--7, tuv--8 wxyz--9, 0--0,就这么简单，渊子把密码中出现的小写字母都变成对应的数字，数字和其他的符号都不做变换，

 

声明：密码中没有空格，而密码中出现的大写字母则变成小写之后往后移一位，如：X，先变成小写，再往后移一位，不就是y了嘛，简单吧。记住，z往后移是a哦。



输入描述：

输入包括多个测试数据。输入是一个明文，密码长度不超过100个字符，输入直到文件结尾

输出描述：

输出渊子真正的密文

示例1

输入：

```
YUANzhi1987
```

复制

输出：

```
zvbo9441987
```

```java
//答案
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        String str=sc.nextLine();
        Map<String,Integer> map=new HashMap<>();
        map.put("abc",2);
        map.put("def",3);
        map.put("ghi",4);
        map.put("jkl",5);
        map.put("mno",6);
        map.put("pqrs",7);
        map.put("tuv",8);
        map.put("wxyz",9);
        for(int i=0;i<str.length();i++){
            char c=str.charAt(i);
            if(c>='A'&&c<='Z'){
                if(c=='Z'){
                    System.out.print('a');
                }else{
                    System.out.print((char)(c+33));
                }
            }else if(c>='a'&&c<='z'){
                final Character fc=c;
                String key=map.keySet().stream().filter(o->o.contains(fc+"")).findAny().get();
                System.out.print(map.get(key));
            }else{
                System.out.print(c);
            }
        }
    }
}

//
char c='A';
char C=(char)('A'+32);	//'a'
String cc=c+"";
```

## 汽水瓶

描述

有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝？

输入描述：

输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1<=n<=100），表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。

输出描述：

对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。

示例1

输入：

```
3
10
81
0
```

复制

输出：

```
1
5
40
```

```java
//个人
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        while(sc.hasNextInt()){
            int n=sc.nextInt();
            if(n==0){
                break;
            }
            int count=0;
            System.out.println(countN(n,count));
        }
    }
    
    static int countN(int n,int count){
        count+=n/3;
        n=n/3+n%3;
        if(n>=3){
            count=countN(n,count);
        }else if(n==2){
            count++;
        }
        return count;
    }
}
```

```java
//答案
import java.util.*;
public class Main {
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        while(!sc.hasNext("0")){
            int n = sc.nextInt();
            int count = 0;
            while(n/3>0){
                count+=n/3;
                n=n/3+n%3;
                if(n==2){
                    n=n+1;
                }
            }
            System.out.println(count);
        }
    }
}


//最优解：剩2个空瓶子时，可以先找老板借一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。 也就是说2个空瓶子即可换一瓶汽水喝，而且喝完之后手里也没有空瓶子。求解时直接把空瓶数除以2，即可得到正解。
```

## 删除字符串中出现次数最少的字符

描述

实现删除字符串中出现次数最少的字符，若多个字符出现次数一样，则都删除。输出删除这些单词后的字符串，字符串中其它字符保持原来的顺序。

注意每个输入文件有多组输入，即多个字符串用回车隔开

输入描述：

字符串只包含小写英文字母, 不考虑非法输入，输入的字符串长度小于等于20个字节。

输出描述：

删除字符串中出现次数最少的字符后的字符串。

示例1

输入：

```
abcdd
aabcddd
```

复制

输出：

```
dd
aaddd
```

```java
//个人
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc=new Scanner(System.in);
        while(sc.hasNextLine()){
            String str=sc.nextLine();
            char[] s=str.toCharArray();
            Map<Character,Integer> map=new HashMap<>();
            for(int i=0;i<s.length;i++){
                if(map.containsKey(s[i])){
                    map.put(s[i],map.get(s[i])+1);
                }else{
                    map.put(s[i],1);
                }
            }
            
            int min=Integer.MAX_VALUE;
            for(char c:map.keySet()){
                min=map.get(c)<min?map.get(c):min;
            }
            
            for(int i=0;i<s.length;i++){
                if(map.get(s[i])>min){
                    System.out.print(s[i]+"");
                }
            }
            System.out.println("");
        }
    }
}
```

```java
//答案
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        //存放每个字符以及出现的次数
        int min = Integer.MAX_VALUE;
        Map<Character,Integer> map = new HashMap<Character,Integer>();
        while(sc.hasNextLine()){
            String str = sc.nextLine();
            if(str.length()>20){
                continue;
            }
            for(int i=0;i<str.length();i++){
                if(map.keySet().contains(str.charAt(i))){
                    map.put(str.charAt(i),map.get(str.charAt(i))+1);
                }else{
                    map.put(str.charAt(i),1);
                }
            }
            //遍历values获取出现次数最少的次数
            for(Integer v:map.values()){
                min = v<min?v:min;
            }
            //遍历输入str
            for(int i=0;i<str.length();i++){
                if(map.get(str.charAt(i))!=min){
                    System.out.print(str.charAt(i));
                }
            }
            map.clear();
            System.out.println("");
        }
    }
}
```





## 合唱队

描述

计算最少出列多少位同学，使得剩下的同学排成合唱队形

说明：

N位同学站成一排，音乐老师要请其中的(N-K)位同学出列，使得剩下的K位同学排成合唱队形。
合唱队形是指这样的一种队形：设K位同学从左到右依次编号为1，2…，K，他们的身高分别为T1，T2，…，TK，  则他们的身高满足存在i（1<=i<=K）使得T1<T2<......<Ti-1<Ti>Ti+1>......>TK。

你的任务是，已知所有N位同学的身高，计算最少需要几位同学出列，可以使得剩下的同学排成合唱队形。

**
**

**注意：不允许改变队列元素的先后顺序** **且** **不要求最高同学左右人数必须相等**

**请注意处理多组输入输出！**

备注：

1<=N<=3000

输入描述：

有多组用例，每组都包含两行数据，第一行是同学的总数N，第二行是N位同学的身高，以空格隔开

输出描述：

最少需要几位同学出列

示例1

输入：

```
8
186 186 150 200 160 130 197 200
```

复制

输出：

```
4
```

复制

说明：

```
由于不允许改变队列元素的先后顺序，所以最终剩下的队列应该为186 200 160 130或150 200 160 130     
```

### 解析

思路：

1. 对于题目，所有人都已经站好位，不能再改变位置了，只能从当中去掉人组成合唱队。同时，可以考虑中间的人两边没有人的情况（比如两头的两个人，或者这个人太矮周围的人都比他高的情况），但是这种情况基本被pass掉。
2. 计算出每个人左边能出现的最多的人数：
   比如题中所给出的示例：186 186 150 200 160 130 197 200。首先如果第一个数186在中间，左边没有数，就自己一个人，所以是1；第二个数186因为左边那个人跟他一边高，没有比他矮的了，所以也是1；第三个数150，左边的人都比他高，他如果是中间的话左边也他自己一个人，所以还是1；第四个数200，因为不能换位置，所以只能留186或者150，加上自己，就是2...最后再以197为例，左边保留150,160是左边人最多的情况，再加上自己，就是3。所以每个人左边人最多的情况（加上自己）就是（186）1 1 1 2 2 1 3 4（200）。同理，看一下每个人右边可能出现最多的人，这时我们从后往前看。200在最右面，所以自己一个人，是1；197最右面没有比他矮的，自己，是1...160左边一个比他矮的，所以算上自己是2，以此类推。所以每个人右边人做多的情况（加上自己）就是（186）3 3 2 3 2 1 1 1（200）
3. 所以将上面两个划横线的对应相加，就可以得到自己如果是中间的那个人，可以得到的最大的合唱队人数。当然，自己加了两遍，所以得减掉一个自己。另外题目问的是最少去掉的人，所以最后的结果：
   总人数 - 该数所在队列人数 = 需要出队的人数

**最长子序列问题**

发表于 2020-05-16 22:29:03

先找到每一个位置i左侧的最长上升子序列长度numL[i]：每一个位置左侧最长子序列长度等于其左侧比它小的所有位置的最长子序列长度中的最大值+1
再找到每一个位置i右侧的最长下降子序列长度numR[i]：每一个位置右侧最长子序列长度等于其右侧比它小的所有位置的最长子序列长度中的最大值+1
然后求出所有位置的最长序列长度=左侧最长子序列长度+右侧最长子序列长度-1（因为该位置被算了两次，所以减1）
然后用数目减去最长序列长度就是答案

```java
//答案
import java.util.Scanner;

public class LISheChang {
    /**
     计算最少出列多少位同学，使得剩下的同学排成合唱队形
     */

    public static void main(String[] args){
        Scanner scan = new Scanner(System.in);
        while(scan.hasNext()){
            int total = scan.nextInt();
            int[] arr = new int[total+1];
            for(int i = 1 ; i <= total ; i++){
                arr[i] = scan.nextInt();
            }
            int[] l = left(arr);
            int[] r = right(arr);
            int max = 0;
            for(int i = 0 ; i < arr.length ; i++){
                if(max < (l[i]+r[i]-1)){
                    max = l[i]+r[i]-1;
                }
            }
            System.out.println(total -max);

        }
    }
    //186 186 150 200 160 130 197 200
    // 1   1   1   2   2   1   3   4
    //LIs:上升子序列长度
    //f(i): 已arr[i]结尾的LIS
    //如果左边的数：arr[j] < arr[i]
    // f(i) = f(j)+1
    // arr[j+1] < arr[i]
    // f(i) = f(j+1)+1
    //最长LIS: max{ f(j)+1,f(j+1)+1 }
    public static  int[]  left(int[] arr){
        int[] left = new int[arr.length];
        for(int i =1 ; i < arr.length ; i++){
            left[i] = 1;
            for(int j = 1 ; j < i ;j++){
                if(arr[j] < arr[i]){
                    left[i] = Math.max(left[i],left[j]+1);
                }
            }
        }
        return left;
    }
    //186 186 150 200 160 130 197 200
    public static  int[]  right(int[] arr){
        int[] right= new int[arr.length];
        for(int i =arr.length-1 ; i > 0; i--){
            right[i] = 1;
            for(int j = arr.length-1; j >i ;j--){
                if(arr[j] < arr[i]){
                    right[i] = Math.max(right[i],right[j]+1);
                }
            }
        }
        return right;
    }
}
```






























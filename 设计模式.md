# 设计模式

## 分类

总体来说设计模式分为三大类：

创建型模式，共五种：单例模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式。

结构型模式，共七种：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。

行为型模式，共十一种：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式、访问者模式、备忘录模式、命令模式、解释器模式、中介模式。

创建型设计模式主要解决“对象的创建”问题，结构型设计模式主要解决“类或对象的组合或组装”问题，行为型设计模式主要解决的是“类或对象之间的交互”问题。

## 创建型模式

### 单例模式

单例模式确保某个类只有一个实例，而且自行实例化并向其他所有对象提供这个实例。

#### 饿汉式

```java
//在类加载的时候创建实例对象。不会出现线程安全，JVM在类加载时保证只会有一个线程去执行类的初始化方法
public class Singleton(){
    private Singleton(){}
    private static Singleton single=new Singleton();
    public static Singleton getInstance(){
    	return single;
    }
    
    private AtomicLong id = new AtomicLong(0);
    public long getId() {
        return id.incrementAndGet();
    }
}
```

#### 懒汉式

```java
//在第一次调用时实例化自己，会出现线程安全，可以将getInstance方法改为public static synchronized Singleton getInstance(){}，但是会导致这个函数的并发度很低
public class Singleton{
    private Singleton(){}
    private static Singleton single=null;
    public static Singleton getInstance(){
        if(single==null){
            single=new Singleton();
        }
        return single;
    }
    
    private AtomicLong id = new AtomicLong(0);
    public long getId() {
        return id.incrementAndGet();
    }
}
```

#### 双重检查

饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种既支持延迟加载、又支持高并发的单例实现方式，也就是双重检测实现方式。

```java
//双重检查模式，进行了两次的判断，第一次是为了避免不要的实例，第二次是为了进行同步，避免多线程问题。
public class Singleton {  
    
	/*
	new 不是一个原子操作 ,指令可能会重排序(高版本的 Java 已经在JDK 内部实现中解决了这个问题，把对象 new 操作设计为原子操作，就自然能禁止重排序)
	1、重排序：先分配内存，让 instance 指向这块内存 ，然后执行对象的初始化 ，这种会有问题，在初始化执行没有完成 ，这时候 cpu 切换时间片 ，
    导致其他线程执行第一个判断不为空，直接返回 ，但是对象还没有初始化完
    2、正常排序：先分配内存，然后对象初始化，让 instance 指向这个内存
    总结 ： valotile 修饰变量，指令不会重排序 ，也就是上面的步骤2
	*/
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getInstance () {
        if (singleton == null) {  
            
            //将判断为空和new操作原子化，同时synchronized也保证了内存可见
            synchronized (Singleton.class) {  
                if (singleton == null) {  
                	singleton = new Singleton();
                }  
            } 
            
        }  
        return singleton;  
    }  
    
    private AtomicLong id = new AtomicLong(0);
    public long getId() {
        return id.incrementAndGet();
    }
}
```

##### 单例模式结合HASHMAP实现缓存

```java
public class Singleton {  
    private volatile static Singleton singleton;  
    private Singleton (){}  
    public static Singleton getInstance () {  
        if (singleton == null) {  
            synchronized (Singleton.class) {  
                if (singleton == null) {  
                	singleton = new Singleton();
                }  
            } 
        }  
        return singleton;  
    }  
    
    private Map<String, Object> cacheDataMap = new ConcurrentHashMap<String, Object>();
    public Map<String, Portalbas> getCacheDataMap() {
		return cacheDataMap;
	}

	public void setCacheDataMap(Map<String, Object> cacheDataMap) {
		this.cacheDataMap = cacheDataMap;
	}
    
    /*
    public void addCacheData(String key,Object obj){
        cacheDataMap.put(key,obj);
    }
    public Object getCacheData(String key){
        return cacheDataMap.get(key);
    }
    public void removeCacheData(String key){
    	if(cacheDataMap.containsKey(key)){
            cacheDataMap.remove(key);
        }
    }
    */
}
```

#### 静态内部类

- 外部类加载时并不需要立即加载静态内部类，静态内部类不被加载则不去初始化instance，故而不占内存。只有第一次调用getInstance()方法会导致虚拟机加载SingleTonHoler类，才会去初始化instance。
- 这种实现方法既保证了线程安全，又能做到延迟加载，但是由于是静态内部类的形式去创建单例的，故外部无法传递参数进去。

```java
public class SingleTon {
    private SingleTon() {}
    private static class SingleTonHoler {
        private static SingleTon instance = new SingleTon();
    }
    public static SingleTon getInstance() {
        return SingleTonHoler.instance;
    }
    
    private AtomicLong id = new AtomicLong(0);
    public long getId() {
    	return id.incrementAndGet();
    }
}
```

#### 枚举

默认枚举实例的创建是线程安全的，并且在任何情况下都是单例。实际上

- 枚举类隐藏了私有的构造器。
- 枚举类的域是相应类型的一个实例对象

```java
public enum Singleton {
    INSTANCE;
    //可以省略此方法，通过Singleton.INSTANCE进行操作
    public static Singleton getInstance() {
        return Singleton.INSTANCE;
    }
    
    private AtomicLong id = new AtomicLong(0);
    public long getId() {
    	return id.incrementAndGet();
    }
}
```

#### 替代方案

为了保证全局唯一，除了使用单例，我们还可以用静态方法来实现。

```java
// 静态方法实现方式
public class IdGenerator {
    private static AtomicLong id = new AtomicLong(0);
    
    public static long getId() {
    	return id.incrementAndGet();
    }
}

// 使用举例
long id = IdGenerator.getId();
```



#### 对象唯一

经典的单例模式是进程内唯一的，ThreadLocal 工具类，可以实现线程唯一单例，集群相当于多个进程构成的一个集合，“集群唯一”就相当于是进程内唯一、进程间也唯一。

需要把这个单例对象序列化并存储到外部共享存储区（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。

为了保证任何时刻，在进程间都只有一份对象存在，一个进程在获取到对象之后，需要对对象加锁，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁。

```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);
    private static IdGenerator instance;
    private static SharedObjectStorage storage = FileSharedObjectStorage(
    private static DistributedLock lock = new DistributedLock();
        
    private IdGenerator() {}
        
    public synchronized static IdGenerator getInstance(){
        if (instance == null) {
            lock.lock();
            instance = storage.load(IdGenerator.class);
        }
        return instance;
    }
    public synchroinzed void freeInstance() {
        storage.save(this, IdGeneator.class);
        instance = null; //释放对象
        lock.unlock();
    }
    public long getId() {
    	return id.incrementAndGet();
    }
}
// IdGenerator使用举例
IdGenerator idGeneator = IdGenerator.getInstance();
long id = idGenerator.getId();
IdGenerator.freeInstance();
```



### 工厂模式

根据条件创建不同的类

#### 简单工厂

将代码中涉及创建对象的部分剥离到一个独立的类中，生成静态方法即可；也可以事先创建存放map缓存；

```java
public class RuleConfigSource {
    public RuleConfig load(String ruleConfigFilePath) {
        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
        IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfig
        if (parser == null) {
            throw new InvalidRuleConfigException("Rule config file format is not supported: " + ruleConfigFilePath
        }
        String configText = "";
        //从ruleConfigFilePath文件中读取配置文本到configText中
        RuleConfig ruleConfig = parser.parse(configText);
            return ruleConfig;
    }
                                                 
    private String getFileExtension(String filePath) {
        //...解析文件名获取扩展名，比如rule.json，返回json
        return "json";
    }
}                                                              }
public class RuleConfigParserFactory {
    public static IRuleConfigParser createParser(String configFormat) {
        IRuleConfigParser parser = null;
        if ("json".equalsIgnoreCase(configFormat)) {
            parser = new JsonRuleConfigParser();
        } else if ("xml".equalsIgnoreCase(configFormat)) {
            parser = new XmlRuleConfigParser();
        } else if ("yaml".equalsIgnoreCase(configFormat)) {
            parser = new YamlRuleConfigParser();
        } else if ("properties".equalsIgnoreCase(configFormat)) {
            parser = new PropertiesRuleConfigParser();
        }
        return parser;
    }
}
```

```java
// RuleConfigParserFactory中存放缓存
public class RuleConfigParserFactory {
    private static final Map<String, RuleConfigParser> cachedParsers = new HashMa
    static {
        cachedParsers.put("json", new JsonRuleConfigParser());
        cachedParsers.put("xml", new XmlRuleConfigParser());
        cachedParsers.put("yaml", new YamlRuleConfigParser());
        cachedParsers.put("properties", new PropertiesRuleConfigParser());
    }
    public static IRuleConfigParser createParser(String configFormat) {
        if (configFormat == null || configFormat.isEmpty()) {
        	return null;//返回null还是IllegalArgumentException全凭你自己说了算
        }
        IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());
        return parser;
    }
}
```



#### 工厂方法

定义接口，接口中定义创建方法，再定义不同实现类；

```java
public interface IRuleConfigParserFactory {
	IRuleConfigParser createParser();
}
public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory {
    @Override
    public IRuleConfigParser createParser() {
    	return new JsonRuleConfigParser();
    }
}
public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory {
    @Override
    public IRuleConfigParser createParser() {
    	return new XmlRuleConfigParser();
    }
}
public class YamlRuleConfigParserFactory implements IRuleConfigParserFactory {
    @Override
    public IRuleConfigParser createParser() {
    	return new YamlRuleConfigParser();
    }
}
public class PropertiesRuleConfigParserFactory implements IRuleConfigParserFact
    @Override
    public IRuleConfigParser createParser() {
        return new PropertiesRuleConfigParser();
    }
}



public class RuleConfigSource {
    public RuleConfig load(String ruleConfigFilePath) {
        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
        IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getPars
        if (parserFactory == null) {
        	throw new InvalidRuleConfigException("Rule config file format is not supp
        }
        IRuleConfigParser parser = parserFactory.createParser();
        String configText = "";
        //从ruleConfigFilePath文件中读取配置文本到configText中
        RuleConfig ruleConfig = parser.parse(configText);
        return ruleConfig;
    }
    private String getFileExtension(String filePath) {
        //...解析文件名获取扩展名，比如rule.json，返回json
        return "json";
    }
}
       
                                                 
                                                 
//因为工厂类只包含方法，不包含成员变量，完全可以复用，
//不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适。
public class RuleConfigParserFactoryMap { 
    private static final Map<String, IRuleConfigParserFactory> cachedFactories =
    static {
        cachedFactories.put("json", new JsonRuleConfigParserFactory());
        cachedFactories.put("xml", new XmlRuleConfigParserFactory());
        cachedFactories.put("yaml", new YamlRuleConfigParserFactory());
        cachedFactories.put("properties", new PropertiesRuleConfigParserFactory())
    }
    public static IRuleConfigParserFactory getParserFactory(String type) {
        if (type == null || type.isEmpty()) {
            return null;
        }
        IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCa
        return parserFactory;
    }
}
```

当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，将创建逻辑写在工厂类里面

#### 抽象工厂

不同的类中有多种分类方式，并且每种方式中类定义类似，可以根据分类方式定义多个接口，最后在统一接口中定义接口数量的创建方法

```xml
分类方式：按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类

针对规则配置的解析器：基于接口IRuleConfigParser
JsonRuleConfigParser
XmlRuleConfigParser
YamlRuleConfigParser
PropertiesRuleConfigParser
针对系统配置的解析器：基于接口ISystemConfigParser
JsonSystemConfigParser
XmlSystemConfigParser
YamlSystemConfigParser
PropertiesSystemConfigParser
```

```java
// 让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser对象。
public interface IConfigParserFactory {
    IRuleConfigParser createRuleParser();
    ISystemConfigParser createSystemParser();
    //此处可以扩展新的parser类型，比如IBizConfigParser
}
public class JsonConfigParserFactory implements IConfigParserFactory {
    @Override
    public IRuleConfigParser createRuleParser() {
    	return new JsonRuleConfigParser();
    }
    @Override
    public ISystemConfigParser createSystemParser() {
        return new JsonSystemConfigParser();
    }
}
public class XmlConfigParserFactory implements IConfigParserFactory {
    @Override
    public IRuleConfigParser createRuleParser() {
        return new XmlRuleConfigParser();
    }
    @Override
    public ISystemConfigParser createSystemParser() {
    	return new XmlSystemConfigParser();
    }
}
// 省略YamlConfigParserFactory和PropertiesConfigParserFactory代码
```



### 建造者模式

创建对象，把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果一个类中有很多属性，为了避免构造函数的参数列表过长，可以将非必填属性通过 set() 方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了

- 如果必填的属性有很多
- 如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合 set() 方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。
- 如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露 set() 方法。构造函数配合 set() 方法来设置属性值的方式就不适用了

```java
public class ResourcePoolConfig {
    private String name;
    private int maxTotal;
    private int maxIdle;
    private int minIdle;
    private ResourcePoolConfig(Builder builder) {
        this.name = builder.name;
        this.maxTotal = builder.maxTotal;
        this.maxIdle = builder.maxIdle;
        this.minIdle = builder.minIdle;
    }
    //...省略getter方法...
    //我们将Builder类设计成了ResourcePoolConfig的内部类。
    //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。
    public static class Builder {
        private static final int DEFAULT_MAX_TOTAL = 8;
        private static final int DEFAULT_MAX_IDLE = 8;
        private static final int DEFAULT_MIN_IDLE = 0;
        private String name;
        private int maxTotal = DEFAULT_MAX_TOTAL;
        private int maxIdle = DEFAULT_MAX_IDLE;
        private int minIdle = DEFAULT_MIN_IDLE;
        public ResourcePoolConfig build() {
            // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等
            if (StringUtils.isBlank(name)) {
                throw new IllegalArgumentException("...");
            }
            if (maxIdle > maxTotal) {
                throw new IllegalArgumentException("...");
            }
            if (minIdle > maxTotal || minIdle > maxIdle) {
                throw new IllegalArgumentException("...");
            }
            return new ResourcePoolConfig(this);
        }
        public Builder setName(String name) {
            if (StringUtils.isBlank(name)) {
                throw new IllegalArgumentException("...");
            }
            this.name = name;
            return this;
        }
        public Builder setMaxTotal(int maxTotal) {
            if (maxTotal <= 0) {
                throw new IllegalArgumentException("...");
            }
            this.maxTotal = maxTotal;
            return this;
        }
        public Builder setMaxIdle(int maxIdle) {
            if (maxIdle < 0) {
                throw new IllegalArgumentException("...");
            }
            this.maxIdle = maxIdle;
            return this;
        }
        public Builder setMinIdle(int minIdle) {
            if (minIdle < 0) {
                throw new IllegalArgumentException("...");
            }
            this.minIdle = minIdle;
            return this;
        }
    }
}
// 这段代码会抛出IllegalArgumentException，因为minIdle>maxIdle
ResourcePoolConfig config = new ResourcePoolConfig.Builder()
    .setName("dbconnectionpool")
    .setMaxTotal(16)
    .setMaxIdle(10)
    .setMinIdle(12)
    .build();
```



### 原型模式

利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象。可以使用clone、对象序列化

```java
// 先将对象序列化，然后再反序列化成新的对象。
public Object deepCopy(Object object) {
    ByteArrayOutputStream bo = new ByteArrayOutputStream();
    ObjectOutputStream oo = new ObjectOutputStream(bo);
    oo.writeObject(object);
    
    byte[] buf = bo.toByteArray();
    ByteArrayInputStream bi = new ByteArrayInputStream(buf);
    ObjectInputStream oi = new ObjectInputStream(bi);
    return oi.readObject();
}

ObjectInputStream is = new ObjectInputStream(new FileInputStream("autologinMap.dat"));
Map<String, String[]> autologinMap = (ConcurrentHashMap<String, String[]>) is.readObject();

ObjectOutputStream os = new ObjectOutputStream(new FileOutputStream("autoAuthMap.dat"));
os.writeObject(AutoLoginMap.getInstance().getAutoLoginMap());
```



## 结构型模式

创建型模式主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。其中，单例模式用来创建全局唯一的对象。工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。原型模式针对创建成本比较大的对象，利用对已有对象进行复制的方式进行创建，以达到节省创建时间的目的。

结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。 

### 代理模式

它在不改变原始类（或叫被代理类）代码的情况下，通过引入代理类来给原始类附加功能。

#### 静态代理 

静态就是程序运行之前就已经存在代理类的字节码文件

##### 模板

```java
基于接口：		
public interface IA {
      void f();
}

public class A implements IA { // 原始类
  public void f() { //... }
}

public class AProxy implements IA { // 代理类
  private IA a;
  public AProxy(IA a) {
    this.a = a;
  }
  public void f() {
    // 新添加的代理逻辑
    a.f();
    // 新添加的代理逻辑
  }
}

基于继承：
public class A{ // 原始类
  public void f() { //... }
}
public class AProxy extend A { // 代理类
  public void f() {
    // 新添加的代理逻辑
    super.f();
    // 新添加的代理逻辑
  }
}
```

##### 样例

```java
public interface UserService {
    public void login(String username,String password);
    public String logout();
}

public class UserServiceImpl implements UserService {
    @Override
    public void login(String username, String password) {
        System.out.println("UserServiceImpl.login:"+username+","+password);
    }

	 @Override
    public String logout() {
        System.out.println("UserServiceImpl.logout");
        return "byebye";
    }
}

//代理的三要素：
//1.目标类的接口
//2.目标类的实例
//3.交叉业务逻辑，要执行的操作
//代理对象需要和目标对象实现相同的接口
public class UserServiceProxy implements UserService {
    
    private UserService userService=new UserServiceImpl();

    @Override
    public void login(String username, String password) {
        try {
            Method method = userService.getClass().getMethod("login", String.class, String.class);
            invoke(method,username,password);
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
    }

    @Override
    public String logout() {
        try {
            Method method = userService.getClass().getMethod("logout");
            return invoke(method).toString();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        }
        return null;
    }

    //封装到公共方法中，统一入口，模块化
    private Object invoke(Method method,Object...args){
        //1.打印日志
        System.out.println(method.getName()+" 启动 at:["+new Date().getTime()+"]");
        //2.执行业务
        try {
            return method.invoke(userService,args);
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
        return null;
    }
} 
 
public static void main(String[] args) {
    UserService userService=new UserServiceProxy();
    userService.login("admin","123");
    System.out.println(userService.logout());
}
```

缺点：这种实现方式很直观也很简单，但其缺点是代理对象必须提前写出

#### 动态代理

不事先为每个原始类编写代理类，而是在运行的时候，动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。代理类是程序在运行期间由JVM根据反射等机制动态生成的，自动生成代理类和代理对象 。

##### JDK动态代理

目标对象必须实现一个或多个接口，如果没有实现任何接口，则无法使用jdk的动态代理

```java
public static void main(String[] args) {
    //调用Proxy类的newProxyInstance()方法动态的生成代理类和实例
    UserService userService= (UserService) Proxy.newProxyInstance(
            UserServiceImpl.class.getClassLoader(), //目标类的类加载器
            new Class[]{UserService.class}, //目标类的接口列表
            new InvocationHandler() { //交叉业务逻辑
                @Override
                public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                    //1.打印日志
                    System.out.println(method.getName()+" login at:["+new Date().getTime()+"]");
                    //2.执行业务
                    System.out.println("开启事务。。。。");
                    Object returnValue = null;
                    try {
                        returnValue = method.invoke(new UserServiceImpl(), args);
                        System.out.println("提交事务。。。。。");
                    } catch  (Exception e) {
                        System.out.println("回滚事务。。。。。");
                        throw e; //一定要抛出异常
                    }
                    return returnValue;
                }
            }
    );

    userService.login("admin","123");
    System.out.println("-------------------------------------------------");
    System.out.println(userService.logout());
    //代理类的类型
    System.out.println(userService.getClass());
}
```

缺点：可以看出静态代理和JDK代理有一个共同的缺点，就是目标对象必须实现一个或多个接口。

##### Cglib代理

没有实现接口，CGLib采用动态创建子类的方式生成代理对象，动态创建代理实例。（所以不能对目标类中的private、final等方法进行代理）。JDK1.8中JDK代理比cglib代理性能更好

```java
public static void main(String[] args) {

	HelloWorld helloWorld = (HelloWorld) Enhancer.create(
            HelloWorld.class, //目标类的类型
            new InvocationHandler() { //交叉业务逻辑
                @Override
                public Object invoke(Object o, Method method, Object[] args) throws Throwable {
                    System.out.println(method.getName() + " start at:[" + new Date().getTime() + "]");
                    return method.invoke(new HelloWorld(), args);
                }
            }
    );

    helloWorld.sayHello();
    //代理类的类型
    System.out.println(helloWorld.getClass());
}
```



### 桥接模式

将抽象和实现解耦，让它们可以独立变化。也就是说定义两个抽象接口，同时都存在多个实现，使用组合关系将两个抽象的实现类进行桥接。

#### 模板

```java
public interface IA{
    void f1();
}
public class A1 implements IA {
    @Override
    public void f1(){
        ...
    }
}
public class A2 implements IA {
	...
}
public class A3 implements IA {
	...
}



public abstract class IB {
    protected IA a;
    public IB(IA a){
        this.a=a;
    }
    public abstract void f2();
}
public class B1 extends IB {
    public B1 (IA a) {
        super(a);
    }
    @Override
    public void f2() {
        a.f1();
    }
}
public class B2 extends IB {
	...
}
public class B3 extends IB {
	...
}
```

#### 样例

```java
如：Class.forName(“com.mysql.jdbc.Driver”) 加载及注册JDBC驱动程序，把具体的 Driver 实现类（com.mysql.jdbc.Driver）注册到 DriverManager，后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 Driver 实现类都实现了相同的接口（java.sql.Driver ）。

public class DriverManager {
    public static synchronized void registerDriver(java.sql.Driver driver) throws
	...
	}
}
JDBC 本身跟具体的数据库无关的、被抽象出来的一套“类库”<--组合-- 具体的Driver（比如:com.mysql.jdbc.Driver
```



### 装饰器模式

不改变现有对象结构的情况下，动态地给该对象增加额外功能的模式。使用组合来替代继承，装饰器类和原始类继承同样的父类，可以对原始类“嵌套”多个装饰器类。

```java
public interface IA {
  void f();
}

public class A implements IA { // 原始类
  public void f() { //... }
}

public class ADecorator implements IA { // 装饰器类
  private IA a;
  public ADecorator(IA a) {
    this.a = a;
  }

  public void f() {
	// 代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能。
    // 功能增强代码
    a.f();
    // 功能增强代码
  }
}
```



### 适配器模式

将不兼容的接口转换为可兼容的接口。适配器模式有两种实现方式：类适配器和对象适配器。其中，类适配器使用继承关系来实现，对象适配器使用组合关系来实现。

```java
// 类适配器: 基于继承
public interface ITarget {
  void f1();
  void f2();
  void fc();
}

public class Adaptee {
  public void fa() { //... }
  public void fb() { //... }
  public void fc() { //... }
}

public class Adaptor extends Adaptee implements ITarget {
  public void f1() {
    super.fa();
  }

  public void f2() {
    //...重新实现f2()...
  }

  // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点
}

// 对象适配器：基于组合
public interface ITarget {
  void f1();
  void f2();
  void fc();
}

public class Adaptee {
  public void fa() { //... }
  public void fb() { //... }
  public void fc() { //... }
}

public class Adaptor implements ITarget {
  private Adaptee adaptee;
  public Adaptor(Adaptee adaptee) {
    this.adaptee = adaptee;
  }

  public void f1() {
    adaptee.fa(); //委托给Adaptee
  }

  public void f2() {
    //...重新实现f2()...
  }

  public void fc() {
    adaptee.fc();
  }
}
```



### 门面模式

为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。假设有一个系统A，提供了a、b、c、d四个接口。系统B完成某个业务功能，需要调用A系统的a、b、d接口。利用门面模式，我们提供一个包裹a、b、d接口调用的门面接口x，给系统B直接使用。

### 组合模式

将一组对象组织（Compose）成树形结构，以表示一种“部分-整体”的层次结构。定义接口和文件目录实现类，将文件和目录对象组织成树形结构，以表示目录与子目录的嵌套结构

```java
// 将一组对象（员工和部门）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（部门与子部门的嵌套结构）。组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。
public abstract class HumanResource {
    protected long id;
    protected double salary;
    public HumanResource(long id) {
        this.id = id;
    }
    public long getId() {
        return id;
    }
    public abstract double calculateSalary();
}

public class Employee extends HumanResource {
    public Employee(long id, double salary) {
        super(id);
        this.salary = salary;
    }
    @Override
    public double calculateSalary() {
        return salary;
    }
}

public class Department extends HumanResource {
    private List<HumanResource> subNodes = new ArrayList<>();
    public Department(long id) {
        super(id);
    }
    @Override
    public double calculateSalary() {
        double totalSalary = 0;
        for (HumanResource hr : subNodes) {
            totalSalary += hr.calculateSalary();
        }
        this.salary = totalSalary;
        return totalSalary;
    }
    public void addSubNode(HumanResource hr) {
        subNodes.add(hr);
    }
}
```



### 享元模式

被共享的单元，共享对象。前提是享元对象是不可变对象。

具体来讲，当一个系统中存在大量重复对象的时候，我们就可以利用享元模式，将对象设计成享元，在内存中只保留一份实例，供多处代码引用，这样可以减少内存中对象的数量，以起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段），提取出来设计成享元，让这些大量相似对象引用这些享元。

```java
// 通过工厂模式，在工厂类中，通过一个 Map 或者 List 来缓存已经创建好的享元对象，以达到复用的目的。
public class CharacterStyle {
    private Font font;
    private int size;
    private int colorRGB;
    public CharacterStyle(Font font, int size, int colorRGB) {
        this.font = font;
        this.size = size;
        this.colorRGB = colorRGB;
    }
    @Override
    public boolean equals(Object o) {
        CharacterStyle otherStyle = (CharacterStyle) o;
        return font.equals(otherStyle.font)
            && size == otherStyle.size
            && colorRGB == otherStyle.colorRGB;
    }
}

public class CharacterStyleFactory {
    private static final List<`> styles = new ArrayList<>();
    public static CharacterStyle getStyle(Font font, int size, int colorRGB) {
        CharacterStyle newStyle = new CharacterStyle(font, size, colorRGB);
        for (CharacterStyle style : styles) {
            if (style.equals(newStyle)) {
                return style;
            }
        }
        styles.add(newStyle);
        return newStyle;
    }
}

public class Character {
    private char c;
    private CharacterStyle style;
    public Character(char c, CharacterStyle style) {
        this.c = c;
        this.style = style;
    }
}

public class Editor {
    private List<Character> chars = new ArrayList<>();
    public void appendCharacter(char c, Font font, int size, int colorRGB) {
        Character character = new Character(c, CharacterStyleFactory.getStyle(font...
		chars.add(character);
	}
}
```

```java
String s1 = "小争哥";
String s2 = "小争哥";
String s3 = new String("小争哥");
System.out.println(s1 == s2);		// true
System.out.println(s1 == s3);		// false
```

String 类利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM 会专门开辟一块存储区来存储字符串常量，这块存储区叫作“字符串常量池”。Integer 类中要共享的对象，是在类加载的时候，就集中一次性创建好的。但是，对于字符串来说，我们没法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能在某个字符串常量第一次被用到的时候，存储到常量池中，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。

## 行为型模式

### 观察者模式

也被称为发布订阅模式，在对象之间有一个一对多的关系，当一个对象状态改变的时候，所有依赖的对象都会自动收到通知。被依赖的对象叫作被观察者（Observable），依赖的对象叫作观察者（Observer）。多个对象注册，一个对象通知。

#### 模板

```java
public interface Subject {
    void registerObserver(Observer observer);
    void removeObserver(Observer observer);
    void notifyObservers(Message message);
}
public interface Observer {
    void update(Message message);
}
public class ConcreteSubject implements Subject {
    private List<Observer> observers = new ArrayList<Observer>();
    @Override
    public void registerObserver(Observer observer) {
        observers.add(observer);
    }
    @Override
    public void removeObserver(Observer observer) {
        observers.remove(observer);
    }
    @Override
    public void notifyObservers(Message message) {
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
}
public class ConcreteObserverOne implements Observer {
    @Override
    public void update(Message message) {
        //TODO: 获取消息通知，执行自己的逻辑...
        System.out.println("ConcreteObserverOne is notified.");
    }
}
public class ConcreteObserverTwo implements Observer {
    @Override
    public void update(Message message) {
        //TODO: 获取消息通知，执行自己的逻辑...
        System.out.println("ConcreteObserverTwo is notified.");
    }
}
public class Demo {
    public static void main(String[] args) {
        ConcreteSubject subject = new ConcreteSubject();
        subject.registerObserver(new ConcreteObserverOne());
        subject.registerObserver(new ConcreteObserverTwo());
        subject.notifyObservers(new Message());
    }
}
```

异步非阻塞的观察者模式可以创建一个新的线程执行观察者中的具体代码（支持异步非阻塞的 EventBus 框架）

跨进程的观察者模式基于消息队列（Message Queue，比如ActiveMQ）实现，被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。被观察者和观察者解耦更加彻底，两部分的耦合更小。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。

### 模板模式

在一个方法中定义一个业务逻辑骨架，并将某些步骤推迟到子类中实现。 模板方法定义为final，可以避免被子类重写。需要子类重写的方法定义为abstract，可以强迫子类去实现。 

模板模式主要是用来解决复用和扩展两个问题。其中，复用指的是，所有的子类可以复用父类中提供的模板方法的代码。扩展指的是，框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能。

#### 模板

```java
public abstract class AbstractClass {
    public final void templateMethod() {
        //...
        method1();
        //...
        method2();
        //...
    }
    protected abstract void method1();
    protected abstract void method2();
}
public class ConcreteClass1 extends AbstractClass {
    @Override
    protected void method1() {
        //...
    }
    @Override
    protected void method2() {
        //...
    }
}
public class ConcreteClass2 extends AbstractClass {
    @Override
    protected void method1() {
        //...
    }
    @Override
    protected void method2() {
        //...
    }
}
AbstractClass demo = ConcreteClass1();
demo.templateMethod();
```



#### 回调

A类事先注册某个函数F到B类，A类在调用B类的P函数的时候，B类反过来调用A类注册给它的F函数。这里的F函数就是“回调函数”。A调用B，B反过来又调用A，这种调用机制就叫作“回调”。 

```java
// A 类如何将回调函数传递给 B 类呢？需要使用包裹了回调函数的类对象，我们简称为回调对象。
public interface ICallback {
  void methodToCallback();
}

public class BClass {
  public void process(ICallback callback) {
    //...
    callback.methodToCallback();
    //...
  }
}

public class AClass {
  public static void main(String[] args) {
    BClass b = new BClass();
    b.process(new ICallback() { //回调对象
      @Override
      public void methodToCallback() {
        System.out.println("Call back me.");
      }
    });
  }
}
// 或者
public class AClass {
  public static void main(String[] args) {
    BClass b = new BClass();
      
    class MyCallback extends ICallback {
        @Override
        public void methodToCallback() {
            System.out.println("Call back me.");
        }
    }

    b.process(new MyCallback());
  }
}



// 回调函数 methodToCallback
// 模板函数 process
```

回调可以分为同步回调和异步回调（或者延迟回调）。同步回调指在模板函数返回之前执行回调函数；异步回调指的是在模板函数返回之后执行回调函数。

- 从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别，更像是观察者模式。

- 从代码实现上来看，回调和模板模式完全不同。**回调基于组合关系来实现**，把一个对象传递给另一个对象，是一种对象之间的关系；**模板模式基于继承关系来实现**，子类重写父类的抽象方法，是一种类之间的关系。

### 策略模式

定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。 

- 定义一个策略接口和一组实现这个接口的策略类。
- 由工厂类来创建策略，封装策略创建的细节。
- 策略模式包含一组策略可选，客户端代码如何选择使用哪个策略，有两种确定方法：编译时静态确定和运行时动态确定。

#### 模板

```java
// 策略定义
public interface Strategy {
  void algorithmInterface();
}

public class ConcreteStrategyA implements Strategy {
  @Override
  public void  algorithmInterface() {
    //具体的算法...
  }
}

public class ConcreteStrategyB implements Strategy {
  @Override
  public void  algorithmInterface() {
    //具体的算法...
  }
}


// 策略创建
public class StrategyFactory {
  private static final Map<String, Strategy> strategies = new HashMap<>();

  static {
    strategies.put("A", new ConcreteStrategyA());
    strategies.put("B", new ConcreteStrategyB());
  }

  public static Strategy getStrategy(String type) {
    if (type == null || type.isEmpty()) {
      throw new IllegalArgumentException("type should not be empty.");
    }
    return strategies.get(type);
  }
}


// 策略使用
public class UserCache {
  private Map<String, User> cacheData = new HashMap<>();
  private Strategy strategy;

  public UserCache(Strategy strategy) {
    this.strategy = strategy;
  }
    
    public void useStrategy(){
        // ...
        strategy.algorithmInterface();
        // ...
    }
  //...
}

// 运行时动态确定，根据配置文件的配置决定使用哪种策略
public class Application {
  public static void main(String[] args) throws Exception {
    Strategy strategy = null;
    Properties props = new Properties();
    props.load(new FileInputStream("./config.properties"));
    String type = props.getProperty("strategy_type");
    //
    strategy = StrategyFactory.getStrategy(type);
    UserCache userCache = new UserCache(strategy);
    userCache.useStrategy();
    //...
  }
}

// 非运行时动态确定，在代码中指定使用哪种策略
public class Application {
  public static void main(String[] args) {
    //...
    //
    Strategy strategy = new ConcreteStrategyA();
    UserCache userCache = new UserCache(strategy);
    userCache.useStrategy();  
    //...
  }
}
```

#### 样例

通过策略模式来移除 if-else 分支判断

```java
public class OrderService {
    public double discount(Order order) {
        double discount = 0.0;
        OrderType type = order.getType();
        if (type.equals(OrderType.NORMAL)) { // 普通订单
            //...省略折扣计算算法代码
        } else if (type.equals(OrderType.GROUPON)) { // 团购订单
            //...省略折扣计算算法代码
        } else if (type.equals(OrderType.PROMOTION)) { // 促销订单
            //...省略折扣计算算法代码
        }
        return discount;
    }
}
```

```java
借助“查表法”，根据 type 查表替代（代码中的strategies 就是表）根据 type 分支判断。
// 策略的定义
public interface DiscountStrategy {
    double calDiscount(Order order);
}
// 省略NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrateg
// 策略的创建
public class DiscountStrategyFactory {
    private static final Map<OrderType, DiscountStrategy> strategies = new HashMa
    static {
        strategies.put(OrderType.NORMAL, new NormalDiscountStrategy());
        strategies.put(OrderType.GROUPON, new GrouponDiscountStrategy());
        strategies.put(OrderType.PROMOTION, new PromotionDiscountStrategy());
    }
    public static DiscountStrategy getDiscountStrategy(OrderType type) {
        return strategies.get(type);
    }
}
// 策略的使用
public class OrderService {
    public double discount(Order order) {
        OrderType type = order.getType();
        DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStra...
        return discountStrategy.calDiscount(order);
    }
}
```



### 职责链模式

在职责链模式中，多个处理器依次处理同一个请求。一个请求先经过A处理器处理，然后再把请求传递给B处理器，B处理器处理完后再传递给C处理器，以此类推，形成一个链条。链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式。 

```java
// 处理器接口或抽象类
public abstract class Handler {
  // 记录下一个处理器
  protected Handler successor = null;

  public void setSuccessor(Handler successor) {
    this.successor = successor;
  }

  public final void handle() {
    boolean handled = doHandle();
    if (successor != null && !handled) {
      successor.handle();
    }
  }

  protected abstract boolean doHandle();
}

public class HandlerA extends Handler {
  @Override
  protected boolean doHandle() {
    boolean handled = false;
    //...
    return handled;
  }
}

public class HandlerB extends Handler {
  @Override
  protected boolean doHandle() {
    boolean handled = false;
    //...
    return handled;
  }
}

// 处理器链
public class HandlerChain {
  private Handler head = null;
  private Handler tail = null;

  public void addHandler(Handler handler) {
    handler.setSuccessor(null);

    if (head == null) {
      head = handler;
      tail = handler;
      return;
    }

    // 上一个handle把当前handle记录在上一个handle的successor中
    tail.setSuccessor(handler);
    tail = handler;
  }

  public void handle() {
    if (head != null) {
      head.handle();
    }
  }
}

// 使用举例
public class Application {
  public static void main(String[] args) {
    HandlerChain chain = new HandlerChain();
    chain.addHandler(new HandlerA());
    chain.addHandler(new HandlerB());
    chain.handle();
  }
}
```



### 状态模式

状态模式是状态机的一种实现方式即可。状态机又叫有限状态机，它有 3 个部分组成：状态、事件、动作。其中，事件也称为转移条件。事件触发状态的转移及动作的执行。

- 第一种实现方式叫分支逻辑法。利用 if-else 或者 switch-case 分支逻辑，参照状态转移图，将每一个状态转移原模原样地直译成代码。

- 第二种实现方式叫查表法，通过二维数组来表示状态转移图。

- 第三种实现方式叫状态模式。

  ```java
  // 使用MarioStateMachine表示状态机，包含状态(Small、Super、Cape、Fire)和分数两个属性，IMario 是状态的接口，定义了所有的事件。SmallMario、SuperMario、CapeMario、FireMario 是 IMario 接口的实现类，分别对应状态机中的 4 个状态
  // 状态机MarioStateMachine调用事件就会调用每个状态工具类中的方法做转换，同时每次把当前状态MarioStateMachine传入到每个工具类中，对状态机做处理，IMario接口和实现类既是工具类
  public interface IMario {
      State getName();
      void obtainMushRoom(MarioStateMachine stateMachine);
      void obtainCape(MarioStateMachine stateMachine);
      void obtainFireFlower(MarioStateMachine stateMachine);
      void meetMonster(MarioStateMachine stateMachine);
  }
  public class SmallMario implements IMario {
      private static final SmallMario instance = new SmallMario();
      private SmallMario() {}
      public static SmallMario getInstance() {
          return instance;
      }
      @Override
      public State getName() {
          return State.SMALL;
      }
      @Override
      public void obtainMushRoom(MarioStateMachine stateMachine) {
          stateMachine.setCurrentState(SuperMario.getInstance());
          stateMachine.setScore(stateMachine.getScore() + 100);
      }
  ......
  }
  // 省略SuperMario、CapeMario、FireMario类...
  public class MarioStateMachine {
      private int score;
      private IMario currentState;
      public MarioStateMachine() {
          this.score = 0;
          this.currentState = SmallMario.getInstance();
      }
      public void obtainMushRoom() {
          this.currentState.obtainMushRoom(this);
      }
  ......
      public int getScore() {
          return this.score;
      }
      public State getCurrentState() {
          return this.currentState.getName();
      }
      public void setScore(int score) {
          this.score = score;
      }
      public void setCurrentState(IMario currentState) {
          this.currentState = currentState;
      }
  }
  ```

### 迭代器模式

用来遍历集合对象，这里说的“集合对象”也可以叫“容器” “聚合对象”，实际上就是包含一组对象的对象。

迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及容器和容器迭代器两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类。

![image-20230405100137177](img_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20230405100137177.png)

#### 样例

```java
public interface Iterator<E> {
    boolean hasNext();
    void next();
    E currentItem();
}
public class ArrayIterator<E> implements Iterator<E> {
    private int cursor;
    private ArrayList<E> arrayList;
    public ArrayIterator(ArrayList<E> arrayList) {
        this.cursor = 0;
        this.arrayList = arrayList;
    }
    @Override
    public boolean hasNext() {
        return cursor < arrayList.size();
    }
    @Override
    public void next() {
        cursor++;
    }
    @Override
    public E currentItem() {
        if (cursor >= arrayList.size()) {
            throw new NoSuchElementException();
        }
        return arrayList.get(cursor);
    }
}



public interface List<E> {
    Iterator iterator();
}
public class ArrayList<E> implements List<E> {
    //...
    public Iterator iterator() {
        return new ArrayIterator(this);
    }
    //...
}



public class Demo {
    public static void main(String[] args) {
        List<String> names = new ArrayList<>();
        names.add("a");
        names.add("b");
        names.add("c");
        names.add("d");
        Iterator<String> iterator = names.iterator();
        iterator.next();
        names.remove("a");
    }
}
```



#### 遍历同时删除

在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。

为了保持数组存储数据的连续性，数组的删除操作会涉及元素的搬移，删除当前游标指向元素之前下标的元素，会导致之后的元素向前移动一位，所以游标原本指向的元素会被跳过遍历不到。添加元素同理，会导致游标原本指向的元素重复遍历。

```java
// 增删元素之后让遍历报错,在 Java 实现中，迭代器类是容器类的内部类，并且 next() 函数不仅将游标后移一位，还会返回当前的元素。Java 迭代器中提供的 remove() 方法，一个 next() 函数之后，只能跟着最多一个 remove() 操作，多次调用 remove() 操作会报错。
public class ArrayList<E> {
    private int modCount;//记录集合被修改的次数，集合每调用一次增加或删除元素的函数，就会给modCount 加 1
    transient Object[] elementData;
    private int size;
    public Iterator<E> iterator() {
        return new Itr();
    }
    private class Itr implements Iterator<E> {
        int cursor; // index of next element to return
        int lastRet = -1; // 记录游标指向的前一个元素 -1 if no such
        int expectedModCount = modCount;//把modCount 值传递给迭代器的 expectedModCount 成员变量，之后每次调用迭代器上的hasNext()、next()、currentItem() 函数，我们都会检查集合上的 modCount 是否等于expectedModCount
        Itr() {}

        public boolean hasNext() {
            return cursor != size;
        }

        @SuppressWarnings("unchecked")
        public E next() {
            checkForComodification();
            int i = cursor;
            if (i >= size) {
                throw new NoSuchElementException();
            }
            Object[] elementData = ArrayList.this.elementData;
            if (i >= elementData.length) {
                throw new ConcurrentModificationException();
            }
            cursor = i + 1;
            return (E) elementData[lastRet = i];
        }

        // 在遍历的同时安全地删除集合元素
        public void remove() {
            if (lastRet < 0) {
                throw new IllegalStateException();
            }
            checkForComodification();
            try {
                ArrayList.this.remove(lastRet);
                cursor = lastRet;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }
        
        @Override
        public Object currentItem() {
            checkForComodification();
            return arrayList.get(cursor);
        }
        
        private void checkForComodification() {
            if (arrayList.modCount != expectedModCount) {
                throw new ConcurrentModificationException();
            }
        }

    }
}
```

#### “快照”功能的迭代器

“快照”，指我们为容器创建迭代器的时候，相当于给容器拍了一张快照（Snapshot）。之后即便我们增删容器中的元素，快照中的元素并不会做相应的改动。

**方案一**

在迭代器类中定义一个成员变量 snapshot 来存储快照。每当创建迭代器的时候，都拷贝一份容器中的元素到快照中，后续的遍历操作都基于这个迭代器自己持有的快照来进行。

```java
public class SnapshotArrayIterator<E> implements Iterator<E> {
    private int cursor;
    private ArrayList<E> snapshot;
    public SnapshotArrayIterator(ArrayList<E> arrayList) {
        this.cursor = 0;
        this.snapshot = new ArrayList<>();
        this.snapshot.addAll(arrayList);
    }
    @Override
    public boolean hasNext() {
        return cursor < snapshot.size();
    }
    @Override
    public E next() {
        E currentItem = snapshot.get(cursor);
        cursor++;
        return currentItem;
    }
}
```



**方案二**

在容器中，为每个元素保存两个时间戳，一个是添加时间戳 addTimestamp，一个是删除时间戳 delTimestamp。当元素被加入到集合中的时候，我们将 addTimestamp设置为当前时间，将 delTimestamp 设置成最大长整型值（Long.MAX_VALUE）。当元素被删除时，我们将 delTimestamp 更新为当前时间，表示已经被删除。

每个迭代器也保存一个迭代器创建时间戳 snapshotTimestamp，也就是迭代器对应的快照的创建时间戳。当使用迭代器来遍历容器的时候，只有满足addTimestamp<snapshotTimestamp<delTimestamp 的元素，才是属于这个迭代器的快照。

```java
public class ArrayList<E> implements List<E> {
    private static final int DEFAULT_CAPACITY = 10;
    private int actualSize; //不包含标记删除元素
    private int totalSize; //包含标记删除元素
    private Object[] elements;
    private long[] addTimestamps;
    private long[] delTimestamps;
    public ArrayList() {
        this.elements = new Object[DEFAULT_CAPACITY];
        this.addTimestamps = new long[DEFAULT_CAPACITY];
        this.delTimestamps = new long[DEFAULT_CAPACITY];
        this.totalSize = 0;
        this.actualSize = 0;
    }
    @Override
    public void add(E obj) {
        elements[totalSize] = obj;
        addTimestamps[totalSize] = System.currentTimeMillis();
        delTimestamps[totalSize] = Long.MAX_VALUE;
        totalSize++;
        actualSize++;
    }
    @Override
    public void remove(E obj) {
        for (int i = 0; i < totalSize; ++i) {
            if (elements[i].equals(obj)) {
                delTimestamps[i] = System.currentTimeMillis();
                actualSize--;
            }
        }
    }
    public int actualSize() {
        return this.actualSize;
    }
    public int totalSize() {
        return this.totalSize;
    }
    public E get(int i) {
        if (i >= totalSize) {
            throw new IndexOutOfBoundsException();
        }
        return (E)elements[i];
    }
    public long getAddTimestamp(int i) {
        if (i >= totalSize) {
            throw new IndexOutOfBoundsException();
        }
        return addTimestamps[i];
    }
    public long getDelTimestamp(int i) {
        if (i >= totalSize) {
            throw new IndexOutOfBoundsException();
        }
        return delTimestamps[i];
    }
}
```

```java
public class SnapshotArrayIterator<E> implements Iterator<E> {
    private long snapshotTimestamp;
    private int cursorInAll; // 在整个容器中的下标，而非快照中的下标
    private int leftCount; // 快照中还有几个元素未被遍历
    private ArrayList<E> arrayList;
    public SnapshotArrayIterator(ArrayList<E> arrayList) {
        this.snapshotTimestamp = System.currentTimeMillis();
        this.cursorInAll = 0;
        this.leftCount = arrayList.actualSize();;
        this.arrayList = arrayList;
        justNext(); // 先跳到这个迭代器快照的第一个元素
    }
    @Override
    public boolean hasNext() {
        return this.leftCount >= 0; // 注意是>=, 而非>
    }
    @Override
    public E next() {
        E currentItem = arrayList.get(cursorInAll);
        justNext();
        return currentItem;
    }
    private void justNext() {
        while (cursorInAll < arrayList.totalSize()) {
            long addTimestamp = arrayList.getAddTimestamp(cursorInAll);
            long delTimestamp = arrayList.getDelTimestamp(cursorInAll);
            if (snapshotTimestamp > addTimestamp && snapshotTimestamp < delTimestamp)
                leftCount--;
            break;
        }
        cursorInAll++;
    }
}
}
```





### 访问者模式

允许一个或者多个操作应用到一组对象上，解耦操作和对象本身。 

```java
public abstract class ResourceFile {
    protected String filePath;
    public ResourceFile(String filePath) {
        this.filePath = filePath;
    }
    abstract public void accept(Visitor vistor);
}

public class PdfFile extends ResourceFile {
    public PdfFile(String filePath) {
        super(filePath);
    }

    @Override
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }

    //...
}
//...PPTFile、WordFile跟PdfFile类似，这里就省略了...

public interface Visitor {
    void visit(PdfFile pdfFile);
    void visit(PPTFile pdfFile);
    void visit(WordFile pdfFile);
}

public class Extractor implements Visitor {
    @Override
    public void visit(PPTFile pptFile) {
        //...
        System.out.println("Extract PPT.");
    }

    @Override
    public void visit(PdfFile pdfFile) {
        //...
        System.out.println("Extract PDF.");
    }

    @Override
    public void visit(WordFile wordFile) {
        //...
        System.out.println("Extract WORD.");
    }
}

public class Compressor implements Visitor {
    @Override
    public void visit(PPTFile pptFile) {
        //...
        System.out.println("Compress PPT.");
    }

    @Override
    public void visit(PdfFile pdfFile) {
        //...
        System.out.println("Compress PDF.");
    }

    @Override
    public void visit(WordFile wordFile) {
        //...
        System.out.println("Compress WORD.");
    }

}

public class ToolApplication {
    public static void main(String[] args) {
        Extractor extractor = new Extractor();
        List<ResourceFile> resourceFiles = listAllResourceFiles(args[0]);
        for (ResourceFile resourceFile : resourceFiles) {
            resourceFile.accept(extractor);
        }

        Compressor compressor = new Compressor();
        for(ResourceFile resourceFile : resourceFiles) {
            resourceFile.accept(compressor);
        }
    }

    private static List<ResourceFile> listAllResourceFiles(String resourceDirectory) {
        List<ResourceFile> resourceFiles = new ArrayList<>();
        //...根据后缀(pdf/ppt/word)由工厂方法创建不同的类对象(PdfFile/PPTFile/WordFile)
        resourceFiles.add(new PdfFile("a.pdf"));
        resourceFiles.add(new WordFile("b.word"));
        resourceFiles.add(new PPTFile("c.ppt"));
        return resourceFiles;
    }
}

// 原始：ResourceFile资源文件接口，多个资源文件类PdfFile、WordFile、PPTFile，当文件类里面存在抽取文本内容，支持压缩、提取文件元信息（文件名、大小、更新时间等等）构建索引等一系列的功能，过于臃肿提取抽象方法
// 提取多个资源类型的一种功能方法单独成为一个功能类，功能类中多个重载方法，传入资源文件类参数区分，由于重载方法参数根据参数声明判断，extractor.handle(resourceFile)无法识别resourceFile，需要使用accept中转，将直接调用extractor中方法移动到resourceFile中，同时将resourceFile传入extractor，也就是resourceFile.accept(extractor);extractor.handle(this)；
// Visitor功能接口，多个功能实现类Extractor、Compressor
```

**Single Dispatch**，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的编译时类型来决定。所谓**Double Dispatch**，双分派，指的是执行哪个对象的方法，根据对象的运行时类型来决定；执行对象的哪个方法，根据方法参数的运行时类型来决定。 

Single”“Double”指的是执行哪个对象的哪个方法，跟几个因素的运行时类型有关。 

### 备忘录模式

也叫快照模式，具体来说，就是在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。这个模式的定义表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。 

```java
// 在InputText类中不能定义setText()函数，不能暴露不应该暴露的函数，把setText()方法重命名为restoreSnapshot()方法
public class InputText {
    private StringBuilder text = new StringBuilder();

    public String getText() {
        return text.toString();
    }

    public void append(String input) {
        text.append(input);
    }

    public Snapshot createSnapshot() {
        return new Snapshot(text.toString());
    }

    public void restoreSnapshot(Snapshot snapshot) {
        this.text.replace(0, this.text.length(), snapshot.getText());
    }
}

// 快照本身是不可变的，所以不应该包含任何set()等修改内部状态的函数
public class Snapshot {
    private String text;

    public Snapshot(String text) {
        this.text = text;
    }

    public String getText() {
        return this.text;
    }
}

public class SnapshotHolder {
    private Stack<Snapshot> snapshots = new Stack<>();

    public Snapshot popSnapshot() {
        return snapshots.pop();
    }

    public void pushSnapshot(Snapshot snapshot) {
        snapshots.push(snapshot);
    }
}

public class ApplicationMain {
    public static void main(String[] args) {
        InputText inputText = new InputText();
        SnapshotHolder snapshotsHolder = new SnapshotHolder();
        Scanner scanner = new Scanner(System.in);
        while (scanner.hasNext()) {
            String input = scanner.next();
            if (input.equals(":list")) {
                System.out.println(inputText.toString());
            } else if (input.equals(":undo")) {
                Snapshot snapshot = snapshotsHolder.popSnapshot();
                inputText.restoreSnapshot(snapshot);
            } else {
                // 存取文本全量快照
                snapshotsHolder.pushSnapshot(inputText.createSnapshot());
                inputText.append(input);
            }
        }
    }
}
```



















































## 项目实际使用

### 工厂模式应用

```java
// 定义统一接口
public interface TemplateRegisterService {
    void registerTemplate(ConfigRegisterDomain config);
}

// 定义实现类的接口降低耦合
public interface DataProductTemplateService extends TemplateRegisterService {}

public interface APITemplateService extends TemplateRegisterService {}
```

```java
// 实现统一接口，可以将抽取的公共方法放在这里
@Service
@Slf4j
public class TemplateRegisterServiceImpl implements TemplateRegisterService {
    @Autowired
    private TemplateHistoryService templateHistoryService;
    
    @Override
    public void registerTemplate(ConfigRegisterDomain config) {
        log.error("use the correct implementation class.");
    }

    public void handleRegisterResult(String batchNo, String templatePath,
        List<List<String>> responseLists, String feedbackName) {
        TemplateHistoryVO templateHistoryVO = TemplateRegisterUtils.getTemplateRegisterInfo(batchNo);
        ......
    }
}
```

```java
@Service
@Slf4j
public class DataProductTemplateServiceImpl extends TemplateRegisterServiceImpl implements DataProductTemplateService {
    @Override
    public void registerTemplate(ConfigRegisterDomain config) {
        ......
        super.handleRegisterResult(
                config.getBatchNo(), config.getTemplatePath(), responseLists, AppConstant.FEEDBACK_NAME_DATAPRODUCT);
    }
}

@Service
@Slf4j
public class APITemplateServiceImpl extends TemplateRegisterServiceImpl implements APITemplateService {
    @Override
    public void registerTemplate(ConfigRegisterDomain config) {
        ......
        super.handleRegisterResult(config.getBatchNo(), config.getTemplatePath(), responseLists,
            AppConstant.FEEDBACK_NAME_API);
    }
}
```

```java
// 代码调用
TemplateRegisterService templateRegisterService;
switch (assetType) {
    case AppConstant.MODEL_ASSETTYPE:
        templateRegisterService = SpringUtils.getBean(DataModelTemplateService.class);
        break;
    case AppConstant.REPORT_ASSETTYPE:
        templateRegisterService = SpringUtils.getBean(ReportTemplateService.class);
        break;
    case AppConstant.API_ASSETTYPE:
        templateRegisterService = SpringUtils.getBean(APITemplateService.class);
        break;
    case AppConstant.DATAPRODUCT_ASSETTYPE:
        templateRegisterService = SpringUtils.getBean(DataProductTemplateService.class);
        break;
    default:
        templateRegisterService = null;
        break;
}
templateRegisterService.registerTemplate(config);
```

```java
@Component
public class SpringUtils implements ApplicationContextAware {
    private static ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        if (SpringUtils.applicationContext == null) {
            SpringUtils.applicationContext = applicationContext;
        }
    }

    // 获取applicationContext
    public static ApplicationContext getApplicationContext() {
        return applicationContext;
    }

    public static Object getBean(String name) {
        return getApplicationContext().getBean(name);
    }

    public static <T> T getBean(Class<T> clazz) {
        return getApplicationContext().getBean(clazz);
    }

    public static <T> T getBean(String name, Class<T> clazz) {
        return getApplicationContext().getBean(name, clazz);
    }
}
```

### 原型模式应用

[BeanUtils](https://blog.csdn.net/Munger6/article/details/103196595)



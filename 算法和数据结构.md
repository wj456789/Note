# 算法和数据结构

## 数据结构

> 数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。
>
> 通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。

数据结构包括数据的逻辑结构、数据的存储结构以及数据的运算；

- 逻辑结构有：集合结构、线性结构、树形结构和图状结构。
- 物理结构有：线性存储结构和非线性存储结构，线性存储结构(线性表)有顺序(顺序表)、链式(链表)、索引和散列4种结构；非线性存储结构有树形存储结构、图形存储结构。
  - 顺序使用连续地址空间存储元素
  - 链式中指针指向下一个元素地址
  - 索引使用索引表存放元素地址
  - 散列通过散列算法计算地址

线性表有栈，队列，实现方式可以是顺序表也可以是链表；顺序表有数组；非线性存储结构有树、堆、图。

集合中ArrayList是顺序表，LinkedList是链表；

### 数组

- 数组是静态的，一个数组实例具有固定的大小，一旦创建了就无法改变容量了。而集合是可以动态扩展容量，可以根据需要动态改变大小。

- 数组的存放的类型中`Object[]`可以存放多种类型，其他只能是一种（基本类型/引用类型）；集合存放的类型可以不是一种(不加泛型时添加的类型是Object，取出时转换成自己的类型就行了)，但是添加泛型时只能是一种。

#### 稀疏数组

> 所谓稀疏数组就是数组中大部分的内容值都未被使用（或都为零），在数组中仅有少部分的空间使用。因此造成内存空间的浪费，为了节省内存空间，并且不影响数组中原有的内容值，我们可以采用一种压缩的方式来表示稀疏数组的内容。

假设有一个9*7的数组，其内容如下：

![clipboard (5)](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard%20(5).png)

在此数组中，共有63个空间，但却只使用了5个元素，造成58个元素空间的浪费。

以下我们就使用稀疏数组重新来定义这个数组：

![clipboard (6)](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard%20(6).png)

在稀疏数组中第一部分所记录的是原数组的列数和行数以及元素使用的个数；

第二部分所记录的是原数组中元素的位置和内容；

经过压缩之后，原来需要声明大小为63的数组，而使用压缩后，只需要声明大小为6*3的数组，仅需18个存储空间。

```java
public class TestArray {
    public static void main(String[] args) {
        /*
        Integer[][] arr=new Integer[9][7];
        arr[1][1]=3;
        ...
        */

        Node[] nodes=new Node[6];
        nodes[0]=new Node(9,7,5);
        nodes[1]=new Node(1,1,3);
        nodes[2]=new Node(3,0,1);
        nodes[3]=new Node(3,1,4);
        nodes[4]=new Node(4,2,7);
        nodes[5]=new Node(5,5,5);

        for(int i=0;i<nodes[0].getRow();i++){
            for(int j=0;j<nodes[0].getCol();j++){
                int k;
                for(k=1;k<nodes.length;k++){
                    if(nodes[k].getRow()==i&&nodes[k].getCol()==j){
                        System.out.print(nodes[k].getVal()+"   ");
                        break;
                    }
                }
                if(k==nodes.length){
                    System.out.print("0   ");
                }
            }
            System.out.println("");
        }
    }
}

@Data
@AllArgsConstructor
class Node{
    private int row;
    private int col;
    private int val;
}

输出：
0   0   0   0   0   0   0   
0   3   0   0   0   0   0   
0   0   0   0   0   0   0   
1   4   0   0   0   0   0   
0   0   7   0   0   0   0   
0   0   0   0   0   5   0   
0   0   0   0   0   0   0   
0   0   0   0   0   0   0   
0   0   0   0   0   0   0
```

### 链表

> 链表是一种线性表，在每一个节点里存到下一个节点的指针(Pointer)，

#### 单向链表

> 一个单链表的节点(Node)分为两个部分，第一个部分(data)保存或者显示关于节点的信息，另一个部分存储下一个节点的地址。最后一个节点存储地址的部分指向空值。链表有一个头节点。

输出：[D->C->B->A]

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1652799105762.png)

#### 用单向链表实现栈

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1652970462872.png)

#### 双端链表

多了对尾节点的引用

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1653314848344.png)

#### 用双端链表实现队列

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1653574602259.png)

#### 有序链表

链表中的数据有序，这称为有序链表。在有序链表中，数据是按照关键值有序排列的。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1653314969403.png)

在有序链表中插入和删除某一项最多需要O(N)次，平均需要O(N/2)次，优先级队列可以使用有序链表来实现。



### 抽象数据类型（ADT）

抽象是抽取出事物具有的普遍性本质，是对事物的一个概括，是一种思考问题的方式。

**抽象数据类型（ADT）是指一个数学模型及定义在该模型上的一组操作。**它仅取决于其逻辑特征，而与计算机内部如何表示和实现无关。

比如整型，各个计算机，不管大型机、小型机、PC、平板电脑甚至智能手机，都有“整型”类型，也需要整型运算，那么整型其实就是一个抽象数据类型。 

比如栈，对于使用者只需要知道 pop() 和 push() 方法或其它方法的存在以及如何使用即可，使用者不需要知道我们是使用数组或是链表中那种结构来实现的。

#### 实现具有迭代器的单链表

让链表本身实现迭代功能，代替我们用循环去遍历链表里的所有节点数据

1、定义一个ListInterface<T>接口（相当于一个ADT），指定了单链表中的各种基本操作：

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1653576279645.png)



2、定义ListWithIteratorInterface<T> 接口并 extends ListInterface<T>

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1653576334540.png)

3、定义了一个类LinkListWithIterator<T> 实现了ListWithIteratorInterface<T>  接口（相当于ADT的实现类），LinkListWithIterator<T> 中定义了一个内部类：IteratorForLinkedList，该内部类 implements Iterator<T>

通过LinkListWithIterator<T> 的对象调用 getIterator() 获得一个迭代器，而该迭代器类又是LinkListWithIterator<T> 的内部类，即可以直接迭代LinkListWithIterator的数据域。**LinkListWithIterator<T> 就表示一个带有迭代器的单链表了。**

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1653576392109.png)











### 栈

<img src="img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211114160624460.png" alt="image-20211114160624460" style="zoom:80%;" />

> **栈**（英语：stack）又称为**堆栈**或**堆叠，**栈作为一种数据结构，是一种**只能在一端进行插入和删除操作的特殊线性表**。先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据（最后一个数据被第一个读出来）。

允许进行插入和删除操作的一端称为栈顶(top)，另一端为栈底(bottom)；栈中元素个数为零时称为空栈。插入一般称为进栈（PUSH），删除则称为退栈（POP）。

#### 数组实现栈

```java
public class TestStack {
    public static void main(String[] args) {
        MyStack myStack=new MyStack();
        myStack.push(1);
        myStack.push(2);
        myStack.push(3);
        myStack.push(4);
        myStack.push(5);
        myStack.push(6);
        myStack.push(7);
        myStack.push(8);
        myStack.push(9);
        myStack.push(10);
        myStack.push(11);

        while(!myStack.isEmpty()){
            System.out.println(myStack.pop());
        }
    }
}

class MyStack{
    private Object[] data;  //栈内部封装的数组，用来保存压入栈的数据元素
    private int maxSize;    //栈的最大长度
    private int top;        //变量始终指向栈顶第一个元素，栈是空栈，默认值是-1

    //初始化栈
    public MyStack(){
        data=new Object[10];
        this.maxSize=10;
        top=-1;
    }

    //压栈
    public void push(Object o){
        if(top==maxSize-1){
            if((maxSize<<1)>Integer.MAX_VALUE){
                maxSize=Integer.MAX_VALUE;
            }else {
                maxSize=maxSize<<1;
            }
            //扩容
            data= Arrays.copyOf(data,maxSize);
        }
        data[++top]=o;
    }

    //获取栈顶元素值
    public Object peek(){
        if(top==-1){
            throw new EmptyStackException();
        }
        return data[top];
    }

    //实现出栈
    public Object pop(){
        Object obj=peek();
        data[top--]=null;
        return obj;
    }

    //判断是不是空栈
    public boolean isEmpty(){
        return (top==-1);
    }

    //判断是不是满栈
    public boolean isFull(){
        return (top==maxSize-1);
    }
}
```

#### 利用栈判断分隔符是否匹配

> 写过xml标签或者html标签的，**我们都知道<必须和最近的>进行匹配，[ 也必须和最近的 ] 进行匹配。**
>
> 比如：<abc[123]abc>这是符号相匹配的，如果是 <abc[123>abc] 那就是不匹配的。
>
> 对于 12<a[b{c}]>，我们分析在栈中的数据：遇到匹配正确的就消除

```java
public static void main(String[] args) {
    String str="12<a[b{c}]>";
    char[] chars = str.toCharArray();
    Stack<Character> stack=new Stack<>();

    char ch;
    boolean flag=true;
    for(char c:chars){
        if(c=='<'||c=='['||c=='{'){
            stack.push(c);
        }
        if(c=='>'||c==']'||c=='}'){
            if(!stack.isEmpty()){
                char pop = stack.pop();
                if(!(c=='>'&&pop=='<'||c==']'&&pop=='['||c=='}'&&pop=='{')){
                    System.out.println("左符号"+pop+"和右符号"+c+"不匹配");
                    flag=false;
                }
            }else {
                //左边符号多余
                System.out.println("左符号"+c+"无匹配");
                flag=false;
                break;
            }
        }
    }

    //右边符号多余
    if(flag&&!stack.isEmpty()){
        flag=false;
        while(!stack.isEmpty()){
            System.out.println("右符号"+stack.pop()+"无匹配");
        }
    }

    if(flag){
        System.out.println("匹配成功");
    }
}
```

### 队列

#### 常用队列

**Queue**

根接口

```java
public interface Queue<E> extends Collection<E> {
    boolean add(E e);
	E remove();
    
    boolean offer(E e);
    E poll();
    
    E peek();
}
```

**ArrayDeque**

数组实现的双端队列

![image-20220215192353286](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220215192353286.png)

**LinkedList**

链表实现的双端队列

![image-20220215192423210](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220215192423210.png)

**ArrayBlockingQueue**

数组实现的优先单向队列

![image-20220215192453673](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220215192453673.png)

**LinkedBlockingDeque**

链表实现的优先双端队列

![image-20220215192516089](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220215192516089.png)

##### 队列应用

```java
public static void main(String[] args) {
    Deque<String> list = new LinkedList<>();
    list.addFirst("1");
    list.addLast("2");
    list.removeFirst();
    list.removeLast();

    list.offerFirst("3");
    list.offerLast("4");
    list.pollFirst();
    list.pollLast();

    //push 和 pop都在头部操作
    list.push("5");
    list.pop();

    list.add("6");//尾部添加
    list.remove();//头部删除

    list.offer("7");//尾部添加
    list.poll();//头部删除
    
    //ArrayDeque使用和LinkedList完全相同，但是常当作栈来使用
    Deque<String> arrayDeque=new ArrayDeque<>();
    arrayDeque.push("1");
    arrayDeque.pop();
}
```



#### 队列原理

> 队列（queue）是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列中没有元素时，称为空队列。队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。
>

队列分为：

- 单向队列（Queue）：只能在一端插入数据，另一端删除数据。
- 双向队列（Deque）：每一端都可以进行插入数据和删除数据操作。
- 优先级队列（Priority Queue），优先级队列是比栈和队列更专用的数据结构，在优先级队列中，数据项按照关键字进行排序，关键字最小（或者最大）的数据项往往在队列的最前面，而数据项在插入的时候都会插入到合适的位置以确保队列的有序。

##### 单向循环队列

```java
public class TestQueue {
    public static void main(String[] args) {
        MyQueue myQueue=new MyQueue(3);
        myQueue.insert(1);
        myQueue.insert(2);
        myQueue.insert(3);

        System.out.println(myQueue.peekFront());
        myQueue.remove();
        System.out.println(myQueue.peekFront());

        myQueue.insert(4);
        myQueue.insert(5);
    }
}

class MyQueue{
    private Object[] queArray;
    //队列总大小
    private int maxSize;
    //前端
    private int front;
    //尾端
    private int rear;
    //队列中元素的实际数目
    private int nItems;

    public MyQueue(int size){
        maxSize=size;
        queArray=new Object[maxSize];
        //虽然初始状态不同，始终指向第一个和最后一个元素
        front=0;
        rear=-1;
        nItems=0;
    }

    public void insert(int value){
        if(isFull()){
            System.out.println("队列已满");
        }else {
            //队尾已满，循环回来指向队列的第一个元素
            if(rear==maxSize-1){
                rear=-1;
            }
            queArray[++rear]=value;
            nItems++;
        }
    }

    public Object remove(){
        Object removeValue=null;
        if(!isEmpty()){
            removeValue=queArray[front];
            queArray[front++]=null;
            if(front==maxSize){
                front=0;
            }
            nItems--;
        }
        return removeValue;
    }

    //查看队头数据
    public Object peekFront(){
        return queArray[front];
    }

    public boolean isFull(){
        return (nItems==maxSize);
    }

    public boolean isEmpty(){
        return (nItems==0);
    }

    public int getSize(){
        return nItems;
    }
}
```

##### 双端队列

> 双端队列就是一个两端都是结尾或者开头的队列， 队列的每一端都可以进行插入数据项和移除数据项，这些方法可以叫做：`addFirst()、addLast()、removeFirst()、removeLast()`

- 双端队列内部维护着"头部下标"、"尾部下标"。**头部下标**指向的是**队列中第一位元素**，**尾部下标**指向的是**下一个尾部元素插入的位置**。

- 当头部元素入队时，头部下标向左移动一位；头部元素出队时，头部下标向右移动一位。

  当尾部元素入队时，尾部下标向右移动一位；尾部元素出队时，尾部下标向左移动一位。

- 下标从数组第0位时，向左移动一位，会跳转到数组的最后一位。下标从数组最后一位时，向右移动一位，会跳转到数组的第0位。

  下标越界时的跳转操作，在细节上是通过下标取模实现的。

**取模计算：**

在jdk中基于数组的双端队列实现中，强制保持内部数组容量为2的平方(初始化时容量为2^4^=16，每次自动扩容容量 * 2)，因此其取模运算可以通过按位与(&)运算来加快计算速度。

```java
System.out.println((15 + 1) & (16 - 1));
System.out.println((0 - 1) & (16 - 1));

System.out.println((15 + 1) %16);
System.out.println((0 + 15) %16);

输出：
0
15
0
15
```

```java
//ArrayDeque
public void addLast(E e) {
    if (e == null) throw new NullPointerException();
    elements[tail] = e;
    if ( (tail = (tail + 1) & (elements.length - 1)) == head ) doubleCapacity();
}

public void addFirst(E e) {
    if (e == null) throw new NullPointerException();
    elements[head = (head - 1) & (elements.length - 1)] = e;
    if (head == tail) doubleCapacity();
}

public E pollFirst() {
    int h = head;
    E result = (E) elements[h];
    // Element is null if deque empty
    if (result == null) return null;
    elements[h] = null;     // Must null out slot
    head = (h + 1) & (elements.length - 1);
    return result;
}

public E pollLast() {
    int t = (tail - 1) & (elements.length - 1);
    E result = (E) elements[t];
    if (result == null) return null;
    elements[t] = null;
    tail = t;
    return result;
}
```



**扩容操作：**

只有在队列为空时，头部下标才会和尾部下标重合；而当插入新的入队元素之后，使得头部下标等于尾部下标时，说明内部数组的容量已经达到了极限，需要进行扩容才能容纳更多的元素。

1. 将"头部下标"直至"当前内部数组尾部"的元素按照顺序整体复制到新扩容数组的起始位置(**红色背景的元素**)

2. 将"当前内部数组头部"直至"尾部下标"的元素按照顺序整体复制到新扩容数组中(位于第一步操作复制的数据区间之后)(**蓝色背景的元素**)

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard.png)

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1644927033455.png)

```java
//ArrayDeque
private void doubleCapacity() {
    assert head == tail;
    int p = head;
    int n = elements.length;
    int r = n - p; // number of elements to the right of p
    int newCapacity = n << 1;
    if (newCapacity < 0) throw new IllegalStateException("Sorry, deque too big");
    Object[] a = new Object[newCapacity];
    System.arraycopy(elements, p, a, 0, r);
    System.arraycopy(elements, 0, a, r, p);
    elements = a;
    head = 0;
    tail = n;
}
```

##### 优先级队列

在优先级队列中，数据项按照关键字进行排序，关键字最小（或者最大）的数据项往往在队列的最前面，而数据项在插入的时候都会插入到合适的位置以确保队列的有序。对于优先权相同的元素，可按先进先出次序处理或按任意优先权进行。

**数组实现优先级队列，声明为int类型的数组，关键字是数组里面的元素，在插入的时候按照从大到小的顺序排列，也就是越小的元素优先级越高。**

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1645184663792.png)

### 集合

#### ArrayList

<img src="img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20211114160523563.png" alt="image-20211114160523563" style="zoom:80%;" />

```java
//将arr1数组里从索引为2的元素开始, 复制到数组arr2里的索引为5的位置, 复制的元素个数为10个.
System.arrayCopy( arr1, 2, arr2, 5, 10);

//扩容1.5倍
newSize=arr.length+(arr.length>>1);
arr=Arrays.copyOf(arr,newSize);
```

```java
class MyArrayList{
    private Object[] arr;
    private int nElems;//数组的真实长度

    //初始化
    public MyArrayList(){
        //其中ArrayList初始容量也是10
        arr=new Object[10];
        nElems=0;
    }

    //添加
    public void add(Object o){
        if(nElems==arr.length){
            arr=Arrays.copyOf(arr,arr.length+(arr.length>>1));
        }
        arr[nElems++]=o;
    }

    //删除
    public void delete(Object o){
        int i=0;
        //找出该元素在数组中的下标i
        //if(找到了)
        System.arraycopy(arr,i+1,arr,i,nElems-1-i);
        arr[nElems--]=0;
    }
}
```

### 算术表达式

**前缀表达式，中缀表达式，后缀表达式：这三种表达式其实就是算术表达式的三种写法，以 3+4-5为例**

- 前缀表达式：操作符在操作数的前面，是一种没有括号的算术表达式，例如，- 1 + 2 3，它等价于1-(2+3)
- 中缀表达式：操作符在操作数的中间，这也是人类最容易识别的算术表达式 3+4-5
- 后缀表达式：操作符在操作数的后面，是一种没有括号的算术表达式，比如 3 4+5-，等价于(3+4)-5

#### 后缀表达式

后缀表达式，指的是不包含括号，运算符放在两个运算对象的后面，所有的计算按运算符出现的顺序，严格从左向右进行（不再考虑运算符的优先规则）。

*从左到右扫描，遇到运算符取出运算符前两位操作数计算，将结果放入表达式，循环计算*

**如何将中缀表达式转换为后缀表达式**

对于这个问题，转换的规则如下：

1. 初始化两个栈：运算符栈s1，中间结果栈s2

2. 从左到右扫描表达式

3. 遇到操作数压入s2

4. 遇到运算符，比较其与s1栈顶运算符的优先级

   a、如果s1栈不是空的，并且栈顶元素不是“（ ”  并且优先级比栈顶元素相等或还小就弹出s1栈顶的元素，压入s2栈

   b、否则，就直接压入栈s1，循环判断a

5. 遇到括号

   a、遇到左括号（  ，直接压入s1栈

   b、遇到有括号  ），依次弹出s1栈顶的元素，压入s2栈，知道遇到左括号为止，然后将这对括号丢掉

6. 重复2-5，扫描完所有表达式

7. 将s1中剩余的运算符压入s2栈

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1646350408170.png)

### 树

树（tree）是一种抽象数据类型（ADT），是由n（n>0）个有限节点通过连接它们的边组成一个具有层次关系的集合。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657325345293.png)



- 节点：上图的圆圈，都是表示节点。在java面向对象编程中，**节点一般代表对象**。
- 边：连接节点的线称为边，边表示节点的关联关系。在**Java当中通常表示引用**。

每个节点最多只能有两个子节点的树称为二叉树，一个节点有多余两个的子节点的树，称为多路树。

#### 常用术语

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657325641978.png)

- **路径**：顺着节点的边从一个节点走到另一个节点，所经过的节点的顺序排列就称为“路径”。
- **根**：树顶端的节点称为根。一棵树只有一个根，如果要把一个节点和边的集合称为树，那么从根到其他任何一个节点都必须有且只有一条路径。A是根节点。
- **父节点**：若一个节点含有子节点，则这个节点称为其子节点的父节点；B是D的父节点。
- **子节点**：一个节点含有的子树的根节点称为该节点的子节点；D是B的子节点。
- **兄弟节点**：具有相同父节点的节点互称为兄弟节点；比如上图的D和E就互称为兄弟节点。
- **叶节点**：没有子节点的节点称为叶节点，也叫叶子节点，比如上图的H、E、F、G都是叶子节点。
- **子树**：每个节点都可以作为子树的根，它和它所有的子节点、子节点的子节点等都包含在子树中。
- **节点的层次**：从根开始定义，根为第0层，根的子节点为第1层，以此类推。（根也可以定义为第一层）
- **高度**：对于任意节点n,n的高度为从n到一片树叶的最长路径长；在树中，树的高度也是从下往上数。
- **深度**：对于任意节点n,n的深度为从根到n的唯一路径长；

#### 二叉搜索树

二叉树的子节点称为 “左子节点” 和 “右子节点” 。上图的D,E分别是B的左子节点和右子节点。

二叉搜索树 (binary search tree)：也称为二叉排序树，任意一个节点的左子树上所有结点的值均小于它的根结点的值，右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为二叉排序树。

##### 节点类

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657326029072.png)



##### 二叉树的类

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657326127700.png)

##### 插入节点

必将在最底层的空节点插入，不会插入中间

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657326151251.png)

##### 遍历树

遍历树是根据一种特定的顺序访问树的每一个节点。比较常用的有前序遍历，中序遍历和后序遍历。而二叉搜索树最常用的是中序遍历。

- 中序遍历：左子树——>根节点——>右子树

- 前序遍历：根节点——>左子树——>右子树

- 后序遍历：左子树——>右子树——>根节点

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657326239252.png)

##### 查找最大值和最小值

要找最小值，先找根的左节点，然后一直找这个左节点的左节点，直到找到没有左节点的节点，那么这个节点就是最小值。同理要找最大值，一直找根节点的右节点，直到没有右节点，则就是最大值。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657326275519.png)





##### 删除节点　

删除节点是二叉搜索树中最复杂的操作，删除的节点有三种情况，前两种比较简单，但是第三种却很复杂。

- 该节点是叶节点（没有子节点）
- 该节点有一个子节点
- 该节点有两个子节点

**①、删除没有子节点的节点**

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657326428757.png)

**②、删除有一个子节点的节点**

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657326436709.png)

**③、删除有两个子节点的节点**

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657326442183.png)

**④、删除有必要吗？**

可以不用真正的删除该节点，只需要在Node类中增加一个标识字段isDelete，当该字段为true时，表示该节点已经删除，反之没有删除。那么我们在做比如find()等操作的时候，要先判断isDelete字段是否为true。这样删除的节点并不会改变树的结构。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657326467171.png)

##### 二叉搜索树的效率

　　二叉树在查找、插入或删除节点等操作的时间复杂度在O(N)和O(lgN)之间，这取决于树的不平衡程度。

　　树的查找、删除、添加操作都有很高的效率。

　　遍历可能不如其他操作快，但是在大型数据库中，遍历是很少使用的操作，它更常用于程序中的辅助算法来解析算术或其它表达式。

#### 用数组表示树

用数组表示树，那么节点是存在数组中的，节点在数组中的位置对应于它在树中的位置。下标为 0 的节点是根，下标为 1 的节点是根的左子节点，以此类推，按照从左到右的顺序存储树的每一层。树中的每个位置，无论是否存在节点，都对应于数组中的一个位置，树中没有节点的在数组中用 0 或者 null 表示。

　　假设节点的索引值为 index，那么节点的左子节点是 `2*index+1`，节点的右子节点是 `2*index+2`，它的父节点是 `（index-1）/2`。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657326756598.png)



#### 红黑树

平衡二叉树：是二叉排序树，任何一个节点的左子树或者右子树高度差小于等于 1 ；

红-黑树是一棵平衡树，保证每个节点的左子树节点个数和右子树节点个数尽量相等；对一个要插入或删除的数据项，检查会不会破坏树的特征，如果破坏了，程序就会进行纠正，根据需要改变树的结构，从而保持树的平衡。

##### 特征

- 每个节点不是红色就是黑色的；
- 根节点总是黑色的；
- 如果节点是红色的，则它的子节点必须是黑色的（反之不一定），也就是从每个叶子到根的所有路径上不能有两个连续的红色节点；
- 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。

**新插入的节点颜色总是红色的**

##### 自我修正

红-黑树主要通过三种方式对平衡进行修正，改变节点颜色、左旋和右旋。

**①、改变节点颜色**

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657414853225.png)

新插入的节点为15，一般新插入颜色都为红色，那么我们发现直接插入会违反规则3，改为黑色却发现违反规则4。这时候我们将其父节点颜色改为黑色，父节点的兄弟节点颜色也改为黑色。通常其祖父节点50颜色会由黑色变为红色，但是由于50是根节点，所以我们这里不能改变根节点颜色。

**②、右旋**

首先要说明的是节点本身是不会旋转的，旋转改变的是节点之间的关系，选择一个节点作为旋转的顶端，如果做一次右旋，这个顶端节点会向下和向右移动到它右子节点的位置，它的左子节点会上移到它原来的位置。右旋的顶端节点必须要有左子节点。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657414964325.png)

**③、左旋**

左旋的顶端节点必须要有右子节点。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657414912079.png)



##### 左旋和右旋的实现

自下而上：每次从下层节点开始处理，单个边先处理由子节点指向父节点，再处理从父节点指向子节点

**①、节点类，在二叉树的基础上升级**

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657415065441.png)

**②、左旋的具体实现**

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657415182706.png)

**③、右旋的具体实现**　

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657415383378.png)

##### 插入操作

和普通二叉树插入操作相比，插入后可能会导致树的不平衡，主要是分情况讨论，分析何时变色，何时左旋，何时右旋。其余不变。

- 如果是第一次插入，由于原树为空，所以只会违反红-黑树的规则2，所以只要把根节点涂黑即可；

- 如果插入节点的父节点是黑色的，那不会违背红-黑树的规则，什么也不需要做；

- 但是遇到如下情况，我们就要开始变色和旋转了：

  **当插入节点的父亲为祖父的左儿子：**

  1. 插入节点的父亲和叔叔都是红色，将父亲和叔叔变成黑色，祖父变成红色；不满足红黑树规则继续对节点进行调整；

  2. 调整当前节点，父亲为祖父的左儿子，插入节点的父亲是红色，叔叔是黑色，自己是父亲的右儿子：以父节点为支点左旋；不满足红黑树规则继续对节点进行调整；

  3. 调整当前节点，父亲为祖父的左儿子，插入节点的父亲是红色，叔叔是黑色，自己是父亲的左儿子：将父节点涂黑，将祖父节点涂红，以祖父节点为支点做右旋操作，最后把根节点涂黑；此时节点不满足条件，可以退出循环。

  总结： 父叔同色，只进行变色操作；父叔异色，自己是右儿子，则进行LR操作；父叔异色，自己是左儿子，则进行R操作

  **PS：**

  当前节点为此时父子同为红色的子节点；

  如果是从情况1开始发生的，必然会走完情况2和3，也就是说这是一整个流程，当然咯，实际中可能不一定会从情况1发生，如果从情况2开始发生，那再走个情况3即可完成调整，如果直接只要调整情况3，那么前两种情况均不需要调整了。故变色和旋转之间的先后关系可以表示为：变色->左旋->右旋。

  **当插入节点的父亲为祖父的右儿子：**

  1. 父叔同色，只进行变色操作
  2. 父叔异色，自己是左儿子，则进行RL操作

  3. 父叔异色，自己是右儿子，则进行L操作

  这里变色和旋转之间的先后关系可以表示为：变色->右旋->左旋。

###### 案例图解

使用N,P,G,U表示关联的节点。N(now)表示当前节点，P(parent)表示N的父节点，U(uncle)表示N的叔叔节点，G(grandfather)表示N的祖父节点。

初始情况如下图：插入节点的父节点和其叔叔节点均为红色。这里考虑父节点是其祖父节点的左子节点的情况

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657418224823.png)



情况1：要做的操作有：将当前节点(4) 的父节点(5) 和叔叔节点(8) 涂黑，将祖父节点(7)涂红，再将当前节点指向其祖父节点，再次从新的当前节点开始算法。这样就变成情况2了。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657418378714.png)



情况2：插入节点的父节点是红色的，叔叔节点是黑色的，且插入节点是其父节点的右子节点。我们要做的操作有，将当前节点(7)的父节点(2)作为新的节点，以新的当前节点为支点做左旋操作。这样就变成情况3了。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657418434879.png)

情况3：插入节点的父节点是红色，叔叔节点是黑色，且插入节点是其父节点的左子节点。我们要做的操作有，将当前节点的父节点(7)涂黑，将祖父节点(11)涂红，在祖父节点为支点做右旋操作。最后把根节点涂黑，整个红-黑树重新恢复了平衡，如下图所示。至此，插入操作完成！

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657418506747.png)



###### 代码

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657415431708.png)



![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657418779985.png)



##### 红黑树的效率

红黑树的查找、插入和删除时间复杂度都为O(lgN)，额外的开销是每个节点的存储空间都稍微增加了一点，一是存储红黑树节点的颜色变量，二是要进行旋转，平均一次插入大约需要一次旋转，因此插入的时间复杂度还是O(lgN)，但实际上比普通的二叉树是要慢的。

大多数应用中，查找的次数比插入和删除的次数多，所以应用红黑树取代普通的二叉搜索树总体上不会有太多的时间开销。而且红黑树的优点是对于有序数据的操作不会慢到O(N)的时间复杂度。





[红黑树详解](https://blog.csdn.net/u014454538/article/details/120120216)

#### 234树

2-3-4树，它是一种多叉树，它的每个节点最多有三个数据项和四个子节点。名字中 2,3,4 的数字含义是指一个节点可能含有的子节点的个数。对于非叶节点有三种可能的情况：

①、有一个数据项的节点总是有两个子节点；

②、有二个数据项的节点总是有三个子节点；

③、有三个数据项的节点总是有四个子节点；

简而言之，非叶节点的子节点数总是比它含有的数据项多1。如果子节点个数为L，数据项个数为D，那么：L = D + 1

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657934087803.png)

叶节点（上图最下面的一排）是没有子节点的，然而它可能含有一个、两个或三个数据项。空节点是不会存在的。

树结构中很重要的一点就是节点之间关键字值大小的关系。由于2-3-4树中一般不允许出现重复关键值，所以不用考虑比较关键值相同的情况。（考虑就是大于等于）

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657934184656.png)



##### 插入

①、当插入没有满数据项的节点时是很简单的，找到合适的位置，只需要把新数据项插入就可以了，插入可能会涉及到在一个节点中移动一个或其他两个数据项，这样在新的数据项插入后关键字值仍保持正确的顺序。如下图：

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657934360651.png)

②、如果往下寻找插入位置的途中，有节点中的数据项是满的，节点必须分裂，分裂能保证2-3-4树的平衡。

把要分裂的数据项设为A,B,C，下面是节点分裂的情况（假设分裂的节点不是根节点）：

###### 节点分裂

  一、创建一个新的空节点，它是要分裂节点的兄弟，在要分裂节点的右边，数据项C移到新节点中；

  二、数据项B移到要分裂节点的父节点中；

  三、数据项A保留在原来的位置；

  四、最右边的两个子节点从要分裂处断开，连到新节点上。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657934552859.png)

另一种说法是**4-节点变成两个 2- 节点**。分裂节点后插入新数据，从而保持了树的平衡。一般插入只需要分裂一个节点，除非插入路径上存在不止一个满节点时，这种情况就需要多重分裂。

###### 根的分裂

如果一开始查找插入节点时就碰到满的根节点，那么插入过程更复杂：

1. 创建新的根节点，它是要分裂节点的父节点。
2. 创建第二个新的节点，它是要分裂节点的兄弟节点；
3. 数据项C移到新的兄弟节点中；
4. 数据项B移到新的根节点中；
5. 数据项A保留在原来的位置；
6. 要分裂节点最右边的两个子节点断开连接，连到新的兄弟节点中。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1657934623138.png)

分裂完成之后，整个树的高度加1。另外一种描述根分裂的方法是说**4-节点变成三个2-节点**。

##### 代码实现

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1660440397221.png)



#### 234树和红黑树

一个可以通过应用一些简单的规则变成另一个，而且使他们保持平衡的操作也是一样，数学上称他们为同构。

##### 对应规则

应用如下三条规则可以将2-3-4树转化为红黑树：

一、把2-3-4树中的每个2-节点转化为红-黑树的黑色节点。

二、把每个3-节点转化为一个子节点和一个父节点，子节点有两个自己的子节点：W和X或X和Y。父节点有另一个子节点：Y或W。哪个节点变成子节点或父节点都无所谓。子节点涂成红色，父节点涂成黑色。

三、把每个4-节点转化为一个父节点和两个子节点。第一个子节点有它自己的子节点W和X；第二个子节点拥有子节点Y和Z。和前面一样，子节点涂成红色，父节点涂成黑色。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1660440904127.png)



下图是一颗2-3-4树转化成对应的红-黑树。虚线环绕的子树是由3-节点和4-节点变成的。转化后符合红-黑树的规则，根节点为红色，两个红色节点不会相连，每条从根到叶节点的路径上的黑节点个数是一样的。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1660440915612.png)

##### 操作等价

不仅红-黑树的结构与2-3-4树对应，而且两种树操作也一样。2-3-4树用节点分裂保持平衡，红-黑树用颜色变换和旋转保持平衡。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1660440943453.png)

上图是4-节点分裂。虚线环绕的部分等价于4-节点。颜色变换之后，40,60节点都为黑色的，50节点是红色的。因此，节点 50 和它的父节点70 对于3-节点，如上图虚线所示。

#### 234 树的效率

分析2-3-4树我们可以和红黑树作比较分析。红-黑树的层数（平衡二叉树）大约是lg(N+1)，而2-3-4树每个节点可以最多有4个数据项，如果节点都是满的，那么高度和log4 N。因此在所有节点都满的情况下，2-3-4树的高度大致是红-黑树的一半。不过他们不可能都是满的，所以2-3-4树的高度大致在 lg(N+1) 和 lg(N+1)/2。减少2-3-4树的高度可以使它的查找时间比红-黑树的短一些。

但是另一方面，每个节点要查看的数据项就多了，这会增加查找时间。因为节点中用线性搜索来查看数据项，使得查找时间的倍数和M成正比，即每个节点数据项的平均数量。总的查找时间和M*log4 N成正比。

### 哈希表

#### 概念

　  哈希表本质是依赖数组实现的，又和一般的数组不同，通过把保存的数据项本身映射到数组的某个下标来。数组、链表等数据结构查找某个数据项，通常要遍历整个数据结构，也就是O(N)的时间级，但是对于哈希表来说，只是O(1)的时间级。

　**数据项和索引，或者说数组下标一一对应**

建立数据项和数组下标的关系：取余，举个例子：我们假设要把从0-199的数字（用largeNumber表示），压缩为从0-9的数字（用smallNumber表示），后者有10个数，所以变量smallRange 的值为10，这个转换的表达式为：

　　arrayIndex = largerNumber % smallRange 

**这也就是哈希函数。它把一个大范围的数字压缩成一个小范围的数字（哈希化），这个小范围的数对应着数组的下标。使用哈希函数向数组插入数据后，这个数组就是哈希表。**



把巨大的数字范围压缩到较小的数字范围，那么肯定会有几个不同的单词哈希化到同一个数组下标，即产生了**冲突**。当冲突产生时，一个方法是通过系统的方法找到数组的一个空位，并把这个单词填入，而不再用哈希函数得到数组的下标，这种方法称为**开放地址法**。另一种方法，就是数组的每个数据项都创建一个子链表或子数组，那么数组内不直接存放单词，当产生冲突时，新的数据项直接存放到这个数组下标表示的链表中，这种方法称为**链地址法**。

#### 开放地址法

开放地址法中，若数据项不能直接存放在由哈希函数所计算出来的数组下标时，就要寻找其他的位置。分别有三种方法：线性探测、二次探测以及再哈希法。

##### 线性探测

线性的查找空白单元，数组下标依次递增，直到找到空白的位置。这就叫做线性探测，因为它沿着数组下标一步一步顺序的查找空白单元。

###### 自实现代码

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1666913089268.png)



需要注意的是，当哈希表变得满时，我们需要扩展数组，但是，数据项不能放到新数组中和老数组相同的位置，而是要根据数组大小重新计算插入位置。这是一个比较耗时的过程，所以一般我们要确定数据的范围，给定好数组的大小，而不再扩容。

　　另外，当哈希表变得比较满时，我们每插入一个新的数据，都要频繁的探测插入位置，因为可能很多位置都被前面插入的数据所占用了，这称为聚集。数组填的越满，聚集越可能发生。

**装填因子**

已填入哈希表的数据项和表长的比率叫做装填因子，比如有10000个单元的哈希表填入了6667 个数据后，其装填因子为 0.6667。

装填因子越大，集聚越大，越影响哈希表的性能。

##### 二次探测

 　二测探测是防止聚集产生的一种方式，探测相距较远的单元，而不是和原始位置相邻的单元。

​	线性探测中，如果哈希函数计算的原始下标是x, **线性探测**就是x+1, x+2, x+3, 以此类推；**而在二次探测中**，探测的过程是x+1, x+4, x+9, x+16，以此类推，到原始位置的距离是步数的平方。二次探测虽然消除了原始的聚集问题，但是产生了另一种更细的聚集问题，叫二次聚集。二次聚集的原因是，二测探测的算法产生的探测序列步长总是固定的：1，4，9，16以此类推。

##### 再哈希法

　　为了消除原始聚集和二次聚集，我们使用另外一种方法：再哈希法。

　　产生一种依赖关键字的探测序列，而不是每个关键字都一样，那么，不同的关键字即使映射到相同的数组下标，也可以使用不同的探测序列。

　　方法是把关键字用不同的哈希函数再做一遍哈希化，用这个结果作为步长。

**第一个哈希函数计算索引值，第二个哈希函数计算探索步长**

**第二个哈希函数必须具备如下特点：**

- 和第一个哈希函数不同

- 不能输出0（否则，将没有步长，每次探测都是原地踏步，算法将陷入死循环）。

  专家们已经发现下面形式的哈希函数工作的非常好：

  `stepSize = constant - key % constant`; 其中constant是质数，且小于数组容量。

- 再哈希法要求表的容量是一个质数

  假如表长度为15(0-14)，有一个特定关键字映射到0，步长为5，则探测序列是0,5,10,0,5,10,以此类推一直循环下去。算法只尝试这三个单元，所以不可能找到某些空白单元，最终算法导致崩溃。如果数组容量为13, 质数，探测序列最终会访问所有单元。即0,5,10,2,7,12,4,9,1,6,11,3,一直下去，只要表中有一个空位，就可以探测到它。

###### 自实现代码

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1666913823250.png)

#### 链地址法

　　在哈希表每个单元中设置链表，某个数据项的关键字值还是像通常一样映射到哈希表的单元，而数据项本身插入到这个单元的链表中。其他同样映射到这个位置的数据项只需要加到链表中，不需要在原始的数组中寻找空位。

##### 自实现代码

有序链表：

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1666913931431.png)

链地址法：

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1666913905499.png)

链地址法中，需要有N个单元的数组中转入N个或更多的数据项，因此装填因子一般为1，或比1大（有可能某些位置包含的链表中包含两个或两个以上的数据项）。

找到初始单元需要O(1)的时间级别，而搜索链表的时间与M成正比，M为链表包含的平均项数，即O(M)的时间级别。

#### 桶

　　另外一种方法类似于链地址法，它是在每个数据项中使用子数组，而不是链表。这样的数组称为桶。

　　这个方法显然不如链表有效，因为桶的容量不好选择，如果容量太小，可能会溢出，如果太大，又造成性能浪费，而链表是动态分配的，不存在此问题。所以一般不使用桶。

#### 总结

　　哈希表基于数组，类似于key-value的存储形式，关键字值通过哈希函数映射为数组的下标，如果一个关键字哈希化到已占用的数组单元，这种情况称为冲突。用来解决冲突的有两种方法：开放地址法和链地址法。在开发地址法中，把冲突的数据项放在数组的其它位置；在链地址法中，每个单元都包含一个链表，把所有映射到同一数组下标的数据项都插入到这个链表中。



### 堆

- **完全二叉树**：一棵二叉树至多只有最下面的一层上的结点的度数可以小于2，并且最下层上的结点都集中在该层最左边的若干位置上，而在最后一层上，右边的若干结点缺失的二叉树，则此二叉树成为完全二叉树。

- **用数组来实现**：假设节点的索引值为index，那么：

  节点的左子节点是 2*index+1，

  节点的右子节点是 2*index+2，

  节点的父节点是 （index-1）/2。

- **堆中的每一个节点的关键字都大于（或等于）这个节点的子节点的关键字。**

堆是弱序的，不支持遍历和查找，不过能够快速的移除最大（或最小）节点，也就是根节点，以及能够快速插入新的节点

**移除**

移除是指删除关键字最大的节点（或最小），也就是根节点。根节点在数组中的索引总是0，即maxNode = heapArray[0];

1. 移走根
2. 把最后一个节点移动到根的位置
3. 一直向下筛选这个节点，直到它在一个大于它的节点之下，小于它的节点之上为止。

**插入**

插入时，选择向上筛选，节点初始时插入到数组最后第一个空着的单元，数组容量大小增一。然后进行向上筛选的算法。

#### 自实现代码

![image-20221111071815326](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20221111071815326.png)



#### 堆排序

堆排序是一种**选择排序，**它的平均时间复杂度均为O(nlogn)。

堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次大值。如此反复执行，便能得到一个有序序列了。（大顶堆父节点大于子节点的值，小顶堆父节点小于子节点的值）

1. 将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;

   从最后一个非叶子结点开始（叶结点自然不用调整，最后一个非叶子结点 arr.length-1-1/2，也就是最后一个节点的父结点），从右至左，从下至上进行调整，调整每个节点只向下调整。

2. 将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;

3. 剩余元素重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。

##### 自实现代码

![image-20221111072730632](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20221111072730632.png)









## 算法

> 按照某种逻辑关系组织起来的一批数据，按一定的方式把它存放在计算机的内存里，在这个基础上为了实现某个功能（比如查找某个元素，删除某个元素，给所有元素排序等等）而进行的一些列操作，我们把这一些列的操作步骤描述出来就是算法。

**时间复杂度和空间复杂度是衡量算法优劣的重要指标：**

- 时间复杂度：是用程序执行的次数来衡量，不是程序执行的时间。

- 空间复杂度：用程序执行所需要的最大内存。

其中基本操作执行次数的函数 T(n)，若存在函数 f(n)，使得当n趋近于无穷大时，T(n)/ f(n)的极限值为不等于零的常数，则称 f(n)是T(n)的同数量级函数。

记作 T(n)= O(f(n))，称O(f(n)) 为算法的**渐进时间复杂度**，简称**时间复杂度**。渐进时间复杂度用大写O来表示，所以也被称为**大O表达式**。

**大O表达式                                     算法的好坏**

O(1) 												最好					大O常数阶

O(logn) 										  比较好				大O对数阶

O(n)                                                良好					大O线性阶

O(n^2)                                            不好					大O平方阶

O(n^3)                                            很不好				

O(2^n)                                            很很不好

O(n!)                                               最不好



**比如：**

> 给小灰一条长16寸的面包，小灰每5天吃掉面包剩余长度的一半，第一次吃掉8寸，第二次吃掉4寸，第三次吃掉2寸......那么小灰把面包吃得只剩下1寸，需要多少天呢？
>
> 这个问题翻译一下，就是数字16不断地除以2，除几次以后的结果等于1？这里要涉及到数学当中的对数，以2位底，16的对数，可以简写为lg16。
>
> 因此，把面包吃得只剩下1寸，需要 5 X lg16 = 5 X 4 = 20 天。
>
> 如果面包的长度是 N 寸呢？
>
> 需要 5 X lgN = 5lgN天，记作 T(n) = 5lgN

```java
void eat2(int n){
   for(int i=1; i<n; i*=2){     
       System.out.println("等待一天");
       System.out.println("等待一天");
       System.out.println("等待一天");
       System.out.println("等待一天");
       System.out.println("吃一半面包");
   }
}
```

程序的设计中要不就是时间换空间，要不就是用空间去换时间。并且时间和空间是可以进行相互转化的；我们在程序当中，请求分页，请求分段，都属于用时间去换空间。在项目当中使用各种缓存技术，都属于利用空间去换时间。

### 查找算法

> 有序数组的二分查找

```java
public int find(Integer[] array,int searchKey){
    int lowerBound=0;
    int upperBound=array.length-1;
    int curIn;

    while(true){
        curIn=(lowerBound+upperBound)/2;
        if(array[curIn]== searchKey){
            return curIn;
        }else if(lowerBound>upperBound){
            return array.length;
        }else{
            if(array[curIn]<searchKey){
                lowerBound=curIn+1;
            }else {
                upperBound=curIn-1;
            }
        }
    }
}
```



### 排序算法

#### 时间复杂度

![image-20220529195052097](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20220529195052097.png)

注：

- 归并排序每次递归都要用到一个辅助表，长度与待排序的表长度相同，虽然递归次数是O(log2n)，但每次递归都会释放掉所占的辅助空间，
- 快速排序空间复杂度只是在通常情况下才为O(log2n)，如果是最坏情况的话，很显然就要O(n)的空间了。当然，可以通过随机化选择pivot来将空间复杂度降低到O(log2n)。

#### 冒泡排序

```java
public static void main(String[] args) {
    Integer[] is=new Integer[]{2,3,1};
    bubSort(is);
    System.out.println(Arrays.asList(is));
}

public static void bubSort(Integer[] array){
    int outer;	//冒泡出来的元素放置的下标位置，从后向前 
    int inner;
    for(outer=array.length-1;outer>=1;outer--){
        for(inner=0;inner<outer;inner++){
            if(array[inner]>array[inner+1]){	//前面的元素比后面大，交换位置
                int temp=array[inner];
                array[inner]=array[inner+1];
                array[inner+1]=temp;
            }
        }
    }
}
```

#### 选择排序

```java
public static void selectSort(Integer[] array){
    int outer;	//选择出来的元素放置的下标位置，从前向后
    int inner;
    int min;

    for(outer=0;outer<array.length-1;outer++){
        min=outer;	//每次循环初始化min指向outer的位置，剩下的元素中的第一个
        for(inner=outer+1;inner<=array.length-1;inner++){
            if(array[inner]<array[min]){
                min=inner;
            }
        }//每次循环完成后，min指向的元素才是真正最小元素
        
        if(min!=outer){
            int temp=array[min];
            array[min]=array[outer];
            array[outer]=temp;
        }
    }
}
```



#### 插入排序

```java
public static void insertSort(Integer[] array){
    int outer;	//指向需要插入的元素
    int inner;	//指向outer之前元素
    int temp;

    //数列中每一个数和它前面的数据比较，如果inner指向的数较大，数往后移位，inner向前遍历,直到inner指向的数较小，在这之后插入这个数
    for(outer=1;outer<=array.length-1;outer++){
        inner=outer-1;
        temp=array[outer];
        while(inner>=0&&array[inner]>temp){	//从小到大
            array[inner+1]=array[inner];
            inner--;
        }
        array[inner+1]=temp;
    }
}
```



```java
public static void main(String[] args) {
    int[] array=new int[]{1,67,9,32,54,7,12};
    sort(array);
    for(int i:array){
        System.out.println(i);
    }
}

//数列中每一个数和它前面的所有数据比较，如果前面的数较大，往后移位，直到前面的数较小，在这之后插入这个数
public static void sort(int[] array){
    int preIndex;
    int current;
    for(int i=1;i<=array.length-1;i++){
        preIndex=i-1;
        current=array[i];
        while(preIndex>=0&&array[preIndex]>current){
            array[preIndex+1]=array[preIndex];
            preIndex--;
        }
        array[preIndex+1]=current;
    }
}
```

#### 希尔排序

也是一种插入排序

将数组按照增量分组，对每组使用直接插入排序算法排序，初始增量gap=length/2，然后缩小增量gap=gap/2，直到增量为1将整个数组分为一组

如100个数据，先分为100/2=50组，每组2个值，每组分别排序

​						  再分为50/2=25组，每组4个值

​						  再分为25/2=12组，每组9或8个值

​						  ...

​						  最后分为2/2=1组，100为一组整体排序

```java
public static void main(String[] args) {
    int[] array=new int[]{1,67,9,32,54,7,12};
    sort(array);
    for(int i:array){
        System.out.println(i);
    }
}

public static void sort(int[] array){
    int gap=array.length/2;
    while(gap>0){
        int preIndex;
        int current;
        for(int i=gap;i<=array.length-1;i++){
            preIndex=i-gap;
            current=array[i];
            while(preIndex>=0&&array[preIndex]>current){
                array[preIndex+gap]=array[preIndex];
                preIndex-=gap;
            }
            array[preIndex+gap]=current;
        }
        gap/=2;
    }
}
```

##### 详解

希尔排序通过加大插入排序中元素的间隔，并在这些有间隔的元素中进行插入排序，从而使数据项能够大跨度的移动。

**排序间隔选取：**

间隔序列中的数字互质是很重要的指标，也就是说，除了1，他们没有公约数。这个约束条件使得每一趟排序更有可能保持前一趟排序已经排好的结果，而希尔最初以 N/2 的间隔的低效性就是没有遵守这个准则。

- 常用的间隔序列：间隔序列用 step 表示，从 1 开始计算间隔序列 step\*3 + 1，最大间隔不大于 len/3 ，之后在计算中每次循环后间隔 (step-1)/3，如对于n=100的数组，最大间隔不大于 100/3=33.33 ，则序列为 1、4、13
- 当前最优的间隔序列：用 2.2 来整除每一个间隔，如对于n=100的数组，会产生序列45，20，9,4,1。

**无论是什么间隔序列，最后必须满足一个条件，就是逐渐减小的间隔最后一定要等于1，因此最后一趟排序一定是简单的插入排序。**

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1653826154462.png)



![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1653826158740.png)





#### 快速排序

对于一个数列进行排序，比基准小的放在基准前，比基准大的放在基准后，然后再将小于基准的子序列和大于基准的子序列递归排序

```java
public static void main(String[] args) {
    int[] array=new int[]{1,67,9,32,54,7,12};
    quickSort(array, 0, array.length - 1);
    for(int i:array){
        System.out.println(i);
    }
}

public static void quickSort(int[] array,int start,int end){
    if(start>=end){
        return;
    }else{
        int patition = patition(array, start, end);
        if(patition>start){
            quickSort(array,start,patition-1);
        }
        if(patition<end){
            quickSort(array,patition+1,end);
        }
    }
}

//选开始值为基准，从前开始找到大于基准的坐标，从后开始找到小于基准的坐标，将两个值交换，然后在两个坐标之间继续循环，直到从后开始的坐标小于从前开始的坐标
public static int patition(int[] array,int start,int end){
    int i=start;
    int j=end+1;
    int pivot=array[start];		//pivot为基准值
    while(true){
        while(i<end&&array[++i]<pivot){}	//取大于基准的坐标
        while(j>start&&array[--j]>pivot){}	//取小于基准的坐标
        if(i>=j){
            break;
        }else{
            swap(array,i,j);
        }
    }
    swap(array,j,start);
    return j;
}

public static int[] swap(int[] array,int i,int j){
    int temp=array[i];
    array[i]=array[j];
    array[j]=temp;
    return array;
}
```

##### 详解

1. 先通过第一趟排序，将数组原地划分为两部分**，**其中一部分的所有数据都小于另一部分的所有数据**。**原数组被划分为2份
2. 通过递归的处理， 再对原数组分割的两部分分别划分为两部分，同样是使得其中一部分的所有数据都小于另一部分的所有数据。 这个时候原数组被划分为了4份
3. 就1,2被划分后的最小单元子数组来看，它们仍然是无序的，但是！ 它们所组成的原数组却逐渐向有序的方向前进。
4. 这样不断划分到最后，数组就被划分为多个由一个元素或多个相同元素组成的单元，这样数组就有序了。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1655294002301.png)







![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1655294047495.png)



最坏性能（worst case behavior）和插入排序相同，也是O(n^2)，对快速排序来说，拥有两个大小相等的子数组是最优的情况。

**三项取中划分**

为了找到一个数组中的中值数据，一般是取数组中第一个、中间的、最后一个，选择这三个数中位于中间的数。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1655294128431.png)



当数组长度较小时，使用快速排序是比较耗时的，当数组长度小于 M 的时候（high-low <= M）， 不进行快排，而进行插入排序。一般来说， M 可以为5到15间的任意值。

































#### 归并排序

归并算法的中心是归并两个已经有序的数组。归并两个有序数组A和B，就生成了第三个有序数组C。数组C包含数组A和B的所有数据项。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1648339685703.png)

### 递归

#### 定义

递归，就是在运行的过程中调用自己。

一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解

递归必须要有三个要素：

- 边界条件
- 递归前进段
- 递归返回段

当边界条件不满足时，递归前进；当边界条件满足时，递归返回。

一个递归方法每次都是用不同的参数值反复调用自己，当某种参数值使得递归的方法返回，而不再调用自身，这种情况称为边界值，也叫基值。当递归方法返回时，递归过程通过逐渐完成各层方法实例的未执行部分，而从最内层返回到最外层的原始调用处。

#### 求一个数的阶乘：n!

> n! = n\*(n-1)\*(n-2)\*......1
>
> 规定：
>
> 0！=1
>
> 1！=1
>
> 负数没有阶乘

n! = n\*(n-1)！

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1648250795099.png)



#### 计算数字三角形的路径

> 7              
>
> 3 8           
>
> 8 1 0        
>
> 2 7 4 4      
>
> 4 5 2 6 5
>
> 在上面的数字三角形中寻找一条从顶部到底边的路径，使得路径上所经过的数字之和最大。路径上的每一步都只能往下或右下走。只需要求出这个最大和即可，不必给出具体路径。 
>
> 三角形的行数大于1小于等于100，数字为 0 - 99

**输入格式：** 

5 //三角形行数。下面是三角形 

7 

3 8 

8 1 0 

2 7 4 4 

4 5 2 6 5

**解题思路：**

用二维数组存放数字三角形

`D[r][j]` //表示第i行第j个元素的数值；

`maxSum(i,j)` //表示从根部到第i行最大路径的，所有数值的最大和；

用递归的思想，在 `D(i,j)` 位置，下一个能走的位置为 `D(i+1,j)` 和 `D(i+1,j+1)`，进行递归

`MaxSum(i,j)=max(MaxSum(i+1,j),MaxSum(i+1,j+1))+D[i][j];`

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1648250865053.png)



#### 递归的二分查找

注意：二分查找的数组一定是有序的！！！

在有序数组array[]中，不断将数组的中间值（mid）和被查找的值比较，如果被查找的值等于array[mid],就返回下标mid; 否则，就将查找范围缩小一半。如果被查找的值小于array[mid], 就继续在左半边查找;如果被查找的值大于array[mid], 就继续在右半边查找。 直到查找到该值或者查找范围为空时， 查找结束。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1648251909165.png)

**递归的二分查找和非递归的二分查找效率都为O(logN)**



#### 汉诺塔问题

> 汉诺塔问题是由很多放置在三个塔座上的盘子组成的一个古老的难题。如下图所示，所有盘子的直径是不同的，并且盘子中央都有一个洞使得它们刚好可以放在塔座上。所有的盘子刚开始都放置在A 塔座上。这个难题的目标是将所有的盘子都从塔座A移动到塔座C上，每次只可以移动一个盘子，并且任何一个盘子都不可以放置在比自己小的盘子之上。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1648337733772.png)



无论有多少个盘子，我们都将其看做只有两个盘子。假设有 N 个盘子在塔座A上，我们将其看为两个盘子，其中(N-1)~1个盘子看成是一个盘子，最下面第N个盘子看成是一个盘子，那么解决办法为：

　　①、先将A塔座的第(N-1)~1个盘子看成是一个盘子，放到中介塔座B上，然后将第N个盘子放到目标塔座C上。

　　②、然后A塔座为空，看成是中介塔座，B塔座这时候有N-1个盘子，将第(N-2)~1个盘子看成是一个盘子，放到中介塔座A上，然后将B塔座的第(N-1)号盘子放到目标塔座C上。

　　③、这时候A塔座上有(N-2)个盘子，B塔座为空，又将B塔座视为中介塔座，重复①，②步骤，直到所有盘子都放到目标塔座C上结束。 实质上这种递归我们又叫：双递归函数

第一次递归将 n-1 个盘子从原塔座放到中间塔座上，然后将第 n 个盘子从原塔座放到目标塔座上

第二次递归将 n-1 个盘子从中间塔座放到目标塔座上

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1648337800822.png)

#### 递归实现归并排序

归并排序的思想是把一个数组分成两半，排序每一半，然后将数组的两半归并成为一个有序的数组。如何来为每一部分排序呢？用递归：

　　把每一半都分为四分之一，对每个四分之一进行排序，然后把它们归并成一个有序的一半。类似的，如何给每个四分之一数组排序呢？把每个四分之一分成八分之一，对每个八分之一进行排序，以此类推，反复的分割数组，直到得到的子数组是一个数据项，那这就是这个递归算法的边界值，也就是假定一个数据项的元素是有序的。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1649288565696.png)



![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1649288602249.png)



#### 消除递归

把递归转变成非递归算法

**题目： 求1+2+3+4+....+n的值：**

递归来分析这个问题：**1+2+3+4+....+n=n+(n-1+....+1)**

递归和栈有着紧密的联系，而且大多数编译器都是用栈来实现递归的，这里我们就模拟一下底层编译器的处理方法来转换递归算法。

**递归：**

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1649288677310.png)

**非递归：**

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1649288715978.png)

#### 求一个数的乘方

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1649288812543.png)

求x的y次方的值，当y是偶数的时候，最后能转换成两个数相乘，当时当y是奇数的时候，最后我们必须要在返回值后面额外的乘以一个x。

x^y= (x^2)^(y/2)，定义a=x^2,b=y/2, 则得到形如： x^y= a^b;

具体算法：

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1649288849057.png)

#### 背包问题

在最简单的形式中，包括试图将不同重量的数据项放到背包中，以使得背包最后达到指定的总重量。

假设想要让背包精确地承重20磅，并且有 5 个可以放入的数据项，它们的重量分别是 11 磅，8 磅，7 磅，6 磅，5 磅。



算法的关键点：

1、递归的边界：

 选择的数据项的总和符合目标重量——找到

 试验了所有的组合没有符合目标重量——没找到

2、怎么递归：

从选择的第一个数据项开始，剩余的数据项的和必须符合背包的目标重量减去第一个数据项的重量——递归

如果没有合适的组合，放弃第一个数据项，并且从第二个数据项开始再重复一遍整个过程——递归

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1649632358565.png)







#### 组合问题

> 有5个登山队员，名称为 A,B,C,D和E。想要从这五个队员中选择三个队员去登峰，这时候如何列出所有的队员组合。（不考虑顺序）

　　还是以递归的思想来解决：首先这五个人的组合选择三个人分成两个部分，第一部分包含A队员，第二部分不包含A队员。假设把从 5 个人中选出 3 个人的组合简写为（5,3），规定 n 是这群人的大小，并且 k 是组队的大小。那么根据组合公式可以有：

　　(n,k) = (n-1,k-1) + (n-1,k)



对于从 5 个人中选择 3 个人，有：

　　(5,3) = (4,2)+(4,3)

　　(4,2)表示已经有A队员了，然后从剩下的4个队员中选择2个队员，(4,3)表示从5个人中剔除A队员，从剩下的4个队员中选择3个队员，这两种情况相加就是从5个队员中选择3个队员。

　　现在已经把一个大问题转换为两个小问题了。从4个人的人群中做两次选择（一次选择2个，一次选择3个），而不是从5个人的人群中选择3个。

　　从4个人的人群中选择2个人，又可以表示为：(4,2) = (3,1) + (3,2)，以此类推，很容易想到递归的思想。

![img](img_%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/clipboard-1649634369445.png)











### 分治算法

当我们求解某些问题时，由于这些问题要处理的数据相当多，或求解过程相当复杂，使得直接求解花费时间会相当长，或者根本无法直接求出。对于这类问题，我们往往先把它分解成几个子问题，找到求出这几个子问题的解法后，再找到合适的方法，把它们组合成求整个问题的解法。这就是分治策略的基本思想。

递归的二分查找法就是一个分治算法的典型例子，在这个方法中含有两个对自身的递归调用，分别对应于问题的两个部分。二分查找中，将查找范围分成比查找值大的一部分和比查找值小的一部分，每次递归调用只会有一个部分执行。





























































